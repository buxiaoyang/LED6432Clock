
LED3264.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00003218  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000024  00800060  00003218  000032ac  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000224  00800084  00800084  000032d0  2**0
                  ALLOC
  3 .debug_aranges 00000020  00000000  00000000  000032d0  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 00000707  00000000  00000000  000032f0  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001bda  00000000  00000000  000039f7  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000003c0  00000000  00000000  000055d1  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002894  00000000  00000000  00005991  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  000003c0  00000000  00000000  00008228  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000073f  00000000  00000000  000085e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    00000b36  00000000  00000000  00008d27  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  0000985d  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 ef 07 	jmp	0xfde	; 0xfde <__ctors_end>
       4:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
       8:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
       c:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      10:	0c 94 ba 12 	jmp	0x2574	; 0x2574 <__vector_4>
      14:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      18:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      1c:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      20:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      24:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      28:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      2c:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      30:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      34:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      38:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      3c:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      40:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      44:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      48:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      4c:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>
      50:	0c 94 0c 08 	jmp	0x1018	; 0x1018 <__bad_interrupt>

00000054 <BIG_NUMBER_STYLE1>:
      54:	07 80 0f c0 3f e0 38 70 70 70 70 38 70 38 60 38     ....?.8pppp8p8`8
      64:	e0 38 e0 38 e0 38 e0 38 e0 38 60 38 70 38 70 30     .8.8.8.8.8`8p8p0
      74:	70 70 3c e0 1f e0 0f 80 06 00 03 00 1f 00 ff 00     pp<.............
      84:	ff 00 c7 00 07 00 07 00 07 00 07 00 07 00 07 00     ................
      94:	07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 00     ................
      a4:	7f f8 7f f8 0f c0 3f f0 3f f8 30 38 00 38 00 18     ......?.?.08.8..
      b4:	00 18 00 38 00 38 00 38 00 70 00 e0 01 c0 03 80     ...8.8.8.p......
      c4:	07 00 0e 00 1c 00 38 00 70 00 7f f8 7f f8 1f 80     ......8.p.......
      d4:	3f e0 3f f0 20 78 00 38 00 38 00 70 00 e0 1f c0     ?.?. x.8.8.p....
      e4:	1f c0 1f f0 00 38 00 38 00 38 00 38 00 38 00 38     .....8.8.8.8.8.8
      f4:	60 f0 7f f0 7f c0 0e 00 01 e0 01 e0 03 e0 03 e0     `...............
     104:	06 e0 0e e0 1c e0 18 e0 30 e0 70 e0 60 e0 e0 e0     ........0.p.`...
     114:	c0 e0 ff f8 ff f8 ff f8 00 e0 00 e0 00 e0 00 e0     ................
     124:	00 e0 3f f8 3f f8 3f f8 38 00 38 00 38 00 38 00     ..?.?.?.8.8.8.8.
     134:	3f 80 3f e0 3f f0 00 78 00 38 00 38 00 18 00 18     ?.?.?..x.8.8....
     144:	00 18 00 38 70 f0 7f f0 3f c0 0e 00 03 c0 0f e0     ...8p...?.......
     154:	1f f0 3c 00 70 00 70 00 e0 00 e7 c0 ff e0 ff f0     ..<.p.p.........
     164:	f0 78 e0 38 e0 38 e0 38 e0 38 e0 38 70 78 78 70     .x.8.8.8.8.8pxxp
     174:	3f e0 1f c0 07 00 ff f8 ff f8 ff f0 00 70 00 70     ?............p.p
     184:	00 60 00 e0 00 c0 01 c0 01 c0 03 80 03 80 03 00     .`..............
     194:	07 00 07 00 0e 00 0e 00 1c 00 1c 00 1c 00 38 00     ..............8.
     1a4:	0f 80 3f e0 7f f0 70 70 e0 70 e0 70 70 70 79 e0     ..?...pp.p.pppy.
     1b4:	1f c0 1f 80 3f e0 70 f0 e0 70 e0 38 c0 38 e0 38     ....?.p..p.8.8.8
     1c4:	e0 38 f0 f0 7f f0 3f c0 06 00 1f 80 3f c0 7f e0     .8....?.....?...
     1d4:	e0 70 e0 70 c0 30 c0 38 e0 38 e0 78 f0 f8 7f f8     .p.p.0.8.8.x....
     1e4:	3f b8 00 30 00 30 00 70 00 70 00 e0 43 e0 7f c0     ?..0.0.p.p..C...
     1f4:	7f 00 1c 00                                         ....

000001f8 <BIG_NUMBER_STYLE2>:
     1f8:	ff f8 ff f8 ff f8 e0 38 e0 38 e0 38 e0 38 e0 38     .......8.8.8.8.8
     208:	e0 38 e0 38 e0 38 e0 38 e0 38 e0 38 e0 38 e0 38     .8.8.8.8.8.8.8.8
     218:	e0 38 e0 38 ff f8 ff f8 ff f8 07 00 07 00 07 00     .8.8............
     228:	07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 00     ................
     238:	07 00 07 00 07 00 07 00 07 00 07 00 07 00 07 00     ................
     248:	07 00 07 00 ff f8 ff f8 ff f8 00 38 00 38 00 38     ...........8.8.8
     258:	00 38 00 38 00 38 ff f8 ff f8 ff f8 e0 00 e0 00     .8.8.8..........
     268:	e0 00 e0 00 e0 00 e0 00 ff f8 ff f8 ff f8 ff f8     ................
     278:	ff f8 ff f8 00 38 00 38 00 38 00 38 00 38 00 38     .....8.8.8.8.8.8
     288:	ff f8 ff f8 ff f8 00 38 00 38 00 38 00 38 00 38     .......8.8.8.8.8
     298:	00 38 ff f8 ff f8 ff f8 e0 38 e0 38 e0 38 e0 38     .8.......8.8.8.8
     2a8:	e0 38 e0 38 e0 38 e0 38 e0 38 ff f8 ff f8 ff f8     .8.8.8.8.8......
     2b8:	00 38 00 38 00 38 00 38 00 38 00 38 00 38 00 38     .8.8.8.8.8.8.8.8
     2c8:	00 38 ff f8 ff f8 ff f8 e0 00 e0 00 e0 00 e0 00     .8..............
     2d8:	e0 00 e0 00 ff f8 ff f8 ff f8 00 38 00 38 00 38     ...........8.8.8
     2e8:	00 38 00 38 00 38 ff f8 ff f8 ff f8 ff f8 ff f8     .8.8.8..........
     2f8:	ff f8 e0 00 e0 00 e0 00 e0 00 e0 00 e0 00 ff f8     ................
     308:	ff f8 ff f8 e0 38 e0 38 e0 38 e0 38 e0 38 e0 38     .....8.8.8.8.8.8
     318:	ff f8 ff f8 ff f8 ff f8 ff f8 ff f8 00 38 00 38     .............8.8
     328:	00 38 00 38 00 38 00 38 00 38 00 38 00 38 00 38     .8.8.8.8.8.8.8.8
     338:	00 38 00 38 00 38 00 38 00 38 00 38 00 38 00 38     .8.8.8.8.8.8.8.8
     348:	ff f8 ff f8 ff f8 e0 38 e0 38 e0 38 e0 38 e0 38     .......8.8.8.8.8
     358:	e0 38 ff f8 ff f8 ff f8 e0 38 e0 38 e0 38 e0 38     .8.......8.8.8.8
     368:	e0 38 e0 38 ff f8 ff f8 ff f8 ff f8 ff f8 ff f8     .8.8............
     378:	e0 38 e0 38 e0 38 e0 38 e0 38 e0 38 ff f8 ff f8     .8.8.8.8.8.8....
     388:	ff f8 00 38 00 38 00 38 00 38 00 38 00 38 ff f8     ...8.8.8.8.8.8..
     398:	ff f8 ff f8                                         ....

0000039c <BIG_NUMBER_STYLE3>:
     39c:	3f e0 7f f0 ff f8 e0 38 e0 38 e0 38 e0 38 e0 38     ?......8.8.8.8.8
     3ac:	e0 38 e0 38 e0 38 e0 38 e0 38 e0 38 e0 38 e0 38     .8.8.8.8.8.8.8.8
     3bc:	e0 38 e0 38 ff f8 7f f0 3f e0 07 00 0f 00 1f 00     .8.8....?.......
     3cc:	1f 00 1f 00 07 00 07 00 07 00 07 00 07 00 07 00     ................
     3dc:	07 00 07 00 07 00 07 00 07 00 07 00 07 00 ff f8     ................
     3ec:	ff f8 ff f8 3f e0 7f f0 ff f8 e0 38 00 38 00 38     ....?......8.8.8
     3fc:	00 38 00 38 00 38 3f f8 7f f0 ff e0 e0 00 e0 00     .8.8.8?.........
     40c:	e0 00 e0 00 e0 00 e0 00 ff f8 ff f8 ff f8 3f e0     ..............?.
     41c:	7f f0 ff f8 e0 38 00 38 00 38 00 38 00 38 00 38     .....8.8.8.8.8.8
     42c:	1f f0 1f e0 1f f0 00 38 00 38 00 38 00 38 00 38     .......8.8.8.8.8
     43c:	e0 38 ff f8 7f f0 3f e0 e1 c0 e1 c0 e1 c0 e1 c0     .8....?.........
     44c:	e1 c0 e1 c0 e1 c0 e1 c0 e1 c0 ff f8 ff f8 ff f8     ................
     45c:	01 c0 01 c0 01 c0 01 c0 01 c0 01 c0 01 c0 01 c0     ................
     46c:	01 c0 ff f8 ff f8 ff f8 e0 00 e0 00 e0 00 e0 00     ................
     47c:	e0 00 e0 00 ff e0 ff f0 ff f8 00 38 00 38 00 38     ...........8.8.8
     48c:	00 38 00 38 e0 38 ff f8 7f f0 3f e0 e0 00 e0 00     .8.8.8....?.....
     49c:	e0 00 e0 00 e0 00 e0 00 e0 00 e0 00 e0 00 ff e0     ................
     4ac:	ff f0 ff f8 e0 38 e0 38 e0 38 e0 38 e0 38 e0 38     .....8.8.8.8.8.8
     4bc:	ff f8 7f f0 3f e0 ff f8 ff f8 ff f8 00 38 00 38     ....?........8.8
     4cc:	00 38 00 38 00 38 00 38 00 38 00 38 00 38 00 38     .8.8.8.8.8.8.8.8
     4dc:	00 38 00 38 00 38 00 38 00 38 00 38 00 38 00 38     .8.8.8.8.8.8.8.8
     4ec:	3f e0 7f f0 ff f8 e0 38 e0 38 e0 38 e0 38 e0 38     ?......8.8.8.8.8
     4fc:	70 70 3f e0 1f c0 3f e0 70 70 e0 38 e0 38 e0 38     pp?...?.pp.8.8.8
     50c:	e0 38 e0 38 ff f8 7f f0 3f e0 3f e0 7f f0 ff f8     .8.8....?.?.....
     51c:	e0 38 e0 38 e0 38 e0 38 e0 38 e0 38 ff f8 7f f8     .8.8.8.8.8.8....
     52c:	3f f8 00 38 00 38 00 38 00 38 00 38 00 38 00 38     ?..8.8.8.8.8.8.8
     53c:	00 38 00 38                                         .8.8

00000540 <SCROLL>:
     540:	7c 82 82 82 82 82 82 82 82 7c 10 30 50 10 10 10     |........|.0P...
     550:	10 10 10 fe 38 44 82 82 04 08 10 20 40 fe 7c 82     ....8D..... @.|.
     560:	02 02 3c 02 02 82 82 7c 06 0c 14 24 44 84 fe 04     ..<....|...$D...
     570:	04 04 fe 80 80 fc 02 02 02 82 82 7c 7c 82 80 80     ...........||...
     580:	fc 82 82 82 82 7c 7e 82 02 04 08 10 20 20 20 20     .....|~.....    
     590:	7c 82 82 82 7c 82 82 82 82 7c 7c 82 82 82 82 7e     |...|....||....~
     5a0:	02 02 82 7c 40 7e 88 7e 48 48 fe 08 08 08 7e 42     ...|@~.~HH....~B
     5b0:	42 7e 42 42 7e 42 46 82 7e 92 ba 92 ba 82 ba aa     B~BB~BF.~.......
     5c0:	ba 86 08 7e 54 7e 5c 40 5c 54 48 96 00 00 00 00     ...~T~\@\TH.....
     5d0:	fe 00 00 00 00 00 00 00 00 7e 00 00 00 ff 00 00     .........~......
     5e0:	00 7e 00 00 00 3c 00 00 00 ff ff a9 a9 a9 a9 a9     .~...<..........
     5f0:	c7 81 ff 81 7e 10 10 10 7c 14 14 14 14 ff 30 18     ....~...|.....0.
     600:	08 ff 00 24 24 66 66 c2 7f 41 41 41 7f 41 41 41     ...$$ff..AAA.AAA
     610:	41 7f 00 00 00 00 00 00 00 00 18 18 00 00 00 00     A...............
     620:	00 00 00 00 00 00 02 e2 bf a2 ea aa a2 aa e6 02     ................
     630:	38 24 24 42 bd 24 24 24 44 8c 10 ff 3c 24 3c ff     8$$B.$$$D...<$<.
     640:	81 3c 24 47 20 3e 40 be 2a ff 32 7e 02 04 40 40     .<$G >@.*.2~..@@
     650:	40 f7 55 55 55 57 50 b0 5c 14 d4 76 40 5c 54 54     @.UUUWP.\..v@\TT
     660:	68 56 7e 5a 7e ff 7e 42 7e 7e 42 ff 00 00 00 00     hV~Z~.~B~~B.....
     670:	00 60 60 00 60 60 10 10 7e 42 7e 42 7e 42 7e 42     .``.``..~B~B~B~B
     680:	04 7e 08 7e 08 ff 08 08 28 18 02 02 bf 62 3a 22     .~.~....(....b:"
     690:	7a bb 22 45 48 48 7e d4 62 54 d4 48 54 62 10 fe     z."EHH~.bT.HTb..
     6a0:	92 fe 92 92 fe 10 12 1e fe 04 08 10 fe 10 10 10     ................
     6b0:	50 30 fe 40 50 7e 52 52 52 52 52 a4 00 00 00 00     P0.@P~RRRRR.....
     6c0:	7e 7e 00 00 00 00 7e 41 41 41 7e 41 41 41 41 7e     ~~....~AAA~AAAA~
     6d0:	41 41 22 14 08 14 22 22 41 41 41 41 41 22 14 08     AA"...""AAAAA"..
     6e0:	08 08 08 08 fe 82 82 82 fe 82 82 82 82 fe 84 5f     ..............._
     6f0:	c4 5f 55 5f 44 4e 55 bf 08 ff 81 7e 04 ff 08 08     ._U_DNU....~....
     700:	38 08 24 44 ff 4e 55 55 5f 65 44 44                 8.$D.NUU_eDD

0000070c <SCROLL_STYLE1>:
     70c:	7c 82 82 82 82 82 82 82 82 7c 10 30 50 10 10 10     |........|.0P...
     71c:	10 10 10 fe 38 44 82 82 04 08 10 20 40 fe 7c 82     ....8D..... @.|.
     72c:	02 02 3c 02 02 82 82 7c 06 0c 14 24 44 84 fe 04     ..<....|...$D...
     73c:	04 04 fe 80 80 fc 02 02 02 82 82 7c 7c 82 80 80     ...........||...
     74c:	fc 82 82 82 82 7c 7e 82 02 04 08 10 20 20 20 20     .....|~.....    
     75c:	7c 82 82 82 7c 82 82 82 82 7c 7c 82 82 82 82 7e     |...|....||....~
     76c:	02 02 82 7c 40 7e 88 7e 48 48 fe 08 08 08 7e 42     ...|@~.~HH....~B
     77c:	42 7e 42 42 7e 42 46 82 7e 92 ba 92 ba 82 ba aa     B~BB~BF.~.......
     78c:	ba 86 08 7e 54 7e 5c 40 5c 54 48 96 00 00 00 00     ...~T~\@\TH.....
     79c:	fe 00 00 00 00 00 00 00 00 7e 00 00 00 ff 00 00     .........~......
     7ac:	00 7e 00 00 00 3c 00 00 00 ff ff a9 a9 a9 a9 a9     .~...<..........
     7bc:	c7 81 ff 81 7e 10 10 10 7c 14 14 14 14 ff 30 18     ....~...|.....0.
     7cc:	08 ff 00 24 24 66 66 c2 7f 41 41 41 7f 41 41 41     ...$$ff..AAA.AAA
     7dc:	41 7f 00 00 00 00 00 00 00 00 18 18 00 00 00 00     A...............
     7ec:	00 00 00 00 00 00                                   ......

000007f2 <SCROLL_STYLE2>:
     7f2:	fe 82 82 82 82 82 82 82 82 fe 10 10 10 10 10 10     ................
     802:	10 10 10 10 fe 02 02 02 02 fe 80 80 80 fe fe 02     ................
     812:	02 02 02 fe 02 02 02 fe 82 82 82 82 82 fe 02 02     ................
     822:	02 02 fe 80 80 80 80 fe 02 02 02 fe fe 80 80 80     ................
     832:	80 fe 82 82 82 fe fe 02 02 02 02 02 02 02 02 02     ................
     842:	fe 82 82 82 82 fe 82 82 82 fe fe 82 82 82 82 fe     ................
     852:	02 02 02 fe 80 fe 88 7e 48 48 fe 08 08 08 7e 42     .......~HH....~B
     862:	42 7e 42 42 7e 42 42 46 fe 92 ba 92 ba 82 ba aa     B~BB~BBF........
     872:	ba 86 df d0 10 10 10 10 10 10 10 1f 00 00 00 00     ................
     882:	fe 00 00 00 00 00 00 7c 00 00 00 00 00 00 00 fe     .......|........
     892:	fe 00 00 00 7c 00 00 00 00 fe fe aa aa aa aa ee     ....|...........
     8a2:	82 82 82 fe fe 20 20 20 fc 24 24 24 24 fe 20 10     .....   .$$$$. .
     8b2:	10 fe 44 44 44 44 44 44 7e 42 42 42 7e 42 42 42     ..DDDDDD~BBB~BBB
     8c2:	42 7e 00 00 00 00 00 00 00 00 18 18 00 00 00 00     B~..............
     8d2:	00 00 00 00 00 00                                   ......

000008d8 <SCROLL_STYLE3>:
     8d8:	7c 82 82 82 82 82 82 82 82 7c 10 30 50 10 10 10     |........|.0P...
     8e8:	10 10 10 fe 7c 82 02 02 02 7c 80 80 80 fe 7c 82     ....|....|....|.
     8f8:	02 02 02 7c 02 02 82 7c 88 88 88 88 88 fe 08 08     ...|...|........
     908:	08 08 fe 80 80 80 80 fc 02 02 82 7c 80 80 80 80     ...........|....
     918:	80 fc 82 82 82 7c fe 02 02 02 02 02 02 02 02 02     .....|..........
     928:	7c 82 82 82 82 7c 82 82 82 7c 7c 82 82 82 82 7e     |....|...||....~
     938:	02 02 02 02 40 7e 88 7e 48 48 fe 08 08 08 7e 42     ....@~.~HH....~B
     948:	42 7e 42 42 7e 42 46 82 7e 92 ba 92 ba 82 ba aa     B~BB~BF.~.......
     958:	ba 86 bc 42 40 40 40 40 40 40 42 3c 00 00 00 00     ...B@@@@@@B<....
     968:	fe 00 00 00 00 00 00 00 00 7e 00 00 00 ff 00 00     .........~......
     978:	00 7e 00 00 00 3c 00 00 00 ff ff a9 a9 a9 a9 a9     .~...<..........
     988:	c7 81 ff 81 7e 10 10 10 7c 14 14 14 14 ff 20 10     ....~...|..... .
     998:	fe 00 44 44 44 44 44 82 7e 42 42 42 7e 42 42 42     ..DDDDD.~BBB~BBB
     9a8:	42 7e 00 00 00 00 00 00 00 00 18 18 00 00 00 00     B~..............
     9b8:	00 00 00 00 00 00                                   ......

000009be <CHINESE>:
     9be:	08 40 49 40 2a 40 08 84 ff fe 19 08 2c 88 4a 88     .@I@*@......,.J.
     9ce:	10 88 fe 90 22 50 22 20 14 50 18 88 25 0e 42 04     ...."P" .P..%.B.
     9de:	02 00 01 00 3f fc 20 04 40 08 1f e0 00 40 00 80     ....?. .@....@..
     9ee:	01 04 ff fe 01 00 01 00 01 00 01 00 05 00 02 00     ................
     9fe:	00 08 04 08 7e 08 44 08 47 fe 44 08 44 08 7c 88     ....~.D.G.D.D.|.
     a0e:	44 48 44 48 44 08 44 08 7c 08 44 48 00 28 00 10     DHDHD.D.|.DH.(..
     a1e:	10 20 10 20 10 20 1c 24 21 fe 21 24 7d 24 91 24     . . . .$!.!$}$.$
     a2e:	11 24 fd fc 11 24 10 20 14 20 18 20 10 20 00 20     .$...$. . . . . 
     a3e:	00 04 7f fe 44 08 48 08 48 28 51 f8 49 28 49 28     ....D.H.H(Q.I(I(
     a4e:	45 28 45 28 45 28 69 e8 51 28 40 08 40 28 40 10     E(E(E(i.Q(@.@(@.
     a5e:	02 00 02 00 02 08 ff fc 04 00 09 00 11 08 3f fc     ..............?.
     a6e:	51 08 91 08 11 08 11 08 11 28 11 10 01 00 01 00     Q........(......
     a7e:	02 00 02 00 02 10 7f f8 42 10 42 10 7f f0 42 10     ........B.B...B.
     a8e:	42 10 7f f0 42 10 02 00 02 04 02 04 01 fc 00 00     B...B...........
     a9e:	00 00 3f f0 00 10 00 20 00 40 01 80 01 04 ff fe     ..?.... .@......
     aae:	01 00 01 00 01 00 01 00 01 00 01 00 05 00 02 00     ................
     abe:	01 f0 21 10 11 10 11 10 01 10 02 0e f4 00 13 f8     ..!.............
     ace:	11 08 11 10 10 90 10 a0 14 40 18 b0 13 0e 0c 04     .........@......
     ade:	3f f8 24 48 3f f8 01 00 7f fc 01 00 1f f0 10 10     ?.$H?...........
     aee:	1f f0 10 10 1f f0 10 10 1f f0 10 14 ff fe 00 00     ................
     afe:	00 40 40 44 37 fe 10 40 07 fc 04 44 f4 44 17 fc     .@@D7..@...D.D..
     b0e:	14 44 10 e0 11 58 12 48 14 40 28 46 47 fc 00 00     .D...X.H.@(FG...
     b1e:	01 00 00 84 3f fe 22 20 22 28 3f fc 22 20 23 e0     ....?." "(?." #.
     b2e:	20 00 2f f0 22 20 21 40 20 80 43 60 8c 1e 30 04      ./." !@ .C`..0.
     b3e:	01 08 7f fc 00 10 1f f8 10 10 10 10 1f f0 00 00     ................
     b4e:	7f fe 40 22 8f f4 08 20 08 20 08 22 10 22 60 1e     ..@"... . ."."`.
     b5e:	00 08 04 08 7e 08 44 08 47 fe 44 08 44 08 7c 88     ....~.D.G.D.D.|.
     b6e:	44 48 44 48 44 08 44 08 7c 08 44 48 00 28 00 10     DHDHD.D.|.DH.(..
     b7e:	20 04 1b fe 08 04 40 24 4f f4 48 24 48 24 48 24      .....@$O.H$H$H$
     b8e:	4f e4 48 24 48 24 48 24 4f e4 48 24 40 14 40 08     O.H$H$H$O.H$@.@.
     b9e:	08 00 08 08 1f fc 11 00 21 00 41 10 1f f8 11 00     ........!.A.....
     bae:	11 00 11 04 ff fe 01 00 01 00 01 00 01 00 01 00     ................
     bbe:	00 10 0f f8 08 10 08 10 08 10 0f f0 08 10 08 10     ................
     bce:	08 10 0f f0 08 10 08 10 10 10 10 10 20 50 40 20     ............ P@ 
     bde:	00 10 1f f8 10 10 10 10 10 10 10 10 10 10 1f f0     ................
     bee:	10 10 10 10 10 10 10 10 10 10 1f f0 10 10 00 00     ................
     bfe:	00 80 04 80 04 40 08 40 08 20 10 10 20 08 4f ee     .....@.@. .. .O.
     c0e:	84 24 04 20 04 20 04 20 04 20 08 20 11 40 20 80     .$. . . . . .@ .
     c1e:	04 20 0e 20 78 20 08 20 08 a8 fe a6 08 a2 1d 20     . . x . ....... 
     c2e:	1a 24 28 24 28 28 48 10 88 20 08 40 08 80 0b 00     .$($((H.. .@....
     c3e:	08 20 09 20 09 20 11 10 12 10 32 0e 54 04 9b f0     . . . ....2.T...
     c4e:	11 10 11 10 11 10 11 10 12 10 12 10 14 a0 10 40     ...............@
     c5e:	00 08 3f fc 20 08 3f f8 20 08 3f f8 01 00 21 08     ..?. .?. .?...!.
     c6e:	3f fc 21 00 41 10 bf f8 01 00 01 04 ff fe 00 00     ?.!.A...........
     c7e:	22 04 22 7e 22 44 7f 44 22 44 3e 7c 22 44 3e 44     "."~"D.D"D>|"D>D
     c8e:	22 44 22 7c ff c4 00 44 24 44 22 84 41 14 82 08     "D"|...D$D".A...
     c9e:	00 08 3f fc 21 08 21 48 2f e8 21 08 21 28 3f f8     ..?.!.!H/.!.!(?.
     cae:	20 48 27 e8 24 48 24 48 24 48 47 c8 84 28 00 10      H'.$H$H$HG..(..
     cbe:	01 00 02 00 04 10 1f f8 10 10 10 10 1f f0 10 10     ................
     cce:	10 10 10 10 1f f0 10 10 10 10 10 10 1f f0 10 10     ................
     cde:	00 10 00 f8 7f 00 01 00 01 10 3f f8 01 00 01 00     ..........?.....
     cee:	01 04 ff fe 01 00 01 00 01 00 01 00 05 00 02 00     ................
     cfe:	00 40 08 40 7c 40 00 44 05 fe fe 44 10 44 10 44     .@.@|@.D...D.D.D
     d0e:	20 44 24 44 42 84 fe 84 41 04 01 04 02 28 04 10      D$DB...A....(..
     d1e:	02 00 01 00 3f fc 20 04 40 08 1f e0 00 40 00 80     ....?. .@....@..
     d2e:	01 04 ff fe 01 00 01 00 01 00 01 00 05 00 02 00     ................
     d3e:	10 80 10 80 10 80 20 88 2f fc 62 a0 a2 a0 24 90     ...... ./.b...$.
     d4e:	24 90 28 88 2b ee 30 84 20 80 20 80 20 80 20 80     $.(.+.0. . . . .
     d5e:	10 40 10 20 10 04 13 fe fc 00 10 88 31 06 3a 8a     .@. ........1.:.
     d6e:	54 88 50 50 90 50 10 20 10 50 10 88 13 0e 1c 04     T.PP.P. .P......
     d7e:	10 00 10 00 10 04 12 7e ff 44 12 44 12 44 12 44     .......~.D.D.D.D
     d8e:	12 44 22 44 22 44 22 44 22 44 4a 7c 84 44 00 00     .D"D"D"D"DJ|.D..
     d9e:	00 10 40 18 30 14 17 fe 04 10 04 10 0d d0 14 14     ..@.0...........
     dae:	25 d4 e5 54 25 54 25 58 25 d0 25 2a 08 46 10 82     %..T%T%X%.%*.F..
     dbe:	10 00 10 08 1f fc 20 10 5f f8 12 10 11 10 10 14     ...... ._.......
     dce:	ff fe 12 10 21 10 20 10 3f f8 00 20 00 a0 00 40     ....!. .?.. ...@
     dde:	10 04 09 fe 7f 20 22 44 14 fe 7f 84 44 94 48 94     ..... "D....D.H.
     dee:	52 94 44 a4 48 a4 52 a4 44 a4 48 48 90 86 21 02     R.D.H.R.D.HH..!.
     dfe:	04 00 04 00 07 f0 08 20 08 48 1f fc 28 88 48 88     ....... .H..(.H.
     e0e:	08 88 0f f8 08 08 08 00 08 02 08 02 07 fe 00 00     ................
     e1e:	10 10 08 20 04 48 3f fc 21 08 21 08 3f f8 21 08     ... .H?.!.!.?.!.
     e2e:	21 08 3f f8 21 00 01 04 ff fe 01 00 01 00 01 00     !.?.!...........
     e3e:	10 00 10 08 23 fc 20 20 44 20 f8 20 10 20 20 20     ....#.  D . .   
     e4e:	40 20 fc 20 40 20 00 20 1c 20 e0 24 47 fe 00 00     @ . @ . . .$G...
     e5e:	10 08 13 fc 20 08 21 f8 44 08 ff fe 10 40 22 44     .... .!.D....@"D
     e6e:	41 4c f9 50 00 e0 01 50 1a 48 e4 4e 41 44 00 80     AL.P...P.H.NAD..
     e7e:	04 40 04 50 3f f8 04 40 04 44 ff fe 01 10 1f f8     .@.P?..@.D......
     e8e:	11 10 1f f0 11 10 1f f0 10 00 04 60 18 18 60 04     ...........`..`.
     e9e:	02 00 01 04 3f fe 20 00 20 70 2f 80 28 80 28 88     ....?. . p/.(.(.
     eae:	2f fc 28 80 28 80 28 40 4a 40 4d a4 88 94 00 0c     /.(.(.(@J@M.....
     ebe:	00 08 4f fc 21 00 21 10 07 f8 02 10 e2 14 3f fe     ..O.!.!.......?.
     ece:	20 00 20 08 27 fc 24 08 2c 08 34 08 27 f8 04 08      . .'.$.,.4.'...
     ede:	02 00 01 10 3f f8 08 20 04 20 04 44 ff fe 00 10     ....?.. . .D....
     eee:	1f f8 10 10 10 10 1f f0 10 10 10 10 1f f0 10 10     ................
     efe:	10 08 11 fc 11 08 11 08 fd 28 11 10 15 00 19 f8     .........(......
     f0e:	31 08 d1 90 11 50 11 20 11 50 11 8e 51 04 21 00     1....P. .P..Q.!.
     f1e:	00 08 7f fc 01 00 01 00 01 00 01 00 11 10 11 f8     ................
     f2e:	11 00 11 00 11 00 11 00 11 00 11 04 ff fe 00 00     ................
     f3e:	01 00 11 10 09 20 7f fe 40 02 8f e4 08 20 0f e0     ..... ..@.... ..
     f4e:	01 10 1f f8 11 10 11 10 11 10 11 50 01 20 01 00     ...........P. ..
     f5e:	10 00 10 00 10 04 1f fe 24 44 44 44 84 44 08 44     ........$DDD.D.D
     f6e:	08 84 08 84 10 84 11 04 21 04 42 04 04 28 08 10     ........!.B..(..
     f7e:	10 40 10 50 10 48 10 40 fc 44 13 fe 14 40 18 60     .@.P.H.@.D...@.`
     f8e:	30 a0 d0 a0 10 a0 10 a0 11 22 11 22 52 1e 24 00     0........"."R.$.
     f9e:	10 10 08 18 04 20 04 48 7f fc 01 00 01 00 01 04     ..... .H........
     fae:	ff fe 01 00 02 80 02 80 04 40 08 30 30 0e c0 04     .........@.00...
     fbe:	20 04 1b fe 08 04 40 84 40 a4 5f f4 40 84 41 84      .....@.@._.@.A.
     fce:	42 84 44 84 48 84 50 84 40 84 42 84 41 14 40 08     B.D.H.P.@.B.A.@.

00000fde <__ctors_end>:
     fde:	11 24       	eor	r1, r1
     fe0:	1f be       	out	0x3f, r1	; 63
     fe2:	cf e5       	ldi	r28, 0x5F	; 95
     fe4:	d4 e0       	ldi	r29, 0x04	; 4
     fe6:	de bf       	out	0x3e, r29	; 62
     fe8:	cd bf       	out	0x3d, r28	; 61

00000fea <__do_copy_data>:
     fea:	10 e0       	ldi	r17, 0x00	; 0
     fec:	a0 e6       	ldi	r26, 0x60	; 96
     fee:	b0 e0       	ldi	r27, 0x00	; 0
     ff0:	e8 e1       	ldi	r30, 0x18	; 24
     ff2:	f2 e3       	ldi	r31, 0x32	; 50
     ff4:	02 c0       	rjmp	.+4      	; 0xffa <.do_copy_data_start>

00000ff6 <.do_copy_data_loop>:
     ff6:	05 90       	lpm	r0, Z+
     ff8:	0d 92       	st	X+, r0

00000ffa <.do_copy_data_start>:
     ffa:	a4 38       	cpi	r26, 0x84	; 132
     ffc:	b1 07       	cpc	r27, r17
     ffe:	d9 f7       	brne	.-10     	; 0xff6 <.do_copy_data_loop>

00001000 <__do_clear_bss>:
    1000:	12 e0       	ldi	r17, 0x02	; 2
    1002:	a4 e8       	ldi	r26, 0x84	; 132
    1004:	b0 e0       	ldi	r27, 0x00	; 0
    1006:	01 c0       	rjmp	.+2      	; 0x100a <.do_clear_bss_start>

00001008 <.do_clear_bss_loop>:
    1008:	1d 92       	st	X+, r1

0000100a <.do_clear_bss_start>:
    100a:	a8 3a       	cpi	r26, 0xA8	; 168
    100c:	b1 07       	cpc	r27, r17
    100e:	e1 f7       	brne	.-8      	; 0x1008 <.do_clear_bss_loop>
    1010:	0e 94 4e 18 	call	0x309c	; 0x309c <main>
    1014:	0c 94 0a 19 	jmp	0x3214	; 0x3214 <_exit>

00001018 <__bad_interrupt>:
    1018:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000101c <s_10us>:
	for(;_10us>=1;_10us--)
	{
		for(aa=0;aa<=66;aa++)
		{;}
	}
}	
    101c:	08 95       	ret

0000101e <_delay_100ms>:
{
	for(;_100ms>=1;_100ms--)
	{
		s_10us(10000);
	}
}
    101e:	08 95       	ret

00001020 <ds1820_reset>:
//DS18B20复位
void ds1820_reset(void) 
{
	unsigned char i;
	//中断保护
	init_f = SREG;    
    1020:	8f b7       	in	r24, 0x3f	; 63
    1022:	80 93 90 00 	sts	0x0090, r24
	//关中断
	cli();      
    1026:	f8 94       	cli
	DQ_OUT;
    1028:	8f 9a       	sbi	0x11, 7	; 17
	DQ_LO;
    102a:	97 98       	cbi	0x12, 7	; 18
	s_10us(60);    //延时600us
	DQ_HI;
    102c:	97 9a       	sbi	0x12, 7	; 18
	DQ_INPUT;
    102e:	8f 98       	cbi	0x11, 7	; 17
	s_10us(5);     //延时50us
	i = DQ_R;
    1030:	90 b3       	in	r25, 0x10	; 16
	s_10us(50);    //延时500us
	if (init_f & 0x80)  //恢复中断状态
    1032:	87 ff       	sbrs	r24, 7
    1034:	01 c0       	rjmp	.+2      	; 0x1038 <ds1820_reset+0x18>
	{   
		sei();        
    1036:	78 94       	sei
    1038:	08 95       	ret

0000103a <ds1820_read_byte>:
unsigned char ds1820_read_byte(void) 
{
	unsigned char i;
	unsigned char value = 0;
	//中断保护
	init_f = SREG;
    103a:	2f b7       	in	r18, 0x3f	; 63
    103c:	20 93 90 00 	sts	0x0090, r18
	//关中断    
	cli();      
    1040:	f8 94       	cli
    1042:	98 e0       	ldi	r25, 0x08	; 8
    1044:	80 e0       	ldi	r24, 0x00	; 0
	for (i = 8; i != 0; i--) 
	{
		value >>= 1;
    1046:	86 95       	lsr	r24
		DQ_OUT;
    1048:	8f 9a       	sbi	0x11, 7	; 17
		DQ_LO;
    104a:	97 98       	cbi	0x12, 7	; 18
		s_10us(1);
		DQ_HI;
    104c:	97 9a       	sbi	0x12, 7	; 18
		DQ_INPUT;
    104e:	8f 98       	cbi	0x11, 7	; 17
		s_10us(1);
		if (DQ_R) 
    1050:	87 99       	sbic	0x10, 7	; 16
		{
			value|=0x80;
    1052:	80 68       	ori	r24, 0x80	; 128
	unsigned char value = 0;
	//中断保护
	init_f = SREG;
	//关中断    
	cli();      
	for (i = 8; i != 0; i--) 
    1054:	91 50       	subi	r25, 0x01	; 1
    1056:	b9 f7       	brne	.-18     	; 0x1046 <ds1820_read_byte+0xc>
		{
			value|=0x80;
		}
		s_10us(3);   //延时30us
	}
	if (init_f & 0x80) //恢复中断状态
    1058:	27 ff       	sbrs	r18, 7
    105a:	01 c0       	rjmp	.+2      	; 0x105e <ds1820_read_byte+0x24>
	{   
		sei();
    105c:	78 94       	sei
	}
	return(value);
}
    105e:	08 95       	ret

00001060 <ds1820_write_byte>:
//DS18B20字节写入
void ds1820_write_byte(unsigned char value) 
{
	unsigned char i;
	//中断保护
	init_f = SREG;   
    1060:	2f b7       	in	r18, 0x3f	; 63
    1062:	20 93 90 00 	sts	0x0090, r18
	//关中断 
	cli();      
    1066:	f8 94       	cli
    1068:	98 e0       	ldi	r25, 0x08	; 8
	for (i = 8; i != 0; i--) 
	{
		DQ_OUT;
    106a:	8f 9a       	sbi	0x11, 7	; 17
		DQ_LO;
    106c:	97 98       	cbi	0x12, 7	; 18
		s_10us(1); //延时10us
		if (value & 0x01) 
    106e:	80 fd       	sbrc	r24, 0
		{
			DQ_HI;
    1070:	97 9a       	sbi	0x12, 7	; 18
		}
		s_10us(4);   //延时40us
		DQ_HI;     
    1072:	97 9a       	sbi	0x12, 7	; 18
	unsigned char i;
	//中断保护
	init_f = SREG;   
	//关中断 
	cli();      
	for (i = 8; i != 0; i--) 
    1074:	91 50       	subi	r25, 0x01	; 1
    1076:	11 f0       	breq	.+4      	; 0x107c <ds1820_write_byte+0x1c>
		{
			DQ_HI;
		}
		s_10us(4);   //延时40us
		DQ_HI;     
		value >>= 1;
    1078:	86 95       	lsr	r24
    107a:	f7 cf       	rjmp	.-18     	; 0x106a <ds1820_write_byte+0xa>
	}
	if (init_f & 0x80)//恢复中断状态
    107c:	27 ff       	sbrs	r18, 7
    107e:	01 c0       	rjmp	.+2      	; 0x1082 <ds1820_write_byte+0x22>
	{   
		sei();
    1080:	78 94       	sei
    1082:	08 95       	ret

00001084 <ds1820_start>:
}

//启动ds1820转换
void ds1820_start(void) 
{
	ds1820_reset();
    1084:	0e 94 10 08 	call	0x1020	; 0x1020 <ds1820_reset>
	ds1820_write_byte(0xCC); //勿略ROM
    1088:	8c ec       	ldi	r24, 0xCC	; 204
    108a:	0e 94 30 08 	call	0x1060	; 0x1060 <ds1820_write_byte>
	ds1820_write_byte(0x44); //启动转换
    108e:	84 e4       	ldi	r24, 0x44	; 68
    1090:	0e 94 30 08 	call	0x1060	; 0x1060 <ds1820_write_byte>
}
    1094:	08 95       	ret

00001096 <ReadTemputer>:

//读温度
void ReadTemputer(void)
 {
    1096:	1f 93       	push	r17
	unsigned int i,tem3,tem2,tem1;
	unsigned char buf[2], NegativeTem;
	ds1820_reset();
    1098:	0e 94 10 08 	call	0x1020	; 0x1020 <ds1820_reset>
	ds1820_write_byte(0xCC); //勿略ROM
    109c:	8c ec       	ldi	r24, 0xCC	; 204
    109e:	0e 94 30 08 	call	0x1060	; 0x1060 <ds1820_write_byte>
	ds1820_write_byte(0xBE); //读温度
    10a2:	8e eb       	ldi	r24, 0xBE	; 190
    10a4:	0e 94 30 08 	call	0x1060	; 0x1060 <ds1820_write_byte>
	for (i = 0; i < 2; i++) {
		buf[i] = ds1820_read_byte();
    10a8:	0e 94 1d 08 	call	0x103a	; 0x103a <ds1820_read_byte>
    10ac:	18 2f       	mov	r17, r24
    10ae:	0e 94 1d 08 	call	0x103a	; 0x103a <ds1820_read_byte>
	}
	//uart_send_char(buf[0]);
	//uart_send_char(buf[1]);
	//uart_send_char(0XAA);
	i = buf[1];
	i <<= 8;
    10b2:	38 2f       	mov	r19, r24
    10b4:	20 e0       	ldi	r18, 0x00	; 0
	i |= buf[0];
    10b6:	e1 2f       	mov	r30, r17
    10b8:	f0 e0       	ldi	r31, 0x00	; 0
    10ba:	e2 2b       	or	r30, r18
    10bc:	f3 2b       	or	r31, r19
	if((i & 0xF000) == 0xF000) //负温度
    10be:	cf 01       	movw	r24, r30
    10c0:	80 70       	andi	r24, 0x00	; 0
    10c2:	90 7f       	andi	r25, 0xF0	; 240
    10c4:	80 50       	subi	r24, 0x00	; 0
    10c6:	90 4f       	sbci	r25, 0xF0	; 240
    10c8:	11 f0       	breq	.+4      	; 0x10ce <ReadTemputer+0x38>
    10ca:	40 e0       	ldi	r20, 0x00	; 0
    10cc:	04 c0       	rjmp	.+8      	; 0x10d6 <ReadTemputer+0x40>
	{
		NegativeTem = 1;
		i = ~i;
		i = i + 1;
    10ce:	f0 95       	com	r31
    10d0:	e1 95       	neg	r30
    10d2:	ff 4f       	sbci	r31, 0xFF	; 255
    10d4:	41 e0       	ldi	r20, 0x01	; 1
	{
		NegativeTem = 0;
	}
	tem1 = i & 0x000f;
	tem1 = (tem1*625)/1000;
	i = (i * 10) / 16;        //数值处理  
    10d6:	cf 01       	movw	r24, r30
    10d8:	88 0f       	add	r24, r24
    10da:	99 1f       	adc	r25, r25
    10dc:	9f 01       	movw	r18, r30
    10de:	53 e0       	ldi	r21, 0x03	; 3
    10e0:	22 0f       	add	r18, r18
    10e2:	33 1f       	adc	r19, r19
    10e4:	5a 95       	dec	r21
    10e6:	e1 f7       	brne	.-8      	; 0x10e0 <ReadTemputer+0x4a>
    10e8:	82 0f       	add	r24, r18
    10ea:	93 1f       	adc	r25, r19
	//第3位没有显示
	i = i % 1000;  
    10ec:	24 e0       	ldi	r18, 0x04	; 4
    10ee:	96 95       	lsr	r25
    10f0:	87 95       	ror	r24
    10f2:	2a 95       	dec	r18
    10f4:	e1 f7       	brne	.-8      	; 0x10ee <ReadTemputer+0x58>
    10f6:	68 ee       	ldi	r22, 0xE8	; 232
    10f8:	73 e0       	ldi	r23, 0x03	; 3
    10fa:	0e 94 f6 18 	call	0x31ec	; 0x31ec <__udivmodhi4>
    10fe:	9c 01       	movw	r18, r24
	//显示第2位
	tem3= i / 100;
	if(NegativeTem == 1)
    1100:	41 30       	cpi	r20, 0x01	; 1
    1102:	21 f4       	brne	.+8      	; 0x110c <ReadTemputer+0x76>
	{
		TemperatureTen = 14; // - 符号
    1104:	8e e0       	ldi	r24, 0x0E	; 14
    1106:	80 93 6f 00 	sts	0x006F, r24
    110a:	06 c0       	rjmp	.+12     	; 0x1118 <ReadTemputer+0x82>
	}
	else
	{
		TemperatureTen = tem3;
    110c:	64 e6       	ldi	r22, 0x64	; 100
    110e:	70 e0       	ldi	r23, 0x00	; 0
    1110:	0e 94 f6 18 	call	0x31ec	; 0x31ec <__udivmodhi4>
    1114:	60 93 6f 00 	sts	0x006F, r22
	}
	i = i % 100;  
	//显示第1位
	tem2= i / 10;
	TemperatureOne = tem2;
    1118:	c9 01       	movw	r24, r18
    111a:	64 e6       	ldi	r22, 0x64	; 100
    111c:	70 e0       	ldi	r23, 0x00	; 0
    111e:	0e 94 f6 18 	call	0x31ec	; 0x31ec <__udivmodhi4>
    1122:	6a e0       	ldi	r22, 0x0A	; 10
    1124:	70 e0       	ldi	r23, 0x00	; 0
    1126:	0e 94 f6 18 	call	0x31ec	; 0x31ec <__udivmodhi4>
    112a:	60 93 70 00 	sts	0x0070, r22
	else
	{
		NegativeTem = 0;
	}
	tem1 = i & 0x000f;
	tem1 = (tem1*625)/1000;
    112e:	ef 70       	andi	r30, 0x0F	; 15
    1130:	f0 70       	andi	r31, 0x00	; 0
	}
	i = i % 100;  
	//显示第1位
	tem2= i / 10;
	TemperatureOne = tem2;
	TemperatureDecimal = tem1;
    1132:	81 e7       	ldi	r24, 0x71	; 113
    1134:	92 e0       	ldi	r25, 0x02	; 2
    1136:	9c 01       	movw	r18, r24
    1138:	e2 9f       	mul	r30, r18
    113a:	c0 01       	movw	r24, r0
    113c:	e3 9f       	mul	r30, r19
    113e:	90 0d       	add	r25, r0
    1140:	f2 9f       	mul	r31, r18
    1142:	90 0d       	add	r25, r0
    1144:	11 24       	eor	r1, r1
    1146:	68 ee       	ldi	r22, 0xE8	; 232
    1148:	73 e0       	ldi	r23, 0x03	; 3
    114a:	0e 94 f6 18 	call	0x31ec	; 0x31ec <__udivmodhi4>
    114e:	60 93 71 00 	sts	0x0071, r22
}
    1152:	1f 91       	pop	r17
    1154:	08 95       	ret

00001156 <SaveRunParameter>:
#ifndef _EEPROM_SELF_H_
#define _EEPROM_SELF_H_

void SaveRunParameter()
{
	cli(); //关闭所有中断
    1156:	f8 94       	cli
	if(eeprom_is_ready())
    1158:	e1 99       	sbic	0x1c, 1	; 28
    115a:	97 c0       	rjmp	.+302    	; 0x128a <SaveRunParameter+0x134>
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    115c:	e1 99       	sbic	0x1c, 1	; 28
    115e:	fe cf       	rjmp	.-4      	; 0x115c <SaveRunParameter+0x6>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1160:	1f ba       	out	0x1f, r1	; 31
    1162:	1e ba       	out	0x1e, r1	; 30
#endif
    EEDR = __value;
    1164:	8c ec       	ldi	r24, 0xCC	; 204
    1166:	8d bb       	out	0x1d, r24	; 29

    __asm__ __volatile__ (
    1168:	0f b6       	in	r0, 0x3f	; 63
    116a:	f8 94       	cli
    116c:	e2 9a       	sbi	0x1c, 2	; 28
    116e:	e1 9a       	sbi	0x1c, 1	; 28
    1170:	0f be       	out	0x3f, r0	; 63
	{
		eeprom_write_byte(0x00, 0xCC);
		eeprom_write_byte(0x01, display_light_Mode);
    1172:	20 91 72 00 	lds	r18, 0x0072
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1176:	e1 99       	sbic	0x1c, 1	; 28
    1178:	fe cf       	rjmp	.-4      	; 0x1176 <SaveRunParameter+0x20>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    117a:	81 e0       	ldi	r24, 0x01	; 1
    117c:	90 e0       	ldi	r25, 0x00	; 0
    117e:	9f bb       	out	0x1f, r25	; 31
    1180:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    1182:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    1184:	0f b6       	in	r0, 0x3f	; 63
    1186:	f8 94       	cli
    1188:	e2 9a       	sbi	0x1c, 2	; 28
    118a:	e1 9a       	sbi	0x1c, 1	; 28
    118c:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x02, display_light);
    118e:	20 91 73 00 	lds	r18, 0x0073
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1192:	e1 99       	sbic	0x1c, 1	; 28
    1194:	fe cf       	rjmp	.-4      	; 0x1192 <SaveRunParameter+0x3c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1196:	82 e0       	ldi	r24, 0x02	; 2
    1198:	90 e0       	ldi	r25, 0x00	; 0
    119a:	9f bb       	out	0x1f, r25	; 31
    119c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    119e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    11a0:	0f b6       	in	r0, 0x3f	; 63
    11a2:	f8 94       	cli
    11a4:	e2 9a       	sbi	0x1c, 2	; 28
    11a6:	e1 9a       	sbi	0x1c, 1	; 28
    11a8:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x03, moveSpeed);
    11aa:	20 91 74 00 	lds	r18, 0x0074
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    11ae:	e1 99       	sbic	0x1c, 1	; 28
    11b0:	fe cf       	rjmp	.-4      	; 0x11ae <SaveRunParameter+0x58>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    11b2:	83 e0       	ldi	r24, 0x03	; 3
    11b4:	90 e0       	ldi	r25, 0x00	; 0
    11b6:	9f bb       	out	0x1f, r25	; 31
    11b8:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    11ba:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    11bc:	0f b6       	in	r0, 0x3f	; 63
    11be:	f8 94       	cli
    11c0:	e2 9a       	sbi	0x1c, 2	; 28
    11c2:	e1 9a       	sbi	0x1c, 1	; 28
    11c4:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x04, Mode);
    11c6:	20 91 75 00 	lds	r18, 0x0075
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    11ca:	e1 99       	sbic	0x1c, 1	; 28
    11cc:	fe cf       	rjmp	.-4      	; 0x11ca <SaveRunParameter+0x74>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    11ce:	84 e0       	ldi	r24, 0x04	; 4
    11d0:	90 e0       	ldi	r25, 0x00	; 0
    11d2:	9f bb       	out	0x1f, r25	; 31
    11d4:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    11d6:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    11d8:	0f b6       	in	r0, 0x3f	; 63
    11da:	f8 94       	cli
    11dc:	e2 9a       	sbi	0x1c, 2	; 28
    11de:	e1 9a       	sbi	0x1c, 1	; 28
    11e0:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x05, AjustTimeMode);
    11e2:	20 91 76 00 	lds	r18, 0x0076
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    11e6:	e1 99       	sbic	0x1c, 1	; 28
    11e8:	fe cf       	rjmp	.-4      	; 0x11e6 <SaveRunParameter+0x90>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    11ea:	85 e0       	ldi	r24, 0x05	; 5
    11ec:	90 e0       	ldi	r25, 0x00	; 0
    11ee:	9f bb       	out	0x1f, r25	; 31
    11f0:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    11f2:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    11f4:	0f b6       	in	r0, 0x3f	; 63
    11f6:	f8 94       	cli
    11f8:	e2 9a       	sbi	0x1c, 2	; 28
    11fa:	e1 9a       	sbi	0x1c, 1	; 28
    11fc:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x06, AjustTimeTen);
    11fe:	20 91 77 00 	lds	r18, 0x0077
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1202:	e1 99       	sbic	0x1c, 1	; 28
    1204:	fe cf       	rjmp	.-4      	; 0x1202 <SaveRunParameter+0xac>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1206:	86 e0       	ldi	r24, 0x06	; 6
    1208:	90 e0       	ldi	r25, 0x00	; 0
    120a:	9f bb       	out	0x1f, r25	; 31
    120c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    120e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    1210:	0f b6       	in	r0, 0x3f	; 63
    1212:	f8 94       	cli
    1214:	e2 9a       	sbi	0x1c, 2	; 28
    1216:	e1 9a       	sbi	0x1c, 1	; 28
    1218:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x07, AjustTimeOne);
    121a:	20 91 78 00 	lds	r18, 0x0078
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    121e:	e1 99       	sbic	0x1c, 1	; 28
    1220:	fe cf       	rjmp	.-4      	; 0x121e <SaveRunParameter+0xc8>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1222:	87 e0       	ldi	r24, 0x07	; 7
    1224:	90 e0       	ldi	r25, 0x00	; 0
    1226:	9f bb       	out	0x1f, r25	; 31
    1228:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    122a:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	f8 94       	cli
    1230:	e2 9a       	sbi	0x1c, 2	; 28
    1232:	e1 9a       	sbi	0x1c, 1	; 28
    1234:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x08, Display_color);
    1236:	20 91 7a 00 	lds	r18, 0x007A
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    123a:	e1 99       	sbic	0x1c, 1	; 28
    123c:	fe cf       	rjmp	.-4      	; 0x123a <SaveRunParameter+0xe4>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    123e:	88 e0       	ldi	r24, 0x08	; 8
    1240:	90 e0       	ldi	r25, 0x00	; 0
    1242:	9f bb       	out	0x1f, r25	; 31
    1244:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    1246:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	f8 94       	cli
    124c:	e2 9a       	sbi	0x1c, 2	; 28
    124e:	e1 9a       	sbi	0x1c, 1	; 28
    1250:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x09, Display_BigNumber_Font);
    1252:	20 91 7b 00 	lds	r18, 0x007B
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1256:	e1 99       	sbic	0x1c, 1	; 28
    1258:	fe cf       	rjmp	.-4      	; 0x1256 <SaveRunParameter+0x100>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    125a:	89 e0       	ldi	r24, 0x09	; 9
    125c:	90 e0       	ldi	r25, 0x00	; 0
    125e:	9f bb       	out	0x1f, r25	; 31
    1260:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    1262:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    1264:	0f b6       	in	r0, 0x3f	; 63
    1266:	f8 94       	cli
    1268:	e2 9a       	sbi	0x1c, 2	; 28
    126a:	e1 9a       	sbi	0x1c, 1	; 28
    126c:	0f be       	out	0x3f, r0	; 63
		eeprom_write_byte(0x10, Voice_Mode);
    126e:	20 91 7c 00 	lds	r18, 0x007C
/** \ingroup avr_eeprom
    Write a byte \a __value to EEPROM address \a __p.
 */
static __inline__ void eeprom_write_byte (uint8_t *__p, uint8_t __value)
{
    do {} while (!eeprom_is_ready ());
    1272:	e1 99       	sbic	0x1c, 1	; 28
    1274:	fe cf       	rjmp	.-4      	; 0x1272 <SaveRunParameter+0x11c>
#endif

#if	E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1276:	80 e1       	ldi	r24, 0x10	; 16
    1278:	90 e0       	ldi	r25, 0x00	; 0
    127a:	9f bb       	out	0x1f, r25	; 31
    127c:	8e bb       	out	0x1e, r24	; 30
#endif
    EEDR = __value;
    127e:	2d bb       	out	0x1d, r18	; 29

    __asm__ __volatile__ (
    1280:	0f b6       	in	r0, 0x3f	; 63
    1282:	f8 94       	cli
    1284:	e2 9a       	sbi	0x1c, 2	; 28
    1286:	e1 9a       	sbi	0x1c, 1	; 28
    1288:	0f be       	out	0x3f, r0	; 63
	}
	sei(); //使能中断
    128a:	78 94       	sei
}
    128c:	08 95       	ret

0000128e <ReadRunParameter>:

void ReadRunParameter()
{
	cli(); //关闭所有中断
    128e:	f8 94       	cli
	if(eeprom_is_ready())
    1290:	e1 99       	sbic	0x1c, 1	; 28
    1292:	6b c0       	rjmp	.+214    	; 0x136a <ReadRunParameter+0xdc>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1294:	e1 99       	sbic	0x1c, 1	; 28
    1296:	fe cf       	rjmp	.-4      	; 0x1294 <ReadRunParameter+0x6>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1298:	1f ba       	out	0x1f, r1	; 31
    129a:	1e ba       	out	0x1e, r1	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    129c:	e0 9a       	sbi	0x1c, 0	; 28
    129e:	8d b3       	in	r24, 0x1d	; 29
	{
		if(eeprom_read_byte(0x00) == 0xCC)
    12a0:	8c 3c       	cpi	r24, 0xCC	; 204
    12a2:	09 f0       	breq	.+2      	; 0x12a6 <ReadRunParameter+0x18>
    12a4:	5a c0       	rjmp	.+180    	; 0x135a <ReadRunParameter+0xcc>
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    12a6:	e1 99       	sbic	0x1c, 1	; 28
    12a8:	fe cf       	rjmp	.-4      	; 0x12a6 <ReadRunParameter+0x18>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    12aa:	81 e0       	ldi	r24, 0x01	; 1
    12ac:	90 e0       	ldi	r25, 0x00	; 0
    12ae:	9f bb       	out	0x1f, r25	; 31
    12b0:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    12b2:	e0 9a       	sbi	0x1c, 0	; 28
    12b4:	8d b3       	in	r24, 0x1d	; 29
		{
			display_light_Mode = 	eeprom_read_byte(0x01);
    12b6:	80 93 72 00 	sts	0x0072, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    12ba:	e1 99       	sbic	0x1c, 1	; 28
    12bc:	fe cf       	rjmp	.-4      	; 0x12ba <ReadRunParameter+0x2c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    12be:	82 e0       	ldi	r24, 0x02	; 2
    12c0:	90 e0       	ldi	r25, 0x00	; 0
    12c2:	9f bb       	out	0x1f, r25	; 31
    12c4:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    12c6:	e0 9a       	sbi	0x1c, 0	; 28
    12c8:	8d b3       	in	r24, 0x1d	; 29
			display_light = 		eeprom_read_byte(0x02);
    12ca:	80 93 73 00 	sts	0x0073, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    12ce:	e1 99       	sbic	0x1c, 1	; 28
    12d0:	fe cf       	rjmp	.-4      	; 0x12ce <ReadRunParameter+0x40>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    12d2:	83 e0       	ldi	r24, 0x03	; 3
    12d4:	90 e0       	ldi	r25, 0x00	; 0
    12d6:	9f bb       	out	0x1f, r25	; 31
    12d8:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    12da:	e0 9a       	sbi	0x1c, 0	; 28
    12dc:	8d b3       	in	r24, 0x1d	; 29
			moveSpeed = 			eeprom_read_byte(0x03);
    12de:	80 93 74 00 	sts	0x0074, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    12e2:	e1 99       	sbic	0x1c, 1	; 28
    12e4:	fe cf       	rjmp	.-4      	; 0x12e2 <ReadRunParameter+0x54>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    12e6:	85 e0       	ldi	r24, 0x05	; 5
    12e8:	90 e0       	ldi	r25, 0x00	; 0
    12ea:	9f bb       	out	0x1f, r25	; 31
    12ec:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    12ee:	e0 9a       	sbi	0x1c, 0	; 28
    12f0:	8d b3       	in	r24, 0x1d	; 29
			//Mode = 					eeprom_read_byte(0x04);
			AjustTimeMode = 		eeprom_read_byte(0x05);
    12f2:	80 93 76 00 	sts	0x0076, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    12f6:	e1 99       	sbic	0x1c, 1	; 28
    12f8:	fe cf       	rjmp	.-4      	; 0x12f6 <ReadRunParameter+0x68>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    12fa:	86 e0       	ldi	r24, 0x06	; 6
    12fc:	90 e0       	ldi	r25, 0x00	; 0
    12fe:	9f bb       	out	0x1f, r25	; 31
    1300:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1302:	e0 9a       	sbi	0x1c, 0	; 28
    1304:	8d b3       	in	r24, 0x1d	; 29
			AjustTimeTen = 			eeprom_read_byte(0x06);
    1306:	80 93 77 00 	sts	0x0077, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    130a:	e1 99       	sbic	0x1c, 1	; 28
    130c:	fe cf       	rjmp	.-4      	; 0x130a <ReadRunParameter+0x7c>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    130e:	87 e0       	ldi	r24, 0x07	; 7
    1310:	90 e0       	ldi	r25, 0x00	; 0
    1312:	9f bb       	out	0x1f, r25	; 31
    1314:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1316:	e0 9a       	sbi	0x1c, 0	; 28
    1318:	8d b3       	in	r24, 0x1d	; 29
			AjustTimeOne = 			eeprom_read_byte(0x07);	
    131a:	80 93 78 00 	sts	0x0078, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    131e:	e1 99       	sbic	0x1c, 1	; 28
    1320:	fe cf       	rjmp	.-4      	; 0x131e <ReadRunParameter+0x90>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1322:	88 e0       	ldi	r24, 0x08	; 8
    1324:	90 e0       	ldi	r25, 0x00	; 0
    1326:	9f bb       	out	0x1f, r25	; 31
    1328:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    132a:	e0 9a       	sbi	0x1c, 0	; 28
    132c:	8d b3       	in	r24, 0x1d	; 29
			Display_color = 		eeprom_read_byte(0x08);
    132e:	80 93 7a 00 	sts	0x007A, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1332:	e1 99       	sbic	0x1c, 1	; 28
    1334:	fe cf       	rjmp	.-4      	; 0x1332 <ReadRunParameter+0xa4>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    1336:	89 e0       	ldi	r24, 0x09	; 9
    1338:	90 e0       	ldi	r25, 0x00	; 0
    133a:	9f bb       	out	0x1f, r25	; 31
    133c:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    133e:	e0 9a       	sbi	0x1c, 0	; 28
    1340:	8d b3       	in	r24, 0x1d	; 29
			Display_BigNumber_Font = eeprom_read_byte(0x09);
    1342:	80 93 7b 00 	sts	0x007B, r24
/** \ingroup avr_eeprom
    Read one byte from EEPROM address \a __p.
 */
__ATTR_PURE__ static __inline__ uint8_t eeprom_read_byte (const uint8_t *__p)
{
    do {} while (!eeprom_is_ready ());
    1346:	e1 99       	sbic	0x1c, 1	; 28
    1348:	fe cf       	rjmp	.-4      	; 0x1346 <ReadRunParameter+0xb8>
#if E2END <= 0xFF
    EEARL = (size_t)__p;
#else
    EEAR = (size_t)__p;
    134a:	80 e1       	ldi	r24, 0x10	; 16
    134c:	90 e0       	ldi	r25, 0x00	; 0
    134e:	9f bb       	out	0x1f, r25	; 31
    1350:	8e bb       	out	0x1e, r24	; 30
    /* Use inline assembly below as some AVRs have problems with accessing
    EECR with STS instructions. For example, see errata for ATmega64. 
    The code below also assumes that EECR and EEDR are in the I/O space.
    */
    uint8_t __result;
    __asm__ __volatile__
    1352:	e0 9a       	sbi	0x1c, 0	; 28
    1354:	8d b3       	in	r24, 0x1d	; 29
			Voice_Mode = 			eeprom_read_byte(0x10);
    1356:	80 93 7c 00 	sts	0x007C, r24
		}
		SET_DISPLAY_LIGHT;
    135a:	80 91 73 00 	lds	r24, 0x0073
    135e:	29 e1       	ldi	r18, 0x19	; 25
    1360:	82 9f       	mul	r24, r18
    1362:	c0 01       	movw	r24, r0
    1364:	11 24       	eor	r1, r1
    1366:	88 51       	subi	r24, 0x18	; 24
    1368:	8c bf       	out	0x3c, r24	; 60
	}
	sei(); //使能中断
    136a:	78 94       	sei
}
    136c:	08 95       	ret

0000136e <LED_SCREEN_INI>:
uint16  moveSpeedTimerCount;
uint16 FreshDisplayBufferCount; /*刷新显示缓存时间计数器*/

void LED_SCREEN_INI()
{
	LS138_E_DDR |= 1<<LS138_E_BIT;
    136e:	bb 9a       	sbi	0x17, 3	; 23
	LS138_A_DDR |= 1<<LS138_A_BIT;
    1370:	b8 9a       	sbi	0x17, 0	; 23
	LS138_B_DDR |= 1<<LS138_B_BIT;
    1372:	b9 9a       	sbi	0x17, 1	; 23
	LS138_C_DDR |= 1<<LS138_C_BIT;
    1374:	ba 9a       	sbi	0x17, 2	; 23
	LS138_D_DDR |= 1<<LS138_D_BIT;
    1376:	bc 9a       	sbi	0x17, 4	; 23
	HC595_D0_DDR |= 1<<HC595_D0_BIT;
    1378:	8c 9a       	sbi	0x11, 4	; 17
	HC595_D1_DDR |= 1<<HC595_D1_BIT;
    137a:	8d 9a       	sbi	0x11, 5	; 17
	HC595_D2_DDR |= 1<<HC595_D2_BIT;
    137c:	d1 9a       	sbi	0x1a, 1	; 26
	HC595_D3_DDR |= 1<<HC595_D3_BIT;
    137e:	d2 9a       	sbi	0x1a, 2	; 26
	HC595_D4_DDR |= 1<<HC595_D4_BIT;
    1380:	d3 9a       	sbi	0x1a, 3	; 26
	HC595_D5_DDR |= 1<<HC595_D5_BIT;
    1382:	d4 9a       	sbi	0x1a, 4	; 26
	HC595_LAT_DDR |= 1<<HC595_LAT_BIT;
    1384:	8a 9a       	sbi	0x11, 2	; 17
	HC595_SCK_DDR |= 1<<HC595_SCK_BIT;
    1386:	8b 9a       	sbi	0x11, 3	; 17

	display_cnt = 0;
    1388:	10 92 89 02 	sts	0x0289, r1
	halfSecondCount = 0;
    138c:	10 92 86 02 	sts	0x0286, r1
    1390:	10 92 85 02 	sts	0x0285, r1
	isSecondCountShow = 0;
    1394:	10 92 88 02 	sts	0x0288, r1
	currentMoveLeft = 0;
    1398:	10 92 8d 02 	sts	0x028D, r1
	moveSpeedTimerCount = 0;
    139c:	10 92 8f 00 	sts	0x008F, r1
    13a0:	10 92 8e 00 	sts	0x008E, r1
	FreshDisplayBufferCount = 0;
    13a4:	10 92 9b 02 	sts	0x029B, r1
    13a8:	10 92 9a 02 	sts	0x029A, r1
}
    13ac:	08 95       	ret

000013ae <writeCloclColon>:
	memset(display_buffer,0xFF,256);
}

void writeCloclColon(uint8 isSecondCountShow)
{
	if(isSecondCountShow)
    13ae:	88 23       	and	r24, r24
    13b0:	d9 f1       	breq	.+118    	; 0x1428 <writeCloclColon+0x7a>
	{
		display_buffer[36] |= 0xC0;
    13b2:	80 91 b5 00 	lds	r24, 0x00B5
    13b6:	80 6c       	ori	r24, 0xC0	; 192
    13b8:	80 93 b5 00 	sts	0x00B5, r24
		display_buffer[44] |= 0xC0;
    13bc:	80 91 bd 00 	lds	r24, 0x00BD
    13c0:	80 6c       	ori	r24, 0xC0	; 192
    13c2:	80 93 bd 00 	sts	0x00BD, r24
		display_buffer[52] |= 0xC0;
    13c6:	80 91 c5 00 	lds	r24, 0x00C5
    13ca:	80 6c       	ori	r24, 0xC0	; 192
    13cc:	80 93 c5 00 	sts	0x00C5, r24
		display_buffer[35] |= 0x01;
    13d0:	80 91 b4 00 	lds	r24, 0x00B4
    13d4:	81 60       	ori	r24, 0x01	; 1
    13d6:	80 93 b4 00 	sts	0x00B4, r24
		display_buffer[43] |= 0x01;
    13da:	80 91 bc 00 	lds	r24, 0x00BC
    13de:	81 60       	ori	r24, 0x01	; 1
    13e0:	80 93 bc 00 	sts	0x00BC, r24
		display_buffer[51] |= 0x01;
    13e4:	80 91 c4 00 	lds	r24, 0x00C4
    13e8:	81 60       	ori	r24, 0x01	; 1
    13ea:	80 93 c4 00 	sts	0x00C4, r24
	
		display_buffer[108] |= 0xC0;
    13ee:	80 91 fd 00 	lds	r24, 0x00FD
    13f2:	80 6c       	ori	r24, 0xC0	; 192
    13f4:	80 93 fd 00 	sts	0x00FD, r24
		display_buffer[116] |= 0xC0;
    13f8:	80 91 05 01 	lds	r24, 0x0105
    13fc:	80 6c       	ori	r24, 0xC0	; 192
    13fe:	80 93 05 01 	sts	0x0105, r24
		display_buffer[124] |= 0xC0;
    1402:	80 91 0d 01 	lds	r24, 0x010D
    1406:	80 6c       	ori	r24, 0xC0	; 192
    1408:	80 93 0d 01 	sts	0x010D, r24
		display_buffer[107] |= 0x01;
    140c:	80 91 fc 00 	lds	r24, 0x00FC
    1410:	81 60       	ori	r24, 0x01	; 1
    1412:	80 93 fc 00 	sts	0x00FC, r24
		display_buffer[115] |= 0x01;
    1416:	80 91 04 01 	lds	r24, 0x0104
    141a:	81 60       	ori	r24, 0x01	; 1
    141c:	80 93 04 01 	sts	0x0104, r24
		display_buffer[123] |= 0x01;
    1420:	80 91 0c 01 	lds	r24, 0x010C
    1424:	81 60       	ori	r24, 0x01	; 1
    1426:	3a c0       	rjmp	.+116    	; 0x149c <writeCloclColon+0xee>
	}
	else
	{
		display_buffer[36] &= 0x3F;
    1428:	80 91 b5 00 	lds	r24, 0x00B5
    142c:	8f 73       	andi	r24, 0x3F	; 63
    142e:	80 93 b5 00 	sts	0x00B5, r24
		display_buffer[44] &= 0x3F;
    1432:	80 91 bd 00 	lds	r24, 0x00BD
    1436:	8f 73       	andi	r24, 0x3F	; 63
    1438:	80 93 bd 00 	sts	0x00BD, r24
		display_buffer[52] &= 0x3F;
    143c:	80 91 c5 00 	lds	r24, 0x00C5
    1440:	8f 73       	andi	r24, 0x3F	; 63
    1442:	80 93 c5 00 	sts	0x00C5, r24
		display_buffer[35] &= 0xFE;
    1446:	80 91 b4 00 	lds	r24, 0x00B4
    144a:	8e 7f       	andi	r24, 0xFE	; 254
    144c:	80 93 b4 00 	sts	0x00B4, r24
		display_buffer[43] &= 0xFE;
    1450:	80 91 bc 00 	lds	r24, 0x00BC
    1454:	8e 7f       	andi	r24, 0xFE	; 254
    1456:	80 93 bc 00 	sts	0x00BC, r24
		display_buffer[51] &= 0xFE;
    145a:	80 91 c4 00 	lds	r24, 0x00C4
    145e:	8e 7f       	andi	r24, 0xFE	; 254
    1460:	80 93 c4 00 	sts	0x00C4, r24
	
		display_buffer[108] &= 0x3F;
    1464:	80 91 fd 00 	lds	r24, 0x00FD
    1468:	8f 73       	andi	r24, 0x3F	; 63
    146a:	80 93 fd 00 	sts	0x00FD, r24
		display_buffer[116] &= 0x3F;
    146e:	80 91 05 01 	lds	r24, 0x0105
    1472:	8f 73       	andi	r24, 0x3F	; 63
    1474:	80 93 05 01 	sts	0x0105, r24
		display_buffer[124] &= 0x3F;
    1478:	80 91 0d 01 	lds	r24, 0x010D
    147c:	8f 73       	andi	r24, 0x3F	; 63
    147e:	80 93 0d 01 	sts	0x010D, r24
		display_buffer[107] &= 0xFE;
    1482:	80 91 fc 00 	lds	r24, 0x00FC
    1486:	8e 7f       	andi	r24, 0xFE	; 254
    1488:	80 93 fc 00 	sts	0x00FC, r24
		display_buffer[115] &= 0xFE;
    148c:	80 91 04 01 	lds	r24, 0x0104
    1490:	8e 7f       	andi	r24, 0xFE	; 254
    1492:	80 93 04 01 	sts	0x0104, r24
		display_buffer[123] &= 0xFE;
    1496:	80 91 0c 01 	lds	r24, 0x010C
    149a:	8e 7f       	andi	r24, 0xFE	; 254
    149c:	80 93 0c 01 	sts	0x010C, r24
    14a0:	08 95       	ret

000014a2 <writeOneChinese>:
	}
}

void writeOneChinese(uint8 x, uint8 y,uint8 index)
{
    14a2:	24 2f       	mov	r18, r20
    14a4:	30 e0       	ldi	r19, 0x00	; 0
    14a6:	f5 e0       	ldi	r31, 0x05	; 5
    14a8:	22 0f       	add	r18, r18
    14aa:	33 1f       	adc	r19, r19
    14ac:	fa 95       	dec	r31
    14ae:	e1 f7       	brne	.-8      	; 0x14a8 <writeOneChinese+0x6>
    14b0:	22 54       	subi	r18, 0x42	; 66
    14b2:	36 4f       	sbci	r19, 0xF6	; 246
    14b4:	70 e0       	ldi	r23, 0x00	; 0
    14b6:	e3 e0       	ldi	r30, 0x03	; 3
    14b8:	66 0f       	add	r22, r22
    14ba:	77 1f       	adc	r23, r23
    14bc:	ea 95       	dec	r30
    14be:	e1 f7       	brne	.-8      	; 0x14b8 <writeOneChinese+0x16>
    14c0:	90 e0       	ldi	r25, 0x00	; 0
    14c2:	db 01       	movw	r26, r22
    14c4:	a8 0f       	add	r26, r24
    14c6:	b9 1f       	adc	r27, r25
    14c8:	af 56       	subi	r26, 0x6F	; 111
    14ca:	bf 4f       	sbci	r27, 0xFF	; 255
	uint8 temp;
	uint8 i;
	for(i=0;i<16;i++)
    14cc:	68 0f       	add	r22, r24
    14ce:	79 1f       	adc	r23, r25
    14d0:	6f 5e       	subi	r22, 0xEF	; 239
    14d2:	7e 4f       	sbci	r23, 0xFE	; 254
	{
		temp = pgm_read_byte(&CHINESE[index][i*2]);
    14d4:	f9 01       	movw	r30, r18
    14d6:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    14d8:	8c 93       	st	X, r24
		temp = pgm_read_byte(&CHINESE[index][i*2+1]);
    14da:	2f 5f       	subi	r18, 0xFF	; 255
    14dc:	3f 4f       	sbci	r19, 0xFF	; 255
    14de:	f9 01       	movw	r30, r18
    14e0:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x+1] = temp;
    14e2:	11 96       	adiw	r26, 0x01	; 1
    14e4:	8c 93       	st	X, r24
    14e6:	11 97       	sbiw	r26, 0x01	; 1
    14e8:	2f 5f       	subi	r18, 0xFF	; 255
    14ea:	3f 4f       	sbci	r19, 0xFF	; 255
    14ec:	18 96       	adiw	r26, 0x08	; 8

void writeOneChinese(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<16;i++)
    14ee:	a6 17       	cp	r26, r22
    14f0:	b7 07       	cpc	r27, r23
    14f2:	81 f7       	brne	.-32     	; 0x14d4 <writeOneChinese+0x32>
		display_buffer[(y+i)*8+x] = temp;
		temp = pgm_read_byte(&CHINESE[index][i*2+1]);
		display_buffer[(y+i)*8+x+1] = temp;
	}
	
}
    14f4:	08 95       	ret

000014f6 <writeOneUnSCROLL>:

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
    14f6:	9a e0       	ldi	r25, 0x0A	; 10
    14f8:	49 9f       	mul	r20, r25
    14fa:	90 01       	movw	r18, r0
    14fc:	11 24       	eor	r1, r1
    14fe:	20 5c       	subi	r18, 0xC0	; 192
    1500:	3a 4f       	sbci	r19, 0xFA	; 250
    1502:	70 e0       	ldi	r23, 0x00	; 0
    1504:	a3 e0       	ldi	r26, 0x03	; 3
    1506:	66 0f       	add	r22, r22
    1508:	77 1f       	adc	r23, r23
    150a:	aa 95       	dec	r26
    150c:	e1 f7       	brne	.-8      	; 0x1506 <writeOneUnSCROLL+0x10>
    150e:	90 e0       	ldi	r25, 0x00	; 0
    1510:	db 01       	movw	r26, r22
    1512:	a8 0f       	add	r26, r24
    1514:	b9 1f       	adc	r27, r25
    1516:	af 56       	subi	r26, 0x6F	; 111
    1518:	bf 4f       	sbci	r27, 0xFF	; 255
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    151a:	68 0f       	add	r22, r24
    151c:	79 1f       	adc	r23, r25
    151e:	6f 51       	subi	r22, 0x1F	; 31
    1520:	7f 4f       	sbci	r23, 0xFF	; 255
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    1522:	f9 01       	movw	r30, r18
    1524:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    1526:	8c 93       	st	X, r24
    1528:	2f 5f       	subi	r18, 0xFF	; 255
    152a:	3f 4f       	sbci	r19, 0xFF	; 255
    152c:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    152e:	a6 17       	cp	r26, r22
    1530:	b7 07       	cpc	r27, r23
    1532:	b9 f7       	brne	.-18     	; 0x1522 <writeOneUnSCROLL+0x2c>
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
		display_buffer[(y+i)*8+x] = temp;
	}	
}
    1534:	08 95       	ret

00001536 <writeOneSCROLL>:

void writeOneSCROLL(uint8 x, uint8 y,uint8 index)
{
    1536:	28 2f       	mov	r18, r24
	uint8 temp;
	uint8 i;
	if(Display_BigNumber_Font == 0)
    1538:	80 91 7b 00 	lds	r24, 0x007B
    153c:	88 23       	and	r24, r24
    153e:	09 f5       	brne	.+66     	; 0x1582 <writeOneSCROLL+0x4c>
    1540:	8a e0       	ldi	r24, 0x0A	; 10
    1542:	48 9f       	mul	r20, r24
    1544:	a0 01       	movw	r20, r0
    1546:	11 24       	eor	r1, r1
    1548:	44 5f       	subi	r20, 0xF4	; 244
    154a:	58 4f       	sbci	r21, 0xF8	; 248
    154c:	86 2f       	mov	r24, r22
    154e:	90 e0       	ldi	r25, 0x00	; 0
    1550:	73 e0       	ldi	r23, 0x03	; 3
    1552:	88 0f       	add	r24, r24
    1554:	99 1f       	adc	r25, r25
    1556:	7a 95       	dec	r23
    1558:	e1 f7       	brne	.-8      	; 0x1552 <writeOneSCROLL+0x1c>
    155a:	30 e0       	ldi	r19, 0x00	; 0
    155c:	dc 01       	movw	r26, r24
    155e:	a2 0f       	add	r26, r18
    1560:	b3 1f       	adc	r27, r19
    1562:	af 56       	subi	r26, 0x6F	; 111
    1564:	bf 4f       	sbci	r27, 0xFF	; 255
	{
		for(i=0;i<10;i++)
    1566:	28 0f       	add	r18, r24
    1568:	39 1f       	adc	r19, r25
    156a:	2f 57       	subi	r18, 0x7F	; 127
    156c:	3e 4f       	sbci	r19, 0xFE	; 254
		{
			temp = pgm_read_byte(&SCROLL_STYLE1[index][i]);
    156e:	fa 01       	movw	r30, r20
    1570:	84 91       	lpm	r24, Z+
			display_buffer[(y+(i*3))*8+x] = temp;
    1572:	8c 93       	st	X, r24
    1574:	4f 5f       	subi	r20, 0xFF	; 255
    1576:	5f 4f       	sbci	r21, 0xFF	; 255
    1578:	58 96       	adiw	r26, 0x18	; 24
{
	uint8 temp;
	uint8 i;
	if(Display_BigNumber_Font == 0)
	{
		for(i=0;i<10;i++)
    157a:	a2 17       	cp	r26, r18
    157c:	b3 07       	cpc	r27, r19
    157e:	b9 f7       	brne	.-18     	; 0x156e <writeOneSCROLL+0x38>
    1580:	08 95       	ret
    1582:	70 e0       	ldi	r23, 0x00	; 0
    1584:	30 e0       	ldi	r19, 0x00	; 0
		{
			temp = pgm_read_byte(&SCROLL_STYLE1[index][i]);
			display_buffer[(y+(i*3))*8+x] = temp;
		}
	}	
	else if(Display_BigNumber_Font == 1)
    1586:	81 30       	cpi	r24, 0x01	; 1
    1588:	f9 f4       	brne	.+62     	; 0x15c8 <writeOneSCROLL+0x92>
    158a:	8a e0       	ldi	r24, 0x0A	; 10
    158c:	48 9f       	mul	r20, r24
    158e:	a0 01       	movw	r20, r0
    1590:	11 24       	eor	r1, r1
    1592:	4e 50       	subi	r20, 0x0E	; 14
    1594:	58 4f       	sbci	r21, 0xF8	; 248
    1596:	cb 01       	movw	r24, r22
    1598:	63 e0       	ldi	r22, 0x03	; 3
    159a:	88 0f       	add	r24, r24
    159c:	99 1f       	adc	r25, r25
    159e:	6a 95       	dec	r22
    15a0:	e1 f7       	brne	.-8      	; 0x159a <writeOneSCROLL+0x64>
    15a2:	dc 01       	movw	r26, r24
    15a4:	a2 0f       	add	r26, r18
    15a6:	b3 1f       	adc	r27, r19
    15a8:	af 56       	subi	r26, 0x6F	; 111
    15aa:	bf 4f       	sbci	r27, 0xFF	; 255
	{
		for(i=0;i<10;i++)
    15ac:	28 0f       	add	r18, r24
    15ae:	39 1f       	adc	r19, r25
    15b0:	2f 57       	subi	r18, 0x7F	; 127
    15b2:	3e 4f       	sbci	r19, 0xFE	; 254
		{
			temp = pgm_read_byte(&SCROLL_STYLE2[index][i]);
    15b4:	fa 01       	movw	r30, r20
    15b6:	84 91       	lpm	r24, Z+
			display_buffer[(y+(i*3))*8+x] = temp;
    15b8:	8c 93       	st	X, r24
    15ba:	4f 5f       	subi	r20, 0xFF	; 255
    15bc:	5f 4f       	sbci	r21, 0xFF	; 255
    15be:	58 96       	adiw	r26, 0x18	; 24
			display_buffer[(y+(i*3))*8+x] = temp;
		}
	}	
	else if(Display_BigNumber_Font == 1)
	{
		for(i=0;i<10;i++)
    15c0:	a2 17       	cp	r26, r18
    15c2:	b3 07       	cpc	r27, r19
    15c4:	b9 f7       	brne	.-18     	; 0x15b4 <writeOneSCROLL+0x7e>
    15c6:	08 95       	ret
    15c8:	8a e0       	ldi	r24, 0x0A	; 10
    15ca:	48 9f       	mul	r20, r24
    15cc:	a0 01       	movw	r20, r0
    15ce:	11 24       	eor	r1, r1
    15d0:	48 52       	subi	r20, 0x28	; 40
    15d2:	57 4f       	sbci	r21, 0xF7	; 247
    15d4:	cb 01       	movw	r24, r22
    15d6:	b3 e0       	ldi	r27, 0x03	; 3
    15d8:	88 0f       	add	r24, r24
    15da:	99 1f       	adc	r25, r25
    15dc:	ba 95       	dec	r27
    15de:	e1 f7       	brne	.-8      	; 0x15d8 <writeOneSCROLL+0xa2>
    15e0:	dc 01       	movw	r26, r24
    15e2:	a2 0f       	add	r26, r18
    15e4:	b3 1f       	adc	r27, r19
    15e6:	af 56       	subi	r26, 0x6F	; 111
    15e8:	bf 4f       	sbci	r27, 0xFF	; 255
			display_buffer[(y+(i*3))*8+x] = temp;
		}	
	}
	else
	{
		for(i=0;i<10;i++)
    15ea:	28 0f       	add	r18, r24
    15ec:	39 1f       	adc	r19, r25
    15ee:	2f 57       	subi	r18, 0x7F	; 127
    15f0:	3e 4f       	sbci	r19, 0xFE	; 254
		{
			temp = pgm_read_byte(&SCROLL_STYLE3[index][i]);
    15f2:	fa 01       	movw	r30, r20
    15f4:	84 91       	lpm	r24, Z+
			display_buffer[(y+(i*3))*8+x] = temp;
    15f6:	8c 93       	st	X, r24
    15f8:	4f 5f       	subi	r20, 0xFF	; 255
    15fa:	5f 4f       	sbci	r21, 0xFF	; 255
    15fc:	58 96       	adiw	r26, 0x18	; 24
			display_buffer[(y+(i*3))*8+x] = temp;
		}	
	}
	else
	{
		for(i=0;i<10;i++)
    15fe:	a2 17       	cp	r26, r18
    1600:	b3 07       	cpc	r27, r19
    1602:	b9 f7       	brne	.-18     	; 0x15f2 <writeOneSCROLL+0xbc>
    1604:	08 95       	ret

00001606 <wirteOneBigNumber>:
		}	
	}	
}

void wirteOneBigNumber(uint8 x, uint8 y,uint8 index)
{
    1606:	cf 93       	push	r28
    1608:	df 93       	push	r29
    160a:	98 2f       	mov	r25, r24
	uint8 temp,temp1;
	uint8 i;
	if(Display_BigNumber_Font == 0)
    160c:	80 91 7b 00 	lds	r24, 0x007B
    1610:	88 23       	and	r24, r24
    1612:	b1 f5       	brne	.+108    	; 0x1680 <wirteOneBigNumber+0x7a>
    1614:	8a e2       	ldi	r24, 0x2A	; 42
    1616:	48 9f       	mul	r20, r24
    1618:	f0 01       	movw	r30, r0
    161a:	11 24       	eor	r1, r1
    161c:	ec 5a       	subi	r30, 0xAC	; 172
    161e:	ff 4f       	sbci	r31, 0xFF	; 255
    1620:	89 2f       	mov	r24, r25
    1622:	90 e0       	ldi	r25, 0x00	; 0
    1624:	dc 01       	movw	r26, r24
    1626:	af 56       	subi	r26, 0x6F	; 111
    1628:	bf 4f       	sbci	r27, 0xFF	; 255
	{
		for(i=0;i<21;i++)
		{
			temp = pgm_read_byte(&BIG_NUMBER_STYLE1[index][i*2]);
			display_buffer[i*8+x] = temp >> y;
    162a:	70 e0       	ldi	r23, 0x00	; 0
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE1[index][i*2+1]);
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
    162c:	48 e0       	ldi	r20, 0x08	; 8
    162e:	50 e0       	ldi	r21, 0x00	; 0
    1630:	46 1b       	sub	r20, r22
    1632:	57 0b       	sbc	r21, r23
{
	uint8 temp,temp1;
	uint8 i;
	if(Display_BigNumber_Font == 0)
	{
		for(i=0;i<21;i++)
    1634:	ec 01       	movw	r28, r24
    1636:	c7 5c       	subi	r28, 0xC7	; 199
    1638:	de 4f       	sbci	r29, 0xFE	; 254
		{
			temp = pgm_read_byte(&BIG_NUMBER_STYLE1[index][i*2]);
    163a:	24 91       	lpm	r18, Z+
			display_buffer[i*8+x] = temp >> y;
    163c:	30 e0       	ldi	r19, 0x00	; 0
    163e:	c9 01       	movw	r24, r18
    1640:	06 2e       	mov	r0, r22
    1642:	02 c0       	rjmp	.+4      	; 0x1648 <wirteOneBigNumber+0x42>
    1644:	95 95       	asr	r25
    1646:	87 95       	ror	r24
    1648:	0a 94       	dec	r0
    164a:	e2 f7       	brpl	.-8      	; 0x1644 <wirteOneBigNumber+0x3e>
    164c:	8c 93       	st	X, r24
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE1[index][i*2+1]);
    164e:	31 96       	adiw	r30, 0x01	; 1
    1650:	84 91       	lpm	r24, Z+
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
    1652:	90 e0       	ldi	r25, 0x00	; 0
    1654:	06 2e       	mov	r0, r22
    1656:	02 c0       	rjmp	.+4      	; 0x165c <wirteOneBigNumber+0x56>
    1658:	95 95       	asr	r25
    165a:	87 95       	ror	r24
    165c:	0a 94       	dec	r0
    165e:	e2 f7       	brpl	.-8      	; 0x1658 <wirteOneBigNumber+0x52>
    1660:	04 2e       	mov	r0, r20
    1662:	02 c0       	rjmp	.+4      	; 0x1668 <wirteOneBigNumber+0x62>
    1664:	22 0f       	add	r18, r18
    1666:	33 1f       	adc	r19, r19
    1668:	0a 94       	dec	r0
    166a:	e2 f7       	brpl	.-8      	; 0x1664 <wirteOneBigNumber+0x5e>
    166c:	82 2b       	or	r24, r18
    166e:	11 96       	adiw	r26, 0x01	; 1
    1670:	8c 93       	st	X, r24
    1672:	11 97       	sbiw	r26, 0x01	; 1
    1674:	31 96       	adiw	r30, 0x01	; 1
    1676:	18 96       	adiw	r26, 0x08	; 8
{
	uint8 temp,temp1;
	uint8 i;
	if(Display_BigNumber_Font == 0)
	{
		for(i=0;i<21;i++)
    1678:	ac 17       	cp	r26, r28
    167a:	bd 07       	cpc	r27, r29
    167c:	f1 f6       	brne	.-68     	; 0x163a <wirteOneBigNumber+0x34>
    167e:	6b c0       	rjmp	.+214    	; 0x1756 <wirteOneBigNumber+0x150>
    1680:	29 2f       	mov	r18, r25
    1682:	30 e0       	ldi	r19, 0x00	; 0
			display_buffer[i*8+x] = temp >> y;
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE1[index][i*2+1]);
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
		}
	}
	else if(Display_BigNumber_Font == 1)
    1684:	81 30       	cpi	r24, 0x01	; 1
    1686:	a1 f5       	brne	.+104    	; 0x16f0 <wirteOneBigNumber+0xea>
    1688:	8a e2       	ldi	r24, 0x2A	; 42
    168a:	48 9f       	mul	r20, r24
    168c:	f0 01       	movw	r30, r0
    168e:	11 24       	eor	r1, r1
    1690:	e8 50       	subi	r30, 0x08	; 8
    1692:	fe 4f       	sbci	r31, 0xFE	; 254
    1694:	d9 01       	movw	r26, r18
    1696:	af 56       	subi	r26, 0x6F	; 111
    1698:	bf 4f       	sbci	r27, 0xFF	; 255
	{
		for(i=0;i<21;i++)
		{
			temp = pgm_read_byte(&BIG_NUMBER_STYLE2[index][i*2]);
			display_buffer[i*8+x] = temp >> y;
    169a:	70 e0       	ldi	r23, 0x00	; 0
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE2[index][i*2+1]);
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
    169c:	48 e0       	ldi	r20, 0x08	; 8
    169e:	50 e0       	ldi	r21, 0x00	; 0
    16a0:	46 1b       	sub	r20, r22
    16a2:	57 0b       	sbc	r21, r23
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
		}
	}
	else if(Display_BigNumber_Font == 1)
	{
		for(i=0;i<21;i++)
    16a4:	e9 01       	movw	r28, r18
    16a6:	c7 5c       	subi	r28, 0xC7	; 199
    16a8:	de 4f       	sbci	r29, 0xFE	; 254
		{
			temp = pgm_read_byte(&BIG_NUMBER_STYLE2[index][i*2]);
    16aa:	24 91       	lpm	r18, Z+
			display_buffer[i*8+x] = temp >> y;
    16ac:	30 e0       	ldi	r19, 0x00	; 0
    16ae:	c9 01       	movw	r24, r18
    16b0:	06 2e       	mov	r0, r22
    16b2:	02 c0       	rjmp	.+4      	; 0x16b8 <wirteOneBigNumber+0xb2>
    16b4:	95 95       	asr	r25
    16b6:	87 95       	ror	r24
    16b8:	0a 94       	dec	r0
    16ba:	e2 f7       	brpl	.-8      	; 0x16b4 <wirteOneBigNumber+0xae>
    16bc:	8c 93       	st	X, r24
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE2[index][i*2+1]);
    16be:	31 96       	adiw	r30, 0x01	; 1
    16c0:	84 91       	lpm	r24, Z+
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
    16c2:	90 e0       	ldi	r25, 0x00	; 0
    16c4:	06 2e       	mov	r0, r22
    16c6:	02 c0       	rjmp	.+4      	; 0x16cc <wirteOneBigNumber+0xc6>
    16c8:	95 95       	asr	r25
    16ca:	87 95       	ror	r24
    16cc:	0a 94       	dec	r0
    16ce:	e2 f7       	brpl	.-8      	; 0x16c8 <wirteOneBigNumber+0xc2>
    16d0:	04 2e       	mov	r0, r20
    16d2:	02 c0       	rjmp	.+4      	; 0x16d8 <wirteOneBigNumber+0xd2>
    16d4:	22 0f       	add	r18, r18
    16d6:	33 1f       	adc	r19, r19
    16d8:	0a 94       	dec	r0
    16da:	e2 f7       	brpl	.-8      	; 0x16d4 <wirteOneBigNumber+0xce>
    16dc:	82 2b       	or	r24, r18
    16de:	11 96       	adiw	r26, 0x01	; 1
    16e0:	8c 93       	st	X, r24
    16e2:	11 97       	sbiw	r26, 0x01	; 1
    16e4:	31 96       	adiw	r30, 0x01	; 1
    16e6:	18 96       	adiw	r26, 0x08	; 8
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
		}
	}
	else if(Display_BigNumber_Font == 1)
	{
		for(i=0;i<21;i++)
    16e8:	ac 17       	cp	r26, r28
    16ea:	bd 07       	cpc	r27, r29
    16ec:	f1 f6       	brne	.-68     	; 0x16aa <wirteOneBigNumber+0xa4>
    16ee:	33 c0       	rjmp	.+102    	; 0x1756 <wirteOneBigNumber+0x150>
    16f0:	8a e2       	ldi	r24, 0x2A	; 42
    16f2:	48 9f       	mul	r20, r24
    16f4:	f0 01       	movw	r30, r0
    16f6:	11 24       	eor	r1, r1
    16f8:	e4 56       	subi	r30, 0x64	; 100
    16fa:	fc 4f       	sbci	r31, 0xFC	; 252
    16fc:	d9 01       	movw	r26, r18
    16fe:	af 56       	subi	r26, 0x6F	; 111
    1700:	bf 4f       	sbci	r27, 0xFF	; 255
	else
	{
		for(i=0;i<21;i++)
		{
			temp = pgm_read_byte(&BIG_NUMBER_STYLE3[index][i*2]);
			display_buffer[i*8+x] = temp >> y;
    1702:	70 e0       	ldi	r23, 0x00	; 0
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE3[index][i*2+1]);
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
    1704:	48 e0       	ldi	r20, 0x08	; 8
    1706:	50 e0       	ldi	r21, 0x00	; 0
    1708:	46 1b       	sub	r20, r22
    170a:	57 0b       	sbc	r21, r23
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
		}
	}
	else
	{
		for(i=0;i<21;i++)
    170c:	e9 01       	movw	r28, r18
    170e:	c7 5c       	subi	r28, 0xC7	; 199
    1710:	de 4f       	sbci	r29, 0xFE	; 254
		{
			temp = pgm_read_byte(&BIG_NUMBER_STYLE3[index][i*2]);
    1712:	24 91       	lpm	r18, Z+
			display_buffer[i*8+x] = temp >> y;
    1714:	30 e0       	ldi	r19, 0x00	; 0
    1716:	c9 01       	movw	r24, r18
    1718:	06 2e       	mov	r0, r22
    171a:	02 c0       	rjmp	.+4      	; 0x1720 <wirteOneBigNumber+0x11a>
    171c:	95 95       	asr	r25
    171e:	87 95       	ror	r24
    1720:	0a 94       	dec	r0
    1722:	e2 f7       	brpl	.-8      	; 0x171c <wirteOneBigNumber+0x116>
    1724:	8c 93       	st	X, r24
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE3[index][i*2+1]);
    1726:	31 96       	adiw	r30, 0x01	; 1
    1728:	84 91       	lpm	r24, Z+
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
    172a:	90 e0       	ldi	r25, 0x00	; 0
    172c:	06 2e       	mov	r0, r22
    172e:	02 c0       	rjmp	.+4      	; 0x1734 <wirteOneBigNumber+0x12e>
    1730:	95 95       	asr	r25
    1732:	87 95       	ror	r24
    1734:	0a 94       	dec	r0
    1736:	e2 f7       	brpl	.-8      	; 0x1730 <wirteOneBigNumber+0x12a>
    1738:	04 2e       	mov	r0, r20
    173a:	02 c0       	rjmp	.+4      	; 0x1740 <wirteOneBigNumber+0x13a>
    173c:	22 0f       	add	r18, r18
    173e:	33 1f       	adc	r19, r19
    1740:	0a 94       	dec	r0
    1742:	e2 f7       	brpl	.-8      	; 0x173c <wirteOneBigNumber+0x136>
    1744:	82 2b       	or	r24, r18
    1746:	11 96       	adiw	r26, 0x01	; 1
    1748:	8c 93       	st	X, r24
    174a:	11 97       	sbiw	r26, 0x01	; 1
    174c:	31 96       	adiw	r30, 0x01	; 1
    174e:	18 96       	adiw	r26, 0x08	; 8
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
		}
	}
	else
	{
		for(i=0;i<21;i++)
    1750:	ac 17       	cp	r26, r28
    1752:	bd 07       	cpc	r27, r29
    1754:	f1 f6       	brne	.-68     	; 0x1712 <wirteOneBigNumber+0x10c>
			display_buffer[i*8+x] = temp >> y;
			temp1 = pgm_read_byte(&BIG_NUMBER_STYLE3[index][i*2+1]);
			display_buffer[i*8+x+1] = (temp << (8-y))|(temp1>>y);
		}
	}
}
    1756:	df 91       	pop	r29
    1758:	cf 91       	pop	r28
    175a:	08 95       	ret

0000175c <display>:
	writeOneSCROLL(2,25,TemperatureDecimal );		//17 温度小数	
	writeOneSCROLL(3,25,13);	
}

void display()
{
    175c:	1f 93       	push	r17
    175e:	cf 93       	push	r28
    1760:	df 93       	push	r29
	uint8 i;
	signed char j;
	uint8 k;
	uint8 *ptr0,*ptr1;

	moveSpeedTimerCount++;
    1762:	40 91 8e 00 	lds	r20, 0x008E
    1766:	50 91 8f 00 	lds	r21, 0x008F
    176a:	4f 5f       	subi	r20, 0xFF	; 255
    176c:	5f 4f       	sbci	r21, 0xFF	; 255
    176e:	50 93 8f 00 	sts	0x008F, r21
    1772:	40 93 8e 00 	sts	0x008E, r20
	if(moveSpeedTimerCount > (9-moveSpeed)*10) 
    1776:	20 91 74 00 	lds	r18, 0x0074
    177a:	89 e0       	ldi	r24, 0x09	; 9
    177c:	90 e0       	ldi	r25, 0x00	; 0
    177e:	82 1b       	sub	r24, r18
    1780:	91 09       	sbc	r25, r1
    1782:	9c 01       	movw	r18, r24
    1784:	73 e0       	ldi	r23, 0x03	; 3
    1786:	22 0f       	add	r18, r18
    1788:	33 1f       	adc	r19, r19
    178a:	7a 95       	dec	r23
    178c:	e1 f7       	brne	.-8      	; 0x1786 <display+0x2a>
    178e:	88 0f       	add	r24, r24
    1790:	99 1f       	adc	r25, r25
    1792:	28 0f       	add	r18, r24
    1794:	39 1f       	adc	r19, r25
    1796:	24 17       	cp	r18, r20
    1798:	35 07       	cpc	r19, r21
    179a:	68 f4       	brcc	.+26     	; 0x17b6 <display+0x5a>
	{
		moveSpeedTimerCount = 0;
    179c:	10 92 8f 00 	sts	0x008F, r1
    17a0:	10 92 8e 00 	sts	0x008E, r1
		currentMoveLeft ++;
    17a4:	80 91 8d 02 	lds	r24, 0x028D
    17a8:	8f 5f       	subi	r24, 0xFF	; 255
    17aa:	80 93 8d 02 	sts	0x028D, r24
		if(currentMoveLeft > 192)
    17ae:	81 3c       	cpi	r24, 0xC1	; 193
    17b0:	10 f0       	brcs	.+4      	; 0x17b6 <display+0x5a>
		{
			currentMoveLeft = 0;
    17b2:	10 92 8d 02 	sts	0x028D, r1
		}
	}
	HC595_LAT_L;
    17b6:	92 98       	cbi	0x12, 2	; 18
	if(Mode == 0)
    17b8:	80 91 75 00 	lds	r24, 0x0075
    17bc:	88 23       	and	r24, r24
    17be:	e9 f4       	brne	.+58     	; 0x17fa <display+0x9e>
	{
		halfSecondCount ++;
    17c0:	80 91 85 02 	lds	r24, 0x0285
    17c4:	90 91 86 02 	lds	r25, 0x0286
    17c8:	01 96       	adiw	r24, 0x01	; 1
    17ca:	90 93 86 02 	sts	0x0286, r25
    17ce:	80 93 85 02 	sts	0x0285, r24
		if(halfSecondCount > 940) //到0.5s
    17d2:	8d 5a       	subi	r24, 0xAD	; 173
    17d4:	93 40       	sbci	r25, 0x03	; 3
    17d6:	88 f0       	brcs	.+34     	; 0x17fa <display+0x9e>
		{
			halfSecondCount = 0;
    17d8:	10 92 86 02 	sts	0x0286, r1
    17dc:	10 92 85 02 	sts	0x0285, r1
			if(isSecondCountShow)
    17e0:	80 91 88 02 	lds	r24, 0x0288
    17e4:	88 23       	and	r24, r24
    17e6:	21 f0       	breq	.+8      	; 0x17f0 <display+0x94>
			{
				isSecondCountShow = 0;
    17e8:	10 92 88 02 	sts	0x0288, r1
				writeCloclColon(0);
    17ec:	80 e0       	ldi	r24, 0x00	; 0
    17ee:	03 c0       	rjmp	.+6      	; 0x17f6 <display+0x9a>
			}
			else 
			{
				isSecondCountShow = 1;
    17f0:	81 e0       	ldi	r24, 0x01	; 1
    17f2:	80 93 88 02 	sts	0x0288, r24
				writeCloclColon(1);
    17f6:	0e 94 d7 09 	call	0x13ae	; 0x13ae <writeCloclColon>
			}
		}
	}
	if(display_cnt > 5)
    17fa:	80 91 89 02 	lds	r24, 0x0289
    17fe:	86 30       	cpi	r24, 0x06	; 6
    1800:	08 f4       	brcc	.+2      	; 0x1804 <display+0xa8>
    1802:	40 c0       	rjmp	.+128    	; 0x1884 <display+0x128>
	{
		if(Mode == 0) //正常显示模式 日期温度滚动
    1804:	80 91 75 00 	lds	r24, 0x0075
    1808:	88 23       	and	r24, r24
    180a:	e1 f5       	brne	.+120    	; 0x1884 <display+0x128>
		{
			uint8 temp1 = currentMoveLeft>>3;
    180c:	90 91 8d 02 	lds	r25, 0x028D
			uint8 temp2 = currentMoveLeft<<5;
			temp2 = temp2>>5;
			uint16 temp3 = 176+(display_cnt-6)*24+temp1;
    1810:	30 91 89 02 	lds	r19, 0x0289
			ptr0 = &display_buffer[0+display_cnt*8];
    1814:	10 91 89 02 	lds	r17, 0x0289
    1818:	29 2f       	mov	r18, r25
    181a:	26 95       	lsr	r18
    181c:	26 95       	lsr	r18
    181e:	26 95       	lsr	r18
    1820:	88 e1       	ldi	r24, 0x18	; 24
    1822:	38 9f       	mul	r19, r24
    1824:	f0 01       	movw	r30, r0
    1826:	11 24       	eor	r1, r1
    1828:	e2 0f       	add	r30, r18
    182a:	f1 1d       	adc	r31, r1
    182c:	ef 54       	subi	r30, 0x4F	; 79
    182e:	ff 4f       	sbci	r31, 0xFF	; 255
    1830:	a6 e8       	ldi	r26, 0x86	; 134
    1832:	b0 e0       	ldi	r27, 0x00	; 0
	{
		if(Mode == 0) //正常显示模式 日期温度滚动
		{
			uint8 temp1 = currentMoveLeft>>3;
			uint8 temp2 = currentMoveLeft<<5;
			temp2 = temp2>>5;
    1834:	97 70       	andi	r25, 0x07	; 7
			uint16 temp3 = 176+(display_cnt-6)*24+temp1;
			ptr0 = &display_buffer[0+display_cnt*8];
			for(k=0; k<8; k++)
			{
				display_buffer_temp[k] = (display_buffer[temp3+k]<<temp2) | (display_buffer[temp3+k+1]>>(8-temp2));
    1836:	69 2f       	mov	r22, r25
    1838:	70 e0       	ldi	r23, 0x00	; 0
    183a:	48 e0       	ldi	r20, 0x08	; 8
    183c:	50 e0       	ldi	r21, 0x00	; 0
    183e:	46 1b       	sub	r20, r22
    1840:	57 0b       	sbc	r21, r23
    1842:	21 81       	ldd	r18, Z+1	; 0x01
    1844:	30 e0       	ldi	r19, 0x00	; 0
    1846:	04 2e       	mov	r0, r20
    1848:	02 c0       	rjmp	.+4      	; 0x184e <display+0xf2>
    184a:	35 95       	asr	r19
    184c:	27 95       	ror	r18
    184e:	0a 94       	dec	r0
    1850:	e2 f7       	brpl	.-8      	; 0x184a <display+0xee>
    1852:	81 91       	ld	r24, Z+
    1854:	90 e0       	ldi	r25, 0x00	; 0
    1856:	06 2e       	mov	r0, r22
    1858:	02 c0       	rjmp	.+4      	; 0x185e <display+0x102>
    185a:	88 0f       	add	r24, r24
    185c:	99 1f       	adc	r25, r25
    185e:	0a 94       	dec	r0
    1860:	e2 f7       	brpl	.-8      	; 0x185a <display+0xfe>
    1862:	28 2b       	or	r18, r24
    1864:	2d 93       	st	X+, r18
			uint8 temp1 = currentMoveLeft>>3;
			uint8 temp2 = currentMoveLeft<<5;
			temp2 = temp2>>5;
			uint16 temp3 = 176+(display_cnt-6)*24+temp1;
			ptr0 = &display_buffer[0+display_cnt*8];
			for(k=0; k<8; k++)
    1866:	80 e0       	ldi	r24, 0x00	; 0
    1868:	ae 38       	cpi	r26, 0x8E	; 142
    186a:	b8 07       	cpc	r27, r24
    186c:	51 f7       	brne	.-44     	; 0x1842 <display+0xe6>
		{
			uint8 temp1 = currentMoveLeft>>3;
			uint8 temp2 = currentMoveLeft<<5;
			temp2 = temp2>>5;
			uint16 temp3 = 176+(display_cnt-6)*24+temp1;
			ptr0 = &display_buffer[0+display_cnt*8];
    186e:	e1 2f       	mov	r30, r17
    1870:	f0 e0       	ldi	r31, 0x00	; 0
    1872:	93 e0       	ldi	r25, 0x03	; 3
    1874:	ee 0f       	add	r30, r30
    1876:	ff 1f       	adc	r31, r31
    1878:	9a 95       	dec	r25
    187a:	e1 f7       	brne	.-8      	; 0x1874 <display+0x118>
    187c:	ef 56       	subi	r30, 0x6F	; 111
    187e:	ff 4f       	sbci	r31, 0xFF	; 255
    1880:	18 97       	sbiw	r26, 0x08	; 8
    1882:	16 c0       	rjmp	.+44     	; 0x18b0 <display+0x154>
			ptr1 = &display_buffer[128+display_cnt*8];
		}
	}
	else
	{
		ptr0 = &display_buffer[0+display_cnt*8];
    1884:	80 91 89 02 	lds	r24, 0x0289
    1888:	e8 2f       	mov	r30, r24
    188a:	f0 e0       	ldi	r31, 0x00	; 0
    188c:	83 e0       	ldi	r24, 0x03	; 3
    188e:	ee 0f       	add	r30, r30
    1890:	ff 1f       	adc	r31, r31
    1892:	8a 95       	dec	r24
    1894:	e1 f7       	brne	.-8      	; 0x188e <display+0x132>
    1896:	ef 56       	subi	r30, 0x6F	; 111
    1898:	ff 4f       	sbci	r31, 0xFF	; 255
		ptr1 = &display_buffer[128+display_cnt*8];	
    189a:	80 91 89 02 	lds	r24, 0x0289
    189e:	a8 2f       	mov	r26, r24
    18a0:	b0 e0       	ldi	r27, 0x00	; 0
    18a2:	13 e0       	ldi	r17, 0x03	; 3
    18a4:	aa 0f       	add	r26, r26
    18a6:	bb 1f       	adc	r27, r27
    18a8:	1a 95       	dec	r17
    18aa:	e1 f7       	brne	.-8      	; 0x18a4 <display+0x148>
    18ac:	af 5e       	subi	r26, 0xEF	; 239
    18ae:	be 4f       	sbci	r27, 0xFE	; 254
	}
	if(Display_color == 0)
    18b0:	80 91 7a 00 	lds	r24, 0x007A
    18b4:	88 23       	and	r24, r24
    18b6:	89 f5       	brne	.+98     	; 0x191a <display+0x1be>
    18b8:	50 e0       	ldi	r21, 0x00	; 0
    18ba:	26 c0       	rjmp	.+76     	; 0x1908 <display+0x1ac>
	/* 单红	*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
			{
				HC595_D0_L;
    18bc:	94 98       	cbi	0x12, 4	; 18
				HC595_D1_L;
    18be:	95 98       	cbi	0x12, 5	; 18
				HC595_D2_L;
    18c0:	d9 98       	cbi	0x1b, 1	; 27
				HC595_D3_L;
    18c2:	da 98       	cbi	0x1b, 2	; 27
				HC595_D4_L;
    18c4:	db 98       	cbi	0x1b, 3	; 27
				HC595_D5_L;
    18c6:	dc 98       	cbi	0x1b, 4	; 27
    18c8:	42 2f       	mov	r20, r18
				if(*ptr0 & 1<<j)
    18ca:	ce 01       	movw	r24, r28
    18cc:	02 2e       	mov	r0, r18
    18ce:	02 c0       	rjmp	.+4      	; 0x18d4 <display+0x178>
    18d0:	95 95       	asr	r25
    18d2:	87 95       	ror	r24
    18d4:	0a 94       	dec	r0
    18d6:	e2 f7       	brpl	.-8      	; 0x18d0 <display+0x174>
    18d8:	80 fd       	sbrc	r24, 0
				{
					HC595_D0_H;
    18da:	94 9a       	sbi	0x12, 4	; 18
				}
				if(*ptr1 & 1<<j)
    18dc:	cb 01       	movw	r24, r22
    18de:	02 c0       	rjmp	.+4      	; 0x18e4 <display+0x188>
    18e0:	95 95       	asr	r25
    18e2:	87 95       	ror	r24
    18e4:	4a 95       	dec	r20
    18e6:	e2 f7       	brpl	.-8      	; 0x18e0 <display+0x184>
    18e8:	80 fd       	sbrc	r24, 0
				{
					HC595_D1_H;
    18ea:	95 9a       	sbi	0x12, 5	; 18
				}
				HC595_SCK_L;
    18ec:	93 98       	cbi	0x12, 3	; 18
				HC595_SCK_H;
    18ee:	93 9a       	sbi	0x12, 3	; 18
    18f0:	21 50       	subi	r18, 0x01	; 1
    18f2:	30 40       	sbci	r19, 0x00	; 0
	if(Display_color == 0)
	{
	/* 单红	*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
    18f4:	8f ef       	ldi	r24, 0xFF	; 255
    18f6:	2f 3f       	cpi	r18, 0xFF	; 255
    18f8:	38 07       	cpc	r19, r24
    18fa:	01 f7       	brne	.-64     	; 0x18bc <display+0x160>
		ptr1 = &display_buffer[128+display_cnt*8];	
	}
	if(Display_color == 0)
	{
	/* 单红	*/
		for(i=0;i<8;i++)
    18fc:	5f 5f       	subi	r21, 0xFF	; 255
    18fe:	58 30       	cpi	r21, 0x08	; 8
    1900:	09 f4       	brne	.+2      	; 0x1904 <display+0x1a8>
    1902:	d5 c0       	rjmp	.+426    	; 0x1aae <display+0x352>
					HC595_D1_H;
				}
				HC595_SCK_L;
				HC595_SCK_H;
			}
			ptr0++;
    1904:	31 96       	adiw	r30, 0x01	; 1
			ptr1++;
    1906:	11 96       	adiw	r26, 0x01	; 1
				HC595_D1_L;
				HC595_D2_L;
				HC595_D3_L;
				HC595_D4_L;
				HC595_D5_L;
				if(*ptr0 & 1<<j)
    1908:	80 81       	ld	r24, Z
    190a:	c8 2f       	mov	r28, r24
    190c:	d0 e0       	ldi	r29, 0x00	; 0
				{
					HC595_D0_H;
				}
				if(*ptr1 & 1<<j)
    190e:	8c 91       	ld	r24, X
    1910:	68 2f       	mov	r22, r24
    1912:	70 e0       	ldi	r23, 0x00	; 0
    1914:	27 e0       	ldi	r18, 0x07	; 7
    1916:	30 e0       	ldi	r19, 0x00	; 0
    1918:	d1 cf       	rjmp	.-94     	; 0x18bc <display+0x160>
			ptr0++;
			ptr1++;
		}
		
	}
	else if(Display_color == 1)
    191a:	81 30       	cpi	r24, 0x01	; 1
    191c:	89 f5       	brne	.+98     	; 0x1980 <display+0x224>
    191e:	50 e0       	ldi	r21, 0x00	; 0
    1920:	26 c0       	rjmp	.+76     	; 0x196e <display+0x212>
	/*单绿	*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
			{
				HC595_D0_L;
    1922:	94 98       	cbi	0x12, 4	; 18
				HC595_D1_L;
    1924:	95 98       	cbi	0x12, 5	; 18
				HC595_D2_L;
    1926:	d9 98       	cbi	0x1b, 1	; 27
				HC595_D3_L;
    1928:	da 98       	cbi	0x1b, 2	; 27
				HC595_D4_L;
    192a:	db 98       	cbi	0x1b, 3	; 27
				HC595_D5_L;
    192c:	dc 98       	cbi	0x1b, 4	; 27
    192e:	42 2f       	mov	r20, r18
				if(*ptr0 & 1<<j)
    1930:	ce 01       	movw	r24, r28
    1932:	02 2e       	mov	r0, r18
    1934:	02 c0       	rjmp	.+4      	; 0x193a <display+0x1de>
    1936:	95 95       	asr	r25
    1938:	87 95       	ror	r24
    193a:	0a 94       	dec	r0
    193c:	e2 f7       	brpl	.-8      	; 0x1936 <display+0x1da>
    193e:	80 fd       	sbrc	r24, 0
				{
					HC595_D2_H;
    1940:	d9 9a       	sbi	0x1b, 1	; 27
				}
				if(*ptr1 & 1<<j)
    1942:	cb 01       	movw	r24, r22
    1944:	02 c0       	rjmp	.+4      	; 0x194a <display+0x1ee>
    1946:	95 95       	asr	r25
    1948:	87 95       	ror	r24
    194a:	4a 95       	dec	r20
    194c:	e2 f7       	brpl	.-8      	; 0x1946 <display+0x1ea>
    194e:	80 fd       	sbrc	r24, 0
				{
					HC595_D3_H;
    1950:	da 9a       	sbi	0x1b, 2	; 27
				}
				HC595_SCK_L;
    1952:	93 98       	cbi	0x12, 3	; 18
				HC595_SCK_H;
    1954:	93 9a       	sbi	0x12, 3	; 18
    1956:	21 50       	subi	r18, 0x01	; 1
    1958:	30 40       	sbci	r19, 0x00	; 0
	else if(Display_color == 1)
	{
	/*单绿	*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
    195a:	8f ef       	ldi	r24, 0xFF	; 255
    195c:	2f 3f       	cpi	r18, 0xFF	; 255
    195e:	38 07       	cpc	r19, r24
    1960:	01 f7       	brne	.-64     	; 0x1922 <display+0x1c6>
		
	}
	else if(Display_color == 1)
	{
	/*单绿	*/
		for(i=0;i<8;i++)
    1962:	5f 5f       	subi	r21, 0xFF	; 255
    1964:	58 30       	cpi	r21, 0x08	; 8
    1966:	09 f4       	brne	.+2      	; 0x196a <display+0x20e>
    1968:	a2 c0       	rjmp	.+324    	; 0x1aae <display+0x352>
					HC595_D3_H;
				}
				HC595_SCK_L;
				HC595_SCK_H;
			}
			ptr0++;
    196a:	31 96       	adiw	r30, 0x01	; 1
			ptr1++;
    196c:	11 96       	adiw	r26, 0x01	; 1
				HC595_D1_L;
				HC595_D2_L;
				HC595_D3_L;
				HC595_D4_L;
				HC595_D5_L;
				if(*ptr0 & 1<<j)
    196e:	80 81       	ld	r24, Z
    1970:	c8 2f       	mov	r28, r24
    1972:	d0 e0       	ldi	r29, 0x00	; 0
				{
					HC595_D2_H;
				}
				if(*ptr1 & 1<<j)
    1974:	8c 91       	ld	r24, X
    1976:	68 2f       	mov	r22, r24
    1978:	70 e0       	ldi	r23, 0x00	; 0
    197a:	27 e0       	ldi	r18, 0x07	; 7
    197c:	30 e0       	ldi	r19, 0x00	; 0
    197e:	d1 cf       	rjmp	.-94     	; 0x1922 <display+0x1c6>
			ptr0++;
			ptr1++;
		}
		
	}
	else if(Display_color == 2)
    1980:	82 30       	cpi	r24, 0x02	; 2
    1982:	99 f5       	brne	.+102    	; 0x19ea <display+0x28e>
    1984:	50 e0       	ldi	r21, 0x00	; 0
    1986:	28 c0       	rjmp	.+80     	; 0x19d8 <display+0x27c>
	/*单黄*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
			{
				HC595_D0_L;
    1988:	94 98       	cbi	0x12, 4	; 18
				HC595_D1_L;
    198a:	95 98       	cbi	0x12, 5	; 18
				HC595_D2_L;
    198c:	d9 98       	cbi	0x1b, 1	; 27
				HC595_D3_L;
    198e:	da 98       	cbi	0x1b, 2	; 27
    1990:	42 2f       	mov	r20, r18
				if(*ptr0 & 1<<j)
    1992:	ce 01       	movw	r24, r28
    1994:	02 2e       	mov	r0, r18
    1996:	02 c0       	rjmp	.+4      	; 0x199c <display+0x240>
    1998:	95 95       	asr	r25
    199a:	87 95       	ror	r24
    199c:	0a 94       	dec	r0
    199e:	e2 f7       	brpl	.-8      	; 0x1998 <display+0x23c>
    19a0:	80 ff       	sbrs	r24, 0
    19a2:	02 c0       	rjmp	.+4      	; 0x19a8 <display+0x24c>
				{
					HC595_D0_H;
    19a4:	94 9a       	sbi	0x12, 4	; 18
					HC595_D2_H;
    19a6:	d9 9a       	sbi	0x1b, 1	; 27
				}
				if(*ptr1 & 1<<j)
    19a8:	cb 01       	movw	r24, r22
    19aa:	02 c0       	rjmp	.+4      	; 0x19b0 <display+0x254>
    19ac:	95 95       	asr	r25
    19ae:	87 95       	ror	r24
    19b0:	4a 95       	dec	r20
    19b2:	e2 f7       	brpl	.-8      	; 0x19ac <display+0x250>
    19b4:	80 ff       	sbrs	r24, 0
    19b6:	02 c0       	rjmp	.+4      	; 0x19bc <display+0x260>
				{
					HC595_D1_H;
    19b8:	95 9a       	sbi	0x12, 5	; 18
					HC595_D3_H;
    19ba:	da 9a       	sbi	0x1b, 2	; 27
				}
				HC595_SCK_L;
    19bc:	93 98       	cbi	0x12, 3	; 18
				HC595_SCK_H;
    19be:	93 9a       	sbi	0x12, 3	; 18
    19c0:	21 50       	subi	r18, 0x01	; 1
    19c2:	30 40       	sbci	r19, 0x00	; 0
	else if(Display_color == 2)
	{
	/*单黄*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
    19c4:	8f ef       	ldi	r24, 0xFF	; 255
    19c6:	2f 3f       	cpi	r18, 0xFF	; 255
    19c8:	38 07       	cpc	r19, r24
    19ca:	f1 f6       	brne	.-68     	; 0x1988 <display+0x22c>
		
	}
	else if(Display_color == 2)
	{
	/*单黄*/
		for(i=0;i<8;i++)
    19cc:	5f 5f       	subi	r21, 0xFF	; 255
    19ce:	58 30       	cpi	r21, 0x08	; 8
    19d0:	09 f4       	brne	.+2      	; 0x19d4 <display+0x278>
    19d2:	6d c0       	rjmp	.+218    	; 0x1aae <display+0x352>
					HC595_D3_H;
				}
				HC595_SCK_L;
				HC595_SCK_H;
			}
			ptr0++;
    19d4:	31 96       	adiw	r30, 0x01	; 1
			ptr1++;
    19d6:	11 96       	adiw	r26, 0x01	; 1
			{
				HC595_D0_L;
				HC595_D1_L;
				HC595_D2_L;
				HC595_D3_L;
				if(*ptr0 & 1<<j)
    19d8:	80 81       	ld	r24, Z
    19da:	c8 2f       	mov	r28, r24
    19dc:	d0 e0       	ldi	r29, 0x00	; 0
				{
					HC595_D0_H;
					HC595_D2_H;
				}
				if(*ptr1 & 1<<j)
    19de:	8c 91       	ld	r24, X
    19e0:	68 2f       	mov	r22, r24
    19e2:	70 e0       	ldi	r23, 0x00	; 0
    19e4:	27 e0       	ldi	r18, 0x07	; 7
    19e6:	30 e0       	ldi	r19, 0x00	; 0
    19e8:	cf cf       	rjmp	.-98     	; 0x1988 <display+0x22c>
			ptr0++;
			ptr1++;
		}
			
	}
	else if(Display_color == 3)
    19ea:	83 30       	cpi	r24, 0x03	; 3
    19ec:	81 f5       	brne	.+96     	; 0x1a4e <display+0x2f2>
    19ee:	50 e0       	ldi	r21, 0x00	; 0
    19f0:	25 c0       	rjmp	.+74     	; 0x1a3c <display+0x2e0>
	/*单蓝*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
			{
				HC595_D0_L;
    19f2:	94 98       	cbi	0x12, 4	; 18
				HC595_D1_L;
    19f4:	95 98       	cbi	0x12, 5	; 18
				HC595_D2_L;
    19f6:	d9 98       	cbi	0x1b, 1	; 27
				HC595_D3_L;
    19f8:	da 98       	cbi	0x1b, 2	; 27
				HC595_D4_L;
    19fa:	db 98       	cbi	0x1b, 3	; 27
				HC595_D5_L;
    19fc:	dc 98       	cbi	0x1b, 4	; 27
    19fe:	42 2f       	mov	r20, r18
				if(*ptr0 & 1<<j)
    1a00:	ce 01       	movw	r24, r28
    1a02:	02 2e       	mov	r0, r18
    1a04:	02 c0       	rjmp	.+4      	; 0x1a0a <display+0x2ae>
    1a06:	95 95       	asr	r25
    1a08:	87 95       	ror	r24
    1a0a:	0a 94       	dec	r0
    1a0c:	e2 f7       	brpl	.-8      	; 0x1a06 <display+0x2aa>
    1a0e:	80 fd       	sbrc	r24, 0
				{
					HC595_D4_H;
    1a10:	db 9a       	sbi	0x1b, 3	; 27
				}
				if(*ptr1 & 1<<j)
    1a12:	cb 01       	movw	r24, r22
    1a14:	02 c0       	rjmp	.+4      	; 0x1a1a <display+0x2be>
    1a16:	95 95       	asr	r25
    1a18:	87 95       	ror	r24
    1a1a:	4a 95       	dec	r20
    1a1c:	e2 f7       	brpl	.-8      	; 0x1a16 <display+0x2ba>
    1a1e:	80 fd       	sbrc	r24, 0
				{
					HC595_D5_H;
    1a20:	dc 9a       	sbi	0x1b, 4	; 27
				}
				HC595_SCK_L;
    1a22:	93 98       	cbi	0x12, 3	; 18
				HC595_SCK_H;
    1a24:	93 9a       	sbi	0x12, 3	; 18
    1a26:	21 50       	subi	r18, 0x01	; 1
    1a28:	30 40       	sbci	r19, 0x00	; 0
	else if(Display_color == 3)
	{
	/*单蓝*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
    1a2a:	8f ef       	ldi	r24, 0xFF	; 255
    1a2c:	2f 3f       	cpi	r18, 0xFF	; 255
    1a2e:	38 07       	cpc	r19, r24
    1a30:	01 f7       	brne	.-64     	; 0x19f2 <display+0x296>
			
	}
	else if(Display_color == 3)
	{
	/*单蓝*/
		for(i=0;i<8;i++)
    1a32:	5f 5f       	subi	r21, 0xFF	; 255
    1a34:	58 30       	cpi	r21, 0x08	; 8
    1a36:	d9 f1       	breq	.+118    	; 0x1aae <display+0x352>
					HC595_D5_H;
				}
				HC595_SCK_L;
				HC595_SCK_H;
			}
			ptr0++;
    1a38:	31 96       	adiw	r30, 0x01	; 1
			ptr1++;
    1a3a:	11 96       	adiw	r26, 0x01	; 1
				HC595_D1_L;
				HC595_D2_L;
				HC595_D3_L;
				HC595_D4_L;
				HC595_D5_L;
				if(*ptr0 & 1<<j)
    1a3c:	80 81       	ld	r24, Z
    1a3e:	c8 2f       	mov	r28, r24
    1a40:	d0 e0       	ldi	r29, 0x00	; 0
				{
					HC595_D4_H;
				}
				if(*ptr1 & 1<<j)
    1a42:	8c 91       	ld	r24, X
    1a44:	68 2f       	mov	r22, r24
    1a46:	70 e0       	ldi	r23, 0x00	; 0
    1a48:	27 e0       	ldi	r18, 0x07	; 7
    1a4a:	30 e0       	ldi	r19, 0x00	; 0
    1a4c:	d2 cf       	rjmp	.-92     	; 0x19f2 <display+0x296>
			}
			ptr0++;
			ptr1++;
		}
	}
	else if(Display_color == 4)
    1a4e:	84 30       	cpi	r24, 0x04	; 4
    1a50:	71 f5       	brne	.+92     	; 0x1aae <display+0x352>
    1a52:	50 e0       	ldi	r21, 0x00	; 0
    1a54:	23 c0       	rjmp	.+70     	; 0x1a9c <display+0x340>
	/* 绿底黄字*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
			{
				HC595_D0_L;
    1a56:	94 98       	cbi	0x12, 4	; 18
				HC595_D1_L;
    1a58:	95 98       	cbi	0x12, 5	; 18
				HC595_D2_H;
    1a5a:	d9 9a       	sbi	0x1b, 1	; 27
				HC595_D3_H;
    1a5c:	da 9a       	sbi	0x1b, 2	; 27
    1a5e:	42 2f       	mov	r20, r18
				if(*ptr0 & 1<<j)
    1a60:	ce 01       	movw	r24, r28
    1a62:	02 2e       	mov	r0, r18
    1a64:	02 c0       	rjmp	.+4      	; 0x1a6a <display+0x30e>
    1a66:	95 95       	asr	r25
    1a68:	87 95       	ror	r24
    1a6a:	0a 94       	dec	r0
    1a6c:	e2 f7       	brpl	.-8      	; 0x1a66 <display+0x30a>
    1a6e:	80 fd       	sbrc	r24, 0
				{
					HC595_D0_H;
    1a70:	94 9a       	sbi	0x12, 4	; 18
				}
				if(*ptr1 & 1<<j)
    1a72:	cb 01       	movw	r24, r22
    1a74:	02 c0       	rjmp	.+4      	; 0x1a7a <display+0x31e>
    1a76:	95 95       	asr	r25
    1a78:	87 95       	ror	r24
    1a7a:	4a 95       	dec	r20
    1a7c:	e2 f7       	brpl	.-8      	; 0x1a76 <display+0x31a>
    1a7e:	80 fd       	sbrc	r24, 0
				{
					HC595_D1_H;
    1a80:	95 9a       	sbi	0x12, 5	; 18
				}
				HC595_SCK_L;
    1a82:	93 98       	cbi	0x12, 3	; 18
				HC595_SCK_H;
    1a84:	93 9a       	sbi	0x12, 3	; 18
    1a86:	21 50       	subi	r18, 0x01	; 1
    1a88:	30 40       	sbci	r19, 0x00	; 0
	else if(Display_color == 4)
	{
	/* 绿底黄字*/
		for(i=0;i<8;i++)
		{
			for(j=7;j>=0;j--)
    1a8a:	8f ef       	ldi	r24, 0xFF	; 255
    1a8c:	2f 3f       	cpi	r18, 0xFF	; 255
    1a8e:	38 07       	cpc	r19, r24
    1a90:	11 f7       	brne	.-60     	; 0x1a56 <display+0x2fa>
		}
	}
	else if(Display_color == 4)
	{
	/* 绿底黄字*/
		for(i=0;i<8;i++)
    1a92:	5f 5f       	subi	r21, 0xFF	; 255
    1a94:	58 30       	cpi	r21, 0x08	; 8
    1a96:	59 f0       	breq	.+22     	; 0x1aae <display+0x352>
					HC595_D1_H;
				}
				HC595_SCK_L;
				HC595_SCK_H;
			}
			ptr0++;
    1a98:	31 96       	adiw	r30, 0x01	; 1
			ptr1++;
    1a9a:	11 96       	adiw	r26, 0x01	; 1
			{
				HC595_D0_L;
				HC595_D1_L;
				HC595_D2_H;
				HC595_D3_H;
				if(*ptr0 & 1<<j)
    1a9c:	80 81       	ld	r24, Z
    1a9e:	c8 2f       	mov	r28, r24
    1aa0:	d0 e0       	ldi	r29, 0x00	; 0
				{
					HC595_D0_H;
				}
				if(*ptr1 & 1<<j)
    1aa2:	8c 91       	ld	r24, X
    1aa4:	68 2f       	mov	r22, r24
    1aa6:	70 e0       	ldi	r23, 0x00	; 0
    1aa8:	27 e0       	ldi	r18, 0x07	; 7
    1aaa:	30 e0       	ldi	r19, 0x00	; 0
    1aac:	d4 cf       	rjmp	.-88     	; 0x1a56 <display+0x2fa>
			ptr1++;
		}
	
	}
	//LS138_E_T_H;
	HC595_LAT_H;
    1aae:	92 9a       	sbi	0x12, 2	; 18

	switch(display_cnt)
    1ab0:	80 91 89 02 	lds	r24, 0x0289
    1ab4:	87 30       	cpi	r24, 0x07	; 7
    1ab6:	99 f1       	breq	.+102    	; 0x1b1e <display+0x3c2>
    1ab8:	88 30       	cpi	r24, 0x08	; 8
    1aba:	70 f4       	brcc	.+28     	; 0x1ad8 <display+0x37c>
    1abc:	83 30       	cpi	r24, 0x03	; 3
    1abe:	39 f1       	breq	.+78     	; 0x1b0e <display+0x3b2>
    1ac0:	84 30       	cpi	r24, 0x04	; 4
    1ac2:	28 f4       	brcc	.+10     	; 0x1ace <display+0x372>
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	e1 f0       	breq	.+56     	; 0x1b00 <display+0x3a4>
    1ac8:	82 30       	cpi	r24, 0x02	; 2
    1aca:	e0 f4       	brcc	.+56     	; 0x1b04 <display+0x3a8>
    1acc:	17 c0       	rjmp	.+46     	; 0x1afc <display+0x3a0>
    1ace:	85 30       	cpi	r24, 0x05	; 5
    1ad0:	11 f1       	breq	.+68     	; 0x1b16 <display+0x3ba>
    1ad2:	86 30       	cpi	r24, 0x06	; 6
    1ad4:	10 f5       	brcc	.+68     	; 0x1b1a <display+0x3be>
    1ad6:	1d c0       	rjmp	.+58     	; 0x1b12 <display+0x3b6>
    1ad8:	8b 30       	cpi	r24, 0x0B	; 11
    1ada:	59 f1       	breq	.+86     	; 0x1b32 <display+0x3d6>
    1adc:	8c 30       	cpi	r24, 0x0C	; 12
    1ade:	28 f4       	brcc	.+10     	; 0x1aea <display+0x38e>
    1ae0:	89 30       	cpi	r24, 0x09	; 9
    1ae2:	11 f1       	breq	.+68     	; 0x1b28 <display+0x3cc>
    1ae4:	8a 30       	cpi	r24, 0x0A	; 10
    1ae6:	18 f5       	brcc	.+70     	; 0x1b2e <display+0x3d2>
    1ae8:	1c c0       	rjmp	.+56     	; 0x1b22 <display+0x3c6>
    1aea:	8d 30       	cpi	r24, 0x0D	; 13
    1aec:	49 f1       	breq	.+82     	; 0x1b40 <display+0x3e4>
    1aee:	8d 30       	cpi	r24, 0x0D	; 13
    1af0:	18 f1       	brcs	.+70     	; 0x1b38 <display+0x3dc>
    1af2:	8e 30       	cpi	r24, 0x0E	; 14
    1af4:	49 f1       	breq	.+82     	; 0x1b48 <display+0x3ec>
    1af6:	8f 30       	cpi	r24, 0x0F	; 15
    1af8:	79 f5       	brne	.+94     	; 0x1b58 <display+0x3fc>
    1afa:	29 c0       	rjmp	.+82     	; 0x1b4e <display+0x3f2>
	{
		case 0: 
			LS138_D_L;LS138_C_L;LS138_B_L;LS138_A_L;
    1afc:	c4 98       	cbi	0x18, 4	; 24
    1afe:	12 c0       	rjmp	.+36     	; 0x1b24 <display+0x3c8>
			break;	
		case 1: 
			LS138_D_L;LS138_C_L;LS138_B_L;LS138_A_H;
    1b00:	c4 98       	cbi	0x18, 4	; 24
    1b02:	13 c0       	rjmp	.+38     	; 0x1b2a <display+0x3ce>
			break;
		case 2: 
			LS138_D_L;LS138_C_L;LS138_B_H;LS138_A_L;
    1b04:	c4 98       	cbi	0x18, 4	; 24
    1b06:	c2 98       	cbi	0x18, 2	; 24
    1b08:	c1 9a       	sbi	0x18, 1	; 24
    1b0a:	c0 98       	cbi	0x18, 0	; 24
    1b0c:	27 c0       	rjmp	.+78     	; 0x1b5c <display+0x400>
			break;	
		case 3: 
			LS138_D_L;LS138_C_L;LS138_B_H;LS138_A_H;
    1b0e:	c4 98       	cbi	0x18, 4	; 24
    1b10:	11 c0       	rjmp	.+34     	; 0x1b34 <display+0x3d8>
			break;		
		case 4: 
			LS138_D_L;LS138_C_H;LS138_B_L;LS138_A_L;
    1b12:	c4 98       	cbi	0x18, 4	; 24
    1b14:	12 c0       	rjmp	.+36     	; 0x1b3a <display+0x3de>
			break;	
		case 5: 
			LS138_D_L;LS138_C_H;LS138_B_L;LS138_A_H;
    1b16:	c4 98       	cbi	0x18, 4	; 24
    1b18:	14 c0       	rjmp	.+40     	; 0x1b42 <display+0x3e6>
			break;
		case 6: 
			LS138_D_L;LS138_C_H;LS138_B_H;LS138_A_L;
    1b1a:	c4 98       	cbi	0x18, 4	; 24
    1b1c:	16 c0       	rjmp	.+44     	; 0x1b4a <display+0x3ee>
			break;
		case 7: 
			LS138_D_L;LS138_C_H;LS138_B_H;LS138_A_H;
    1b1e:	c4 98       	cbi	0x18, 4	; 24
    1b20:	17 c0       	rjmp	.+46     	; 0x1b50 <display+0x3f4>
			break;	

		case 8: 
			LS138_D_H;LS138_C_L;LS138_B_L;LS138_A_L;
    1b22:	c4 9a       	sbi	0x18, 4	; 24
    1b24:	c2 98       	cbi	0x18, 2	; 24
    1b26:	0a c0       	rjmp	.+20     	; 0x1b3c <display+0x3e0>
			break;	
		case 9: 
			LS138_D_H;LS138_C_L;LS138_B_L;LS138_A_H;
    1b28:	c4 9a       	sbi	0x18, 4	; 24
    1b2a:	c2 98       	cbi	0x18, 2	; 24
    1b2c:	0b c0       	rjmp	.+22     	; 0x1b44 <display+0x3e8>
			break;	
		case 10: 
			LS138_D_H;LS138_C_L;LS138_B_H;LS138_A_L;
    1b2e:	c4 9a       	sbi	0x18, 4	; 24
    1b30:	ea cf       	rjmp	.-44     	; 0x1b06 <display+0x3aa>
			break;	
		case 11: 
			LS138_D_H;LS138_C_L;LS138_B_H;LS138_A_H;
    1b32:	c4 9a       	sbi	0x18, 4	; 24
    1b34:	c2 98       	cbi	0x18, 2	; 24
    1b36:	0d c0       	rjmp	.+26     	; 0x1b52 <display+0x3f6>
			break;	
		case 12: 
			LS138_D_H;LS138_C_H;LS138_B_L;LS138_A_L;
    1b38:	c4 9a       	sbi	0x18, 4	; 24
    1b3a:	c2 9a       	sbi	0x18, 2	; 24
    1b3c:	c1 98       	cbi	0x18, 1	; 24
    1b3e:	e5 cf       	rjmp	.-54     	; 0x1b0a <display+0x3ae>
			break;	
		case 13: 
			LS138_D_H;LS138_C_H;LS138_B_L;LS138_A_H;
    1b40:	c4 9a       	sbi	0x18, 4	; 24
    1b42:	c2 9a       	sbi	0x18, 2	; 24
    1b44:	c1 98       	cbi	0x18, 1	; 24
    1b46:	06 c0       	rjmp	.+12     	; 0x1b54 <display+0x3f8>
			break;	
		case 14: 
			LS138_D_H;LS138_C_H;LS138_B_H;LS138_A_L;
    1b48:	c4 9a       	sbi	0x18, 4	; 24
    1b4a:	c2 9a       	sbi	0x18, 2	; 24
    1b4c:	dd cf       	rjmp	.-70     	; 0x1b08 <display+0x3ac>
			break;	
		case 15: 
			LS138_D_H;LS138_C_H;LS138_B_H;LS138_A_H;
    1b4e:	c4 9a       	sbi	0x18, 4	; 24
    1b50:	c2 9a       	sbi	0x18, 2	; 24
    1b52:	c1 9a       	sbi	0x18, 1	; 24
    1b54:	c0 9a       	sbi	0x18, 0	; 24
    1b56:	02 c0       	rjmp	.+4      	; 0x1b5c <display+0x400>
			break;	

		default: display_cnt=0;break;
    1b58:	10 92 89 02 	sts	0x0289, r1
	}
	//LS138_E_T_L;
	display_cnt++;
    1b5c:	80 91 89 02 	lds	r24, 0x0289
    1b60:	8f 5f       	subi	r24, 0xFF	; 255
    1b62:	80 93 89 02 	sts	0x0289, r24
	if(display_cnt==16)display_cnt=0;
    1b66:	80 91 89 02 	lds	r24, 0x0289
    1b6a:	80 31       	cpi	r24, 0x10	; 16
    1b6c:	11 f4       	brne	.+4      	; 0x1b72 <display+0x416>
    1b6e:	10 92 89 02 	sts	0x0289, r1
}
    1b72:	df 91       	pop	r29
    1b74:	cf 91       	pop	r28
    1b76:	1f 91       	pop	r17
    1b78:	08 95       	ret

00001b7a <twi_init>:
#define _TWI_H_

//功能描述: i2c通信初始化
void twi_init(void)
{
 TWCR= 0x00; //disable twi
    1b7a:	16 be       	out	0x36, r1	; 54
 TWBR= (1<<6) | (1<<5) | (1<<2); //set bit rate
    1b7c:	84 e6       	ldi	r24, 0x64	; 100
    1b7e:	80 b9       	out	0x00, r24	; 0
 TWSR= 0x00; //set prescale
    1b80:	11 b8       	out	0x01, r1	; 1
 TWAR= 0x00; //set slave address
    1b82:	12 b8       	out	0x02, r1	; 2
 TWCR= (1<<TWEN); //enable twi
    1b84:	84 e0       	ldi	r24, 0x04	; 4
    1b86:	86 bf       	out	0x36, r24	; 54
}
    1b88:	08 95       	ret

00001b8a <i2cstart>:

//i2c通信开始
void i2cstart(void)
{ 
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
    1b8a:	84 ea       	ldi	r24, 0xA4	; 164
    1b8c:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1b8e:	06 b6       	in	r0, 0x36	; 54
    1b90:	07 fe       	sbrs	r0, 7
    1b92:	fd cf       	rjmp	.-6      	; 0x1b8e <i2cstart+0x4>
}
    1b94:	08 95       	ret

00001b96 <i2cwt>:

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1b96:	83 b9       	out	0x03, r24	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1b98:	84 e8       	ldi	r24, 0x84	; 132
    1b9a:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1b9c:	06 b6       	in	r0, 0x36	; 54
    1b9e:	07 fe       	sbrs	r0, 7
    1ba0:	fd cf       	rjmp	.-6      	; 0x1b9c <i2cwt+0x6>
   	asm("nop");
    1ba2:	00 00       	nop
   	return(TWSR&0b11111000);
    1ba4:	81 b1       	in	r24, 0x01	; 1
}
    1ba6:	88 7f       	andi	r24, 0xF8	; 248
    1ba8:	08 95       	ret

00001baa <i2crd>:

//i2c读数据
unsigned char i2crd(void)
{
   	TWCR= (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
    1baa:	84 ec       	ldi	r24, 0xC4	; 196
    1bac:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1bae:	06 b6       	in	r0, 0x36	; 54
    1bb0:	07 fe       	sbrs	r0, 7
    1bb2:	fd cf       	rjmp	.-6      	; 0x1bae <i2crd+0x4>
   	return(TWDR);
    1bb4:	83 b1       	in	r24, 0x03	; 3
}
    1bb6:	08 95       	ret

00001bb8 <i2cstop>:

//功能描述: i2c停止
void i2cstop(void)
{ 
   TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    1bb8:	84 e9       	ldi	r24, 0x94	; 148
    1bba:	86 bf       	out	0x36, r24	; 54
}
    1bbc:	08 95       	ret

00001bbe <clear>:

uint16 freshTimeCount = 0;

//清除指定区域指定长度的数据
void clear(unsigned char *p,unsigned char num)
{
    1bbe:	fc 01       	movw	r30, r24
    1bc0:	02 c0       	rjmp	.+4      	; 0x1bc6 <clear+0x8>
 for(;num>0;num--)
 	{
	 *p=0;
    1bc2:	11 92       	st	Z+, r1
uint16 freshTimeCount = 0;

//清除指定区域指定长度的数据
void clear(unsigned char *p,unsigned char num)
{
 for(;num>0;num--)
    1bc4:	61 50       	subi	r22, 0x01	; 1
    1bc6:	66 23       	and	r22, r22
    1bc8:	e1 f7       	brne	.-8      	; 0x1bc2 <clear+0x4>
 	{
	 *p=0;
	 p++;
	}
}
    1bca:	08 95       	ret

00001bcc <PCF8536_wt>:

//功能描述: 向PCF8563指定地址写入一条数据
void PCF8536_wt(unsigned int add,unsigned char data)
{
    1bcc:	28 2f       	mov	r18, r24
}

//i2c通信开始
void i2cstart(void)
{ 
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
    1bce:	84 ea       	ldi	r24, 0xA4	; 164
    1bd0:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1bd2:	06 b6       	in	r0, 0x36	; 54
    1bd4:	07 fe       	sbrs	r0, 7
    1bd6:	fd cf       	rjmp	.-6      	; 0x1bd2 <PCF8536_wt+0x6>
 unsigned char t;
 t=add>>8;
 t<<=1;
 i2cstart();
 if(i2cwt(W_ADD_COM+t)==SLAW)
    1bd8:	99 0f       	add	r25, r25
    1bda:	9e 55       	subi	r25, 0x5E	; 94
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1bdc:	93 b9       	out	0x03, r25	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1bde:	84 e8       	ldi	r24, 0x84	; 132
    1be0:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1be2:	06 b6       	in	r0, 0x36	; 54
    1be4:	07 fe       	sbrs	r0, 7
    1be6:	fd cf       	rjmp	.-6      	; 0x1be2 <PCF8536_wt+0x16>
   	asm("nop");
    1be8:	00 00       	nop
   	return(TWSR&0b11111000);
    1bea:	81 b1       	in	r24, 0x01	; 1
    1bec:	88 7f       	andi	r24, 0xF8	; 248
    1bee:	88 31       	cpi	r24, 0x18	; 24
    1bf0:	89 f4       	brne	.+34     	; 0x1c14 <PCF8536_wt+0x48>
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1bf2:	23 b9       	out	0x03, r18	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1bf4:	84 e8       	ldi	r24, 0x84	; 132
    1bf6:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1bf8:	06 b6       	in	r0, 0x36	; 54
    1bfa:	07 fe       	sbrs	r0, 7
    1bfc:	fd cf       	rjmp	.-6      	; 0x1bf8 <PCF8536_wt+0x2c>
   	asm("nop");
    1bfe:	00 00       	nop
   	return(TWSR&0b11111000);
    1c00:	81 b1       	in	r24, 0x01	; 1
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1c02:	63 b9       	out	0x03, r22	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1c04:	84 e8       	ldi	r24, 0x84	; 132
    1c06:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1c08:	06 b6       	in	r0, 0x36	; 54
    1c0a:	07 fe       	sbrs	r0, 7
    1c0c:	fd cf       	rjmp	.-6      	; 0x1c08 <PCF8536_wt+0x3c>
   	asm("nop");
    1c0e:	00 00       	nop
   	return(TWSR&0b11111000);
    1c10:	81 b1       	in	r24, 0x01	; 1
    1c12:	03 c0       	rjmp	.+6      	; 0x1c1a <PCF8536_wt+0x4e>
 	{
	 i2cwt(add);
	 i2cwt(data);
	}
 else syserr=ERR_SLAW;
    1c14:	81 e0       	ldi	r24, 0x01	; 1
    1c16:	80 93 98 02 	sts	0x0298, r24
}

//功能描述: i2c停止
void i2cstop(void)
{ 
   TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    1c1a:	84 e9       	ldi	r24, 0x94	; 148
    1c1c:	86 bf       	out	0x36, r24	; 54
 i2cstop();
}
    1c1e:	08 95       	ret

00001c20 <PCF8536_wt_p>:

//功能描述: 向PCF8563地址连续的寄存器写入系列数据
void PCF8536_wt_p(unsigned int add,unsigned char *p,unsigned char num)
{
    1c20:	28 2f       	mov	r18, r24
    1c22:	fb 01       	movw	r30, r22
}

//i2c通信开始
void i2cstart(void)
{ 
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
    1c24:	84 ea       	ldi	r24, 0xA4	; 164
    1c26:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1c28:	06 b6       	in	r0, 0x36	; 54
    1c2a:	07 fe       	sbrs	r0, 7
    1c2c:	fd cf       	rjmp	.-6      	; 0x1c28 <PCF8536_wt_p+0x8>
 unsigned char t;
 t=add>>8;
 t<<=1;
 i2cstart();
 if(i2cwt(W_ADD_COM+t)==SLAW)
    1c2e:	99 0f       	add	r25, r25
    1c30:	9e 55       	subi	r25, 0x5E	; 94
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1c32:	93 b9       	out	0x03, r25	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1c34:	84 e8       	ldi	r24, 0x84	; 132
    1c36:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1c38:	06 b6       	in	r0, 0x36	; 54
    1c3a:	07 fe       	sbrs	r0, 7
    1c3c:	fd cf       	rjmp	.-6      	; 0x1c38 <PCF8536_wt_p+0x18>
   	asm("nop");
    1c3e:	00 00       	nop
   	return(TWSR&0b11111000);
    1c40:	81 b1       	in	r24, 0x01	; 1
    1c42:	88 7f       	andi	r24, 0xF8	; 248
    1c44:	88 31       	cpi	r24, 0x18	; 24
    1c46:	c1 f4       	brne	.+48     	; 0x1c78 <PCF8536_wt_p+0x58>
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1c48:	23 b9       	out	0x03, r18	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1c4a:	84 e8       	ldi	r24, 0x84	; 132
    1c4c:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1c4e:	06 b6       	in	r0, 0x36	; 54
    1c50:	07 fe       	sbrs	r0, 7
    1c52:	fd cf       	rjmp	.-6      	; 0x1c4e <PCF8536_wt_p+0x2e>
   	asm("nop");
    1c54:	00 00       	nop
   	return(TWSR&0b11111000);
    1c56:	81 b1       	in	r24, 0x01	; 1

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1c58:	94 e8       	ldi	r25, 0x84	; 132
    1c5a:	0b c0       	rjmp	.+22     	; 0x1c72 <PCF8536_wt_p+0x52>
 	{
	 i2cwt(add);
	 for(;num>0;num--)
	 	{
		 i2cwt(*p);
    1c5c:	80 81       	ld	r24, Z
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1c5e:	83 b9       	out	0x03, r24	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1c60:	96 bf       	out	0x36, r25	; 54
   	while (!(TWCR & (1<<TWINT)));
    1c62:	06 b6       	in	r0, 0x36	; 54
    1c64:	07 fe       	sbrs	r0, 7
    1c66:	fd cf       	rjmp	.-6      	; 0x1c62 <PCF8536_wt_p+0x42>
   	asm("nop");
    1c68:	00 00       	nop
   	return(TWSR&0b11111000);
    1c6a:	81 b1       	in	r24, 0x01	; 1
		 p++;
    1c6c:	31 96       	adiw	r30, 0x01	; 1
		 asm("nop");
    1c6e:	00 00       	nop
 t<<=1;
 i2cstart();
 if(i2cwt(W_ADD_COM+t)==SLAW)
 	{
	 i2cwt(add);
	 for(;num>0;num--)
    1c70:	41 50       	subi	r20, 0x01	; 1
    1c72:	44 23       	and	r20, r20
    1c74:	99 f7       	brne	.-26     	; 0x1c5c <PCF8536_wt_p+0x3c>
    1c76:	03 c0       	rjmp	.+6      	; 0x1c7e <PCF8536_wt_p+0x5e>
		 i2cwt(*p);
		 p++;
		 asm("nop");
		}
	}
 else syserr=ERR_SLAW;
    1c78:	81 e0       	ldi	r24, 0x01	; 1
    1c7a:	80 93 98 02 	sts	0x0298, r24
}

//功能描述: i2c停止
void i2cstop(void)
{ 
   TWCR = (1<<TWINT) | (1<<TWSTO) | (1<<TWEN);
    1c7e:	84 e9       	ldi	r24, 0x94	; 148
    1c80:	86 bf       	out	0x36, r24	; 54
 i2cstop();
}
    1c82:	08 95       	ret

00001c84 <PCF8536_rd>:

//读PCF8563
void PCF8536_rd(unsigned int add,unsigned char *p,unsigned char num)
{
    1c84:	28 2f       	mov	r18, r24
    1c86:	fb 01       	movw	r30, r22
 unsigned char t;
 t=add>>8;
 t<<=1;
    1c88:	99 0f       	add	r25, r25
}

//i2c通信开始
void i2cstart(void)
{ 
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
    1c8a:	84 ea       	ldi	r24, 0xA4	; 164
    1c8c:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1c8e:	06 b6       	in	r0, 0x36	; 54
    1c90:	07 fe       	sbrs	r0, 7
    1c92:	fd cf       	rjmp	.-6      	; 0x1c8e <PCF8536_rd+0xa>
 i2cstart();
 if(i2cwt(W_ADD_COM+t)==SLAW)
    1c94:	9e 55       	subi	r25, 0x5E	; 94
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1c96:	93 b9       	out	0x03, r25	; 3
    1c98:	92 5a       	subi	r25, 0xA2	; 162
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1c9a:	84 e8       	ldi	r24, 0x84	; 132
    1c9c:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1c9e:	06 b6       	in	r0, 0x36	; 54
    1ca0:	07 fe       	sbrs	r0, 7
    1ca2:	fd cf       	rjmp	.-6      	; 0x1c9e <PCF8536_rd+0x1a>
   	asm("nop");
    1ca4:	00 00       	nop
   	return(TWSR&0b11111000);
    1ca6:	81 b1       	in	r24, 0x01	; 1
    1ca8:	88 7f       	andi	r24, 0xF8	; 248
    1caa:	88 31       	cpi	r24, 0x18	; 24
    1cac:	49 f4       	brne	.+18     	; 0x1cc0 <PCF8536_rd+0x3c>
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1cae:	23 b9       	out	0x03, r18	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1cb0:	84 e8       	ldi	r24, 0x84	; 132
    1cb2:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1cb4:	06 b6       	in	r0, 0x36	; 54
    1cb6:	07 fe       	sbrs	r0, 7
    1cb8:	fd cf       	rjmp	.-6      	; 0x1cb4 <PCF8536_rd+0x30>
   	asm("nop");
    1cba:	00 00       	nop
   	return(TWSR&0b11111000);
    1cbc:	81 b1       	in	r24, 0x01	; 1
    1cbe:	03 c0       	rjmp	.+6      	; 0x1cc6 <PCF8536_rd+0x42>
 	{
	 i2cwt(add);
	}
 else syserr=ERR_SLAW;
    1cc0:	81 e0       	ldi	r24, 0x01	; 1
    1cc2:	80 93 98 02 	sts	0x0298, r24
}

//i2c通信开始
void i2cstart(void)
{ 
	TWCR = (1<<TWINT) | (1<<TWSTA) | (1<<TWEN); 
    1cc6:	84 ea       	ldi	r24, 0xA4	; 164
    1cc8:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1cca:	06 b6       	in	r0, 0x36	; 54
    1ccc:	07 fe       	sbrs	r0, 7
    1cce:	fd cf       	rjmp	.-6      	; 0x1cca <PCF8536_rd+0x46>
 
 i2cstart();
 if(i2cwt(R_ADD_COM+t)==SLAW)
    1cd0:	9d 55       	subi	r25, 0x5D	; 93
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1cd2:	93 b9       	out	0x03, r25	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1cd4:	84 e8       	ldi	r24, 0x84	; 132
    1cd6:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1cd8:	06 b6       	in	r0, 0x36	; 54
    1cda:	07 fe       	sbrs	r0, 7
    1cdc:	fd cf       	rjmp	.-6      	; 0x1cd8 <PCF8536_rd+0x54>
   	asm("nop");
    1cde:	00 00       	nop
   	return(TWSR&0b11111000);
    1ce0:	81 b1       	in	r24, 0x01	; 1
    1ce2:	88 7f       	andi	r24, 0xF8	; 248
    1ce4:	88 31       	cpi	r24, 0x18	; 24
    1ce6:	49 f4       	brne	.+18     	; 0x1cfa <PCF8536_rd+0x76>
}

//i2c写数据,返回TWI状态
unsigned char i2cwt(unsigned char data)
{ 
	TWDR = data;
    1ce8:	23 b9       	out	0x03, r18	; 3
   	TWCR = (1<<TWINT) | (1<<TWEN);
    1cea:	84 e8       	ldi	r24, 0x84	; 132
    1cec:	86 bf       	out	0x36, r24	; 54
   	while (!(TWCR & (1<<TWINT)));
    1cee:	06 b6       	in	r0, 0x36	; 54
    1cf0:	07 fe       	sbrs	r0, 7
    1cf2:	fd cf       	rjmp	.-6      	; 0x1cee <PCF8536_rd+0x6a>
   	asm("nop");
    1cf4:	00 00       	nop
   	return(TWSR&0b11111000);
    1cf6:	81 b1       	in	r24, 0x01	; 1
    1cf8:	0c c0       	rjmp	.+24     	; 0x1d12 <PCF8536_rd+0x8e>
 	{
	 i2cwt(add);
	}
 else syserr=ERR_SLAW;
    1cfa:	81 e0       	ldi	r24, 0x01	; 1
    1cfc:	80 93 98 02 	sts	0x0298, r24
    1d00:	08 c0       	rjmp	.+16     	; 0x1d12 <PCF8536_rd+0x8e>
}

//i2c读数据
unsigned char i2crd(void)
{
   	TWCR= (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
    1d02:	96 bf       	out	0x36, r25	; 54
   	while (!(TWCR & (1<<TWINT)));
    1d04:	06 b6       	in	r0, 0x36	; 54
    1d06:	07 fe       	sbrs	r0, 7
    1d08:	fd cf       	rjmp	.-6      	; 0x1d04 <PCF8536_rd+0x80>
   	return(TWDR);
    1d0a:	83 b1       	in	r24, 0x03	; 3
 
 for(;num>0;num--)
 	{
	 *p=i2crd();
    1d0c:	81 93       	st	Z+, r24
 	{
	 i2cwt(add);
	}
 else syserr=ERR_SLAW;
 
 for(;num>0;num--)
    1d0e:	41 50       	subi	r20, 0x01	; 1
    1d10:	01 c0       	rjmp	.+2      	; 0x1d14 <PCF8536_rd+0x90>
}

//i2c读数据
unsigned char i2crd(void)
{
   	TWCR= (1<<TWINT) | (1<<TWEA) | (1<<TWEN);
    1d12:	94 ec       	ldi	r25, 0xC4	; 196
    1d14:	44 23       	and	r20, r20
    1d16:	a9 f7       	brne	.-22     	; 0x1d02 <PCF8536_rd+0x7e>
 	{
	 *p=i2crd();
	 p++;
	} 
}
    1d18:	08 95       	ret

00001d1a <PCF8563_init>:

//功能描述: PCF8563初始化
void PCF8563_init(void)
{
    1d1a:	e0 ea       	ldi	r30, 0xA0	; 160
    1d1c:	f2 e0       	ldi	r31, 0x02	; 2
//清除指定区域指定长度的数据
void clear(unsigned char *p,unsigned char num)
{
 for(;num>0;num--)
 	{
	 *p=0;
    1d1e:	11 92       	st	Z+, r1
uint16 freshTimeCount = 0;

//清除指定区域指定长度的数据
void clear(unsigned char *p,unsigned char num)
{
 for(;num>0;num--)
    1d20:	82 e0       	ldi	r24, 0x02	; 2
    1d22:	e8 3a       	cpi	r30, 0xA8	; 168
    1d24:	f8 07       	cpc	r31, r24
    1d26:	d9 f7       	brne	.-10     	; 0x1d1e <PCF8563_init+0x4>
    1d28:	ee e8       	ldi	r30, 0x8E	; 142
    1d2a:	f2 e0       	ldi	r31, 0x02	; 2
 	{
	 *p=0;
    1d2c:	11 92       	st	Z+, r1
uint16 freshTimeCount = 0;

//清除指定区域指定长度的数据
void clear(unsigned char *p,unsigned char num)
{
 for(;num>0;num--)
    1d2e:	82 e0       	ldi	r24, 0x02	; 2
    1d30:	e6 39       	cpi	r30, 0x96	; 150
    1d32:	f8 07       	cpc	r31, r24
    1d34:	d9 f7       	brne	.-10     	; 0x1d2c <PCF8563_init+0x12>
void PCF8563_init(void)
{
 clear(write_buff,8);
 clear(read_buff,8);
 
 PCF8536_wt(0x00,0x20);//写寄存器1，停止计时
    1d36:	80 e0       	ldi	r24, 0x00	; 0
    1d38:	90 e0       	ldi	r25, 0x00	; 0
    1d3a:	60 e2       	ldi	r22, 0x20	; 32
    1d3c:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <PCF8536_wt>
 //PCF8536_wt_p(0x02,time,7);//设定时间
 PCF8536_wt(0x00,0x00);//写寄存器1，开始计时
    1d40:	80 e0       	ldi	r24, 0x00	; 0
    1d42:	90 e0       	ldi	r25, 0x00	; 0
    1d44:	60 e0       	ldi	r22, 0x00	; 0
    1d46:	0e 94 e6 0d 	call	0x1bcc	; 0x1bcc <PCF8536_wt>
}
    1d4a:	08 95       	ret

00001d4c <Updata_time>:

//刷新时间寄存器及相关数组内容
void Updata_time(void)
{
	PCF8536_rd(0x02,time,7);//读取时间
    1d4c:	82 e0       	ldi	r24, 0x02	; 2
    1d4e:	90 e0       	ldi	r25, 0x00	; 0
    1d50:	6d e7       	ldi	r22, 0x7D	; 125
    1d52:	70 e0       	ldi	r23, 0x00	; 0
    1d54:	47 e0       	ldi	r20, 0x07	; 7
    1d56:	0e 94 42 0e 	call	0x1c84	; 0x1c84 <PCF8536_rd>

	time[0]=time[0]&0x7F;
    1d5a:	80 91 7d 00 	lds	r24, 0x007D
    1d5e:	98 2f       	mov	r25, r24
    1d60:	9f 77       	andi	r25, 0x7F	; 127
    1d62:	90 93 7d 00 	sts	0x007D, r25
	time[1]=time[1]&0x7F;
    1d66:	20 91 7e 00 	lds	r18, 0x007E
    1d6a:	42 2f       	mov	r20, r18
    1d6c:	4f 77       	andi	r20, 0x7F	; 127
    1d6e:	40 93 7e 00 	sts	0x007E, r20
	time[2]=time[2]&0x3F;
    1d72:	50 91 7f 00 	lds	r21, 0x007F
    1d76:	75 2f       	mov	r23, r21
    1d78:	7f 73       	andi	r23, 0x3F	; 63
    1d7a:	70 93 7f 00 	sts	0x007F, r23
	time[3]=time[3]&0x3F;
    1d7e:	e0 91 80 00 	lds	r30, 0x0080
    1d82:	ae 2f       	mov	r26, r30
    1d84:	af 73       	andi	r26, 0x3F	; 63
    1d86:	a0 93 80 00 	sts	0x0080, r26
	time[4]=time[4]&0x07;
    1d8a:	f0 91 81 00 	lds	r31, 0x0081
    1d8e:	f7 70       	andi	r31, 0x07	; 7
    1d90:	f0 93 81 00 	sts	0x0081, r31
	time[5]=time[5]&0x1F;
    1d94:	30 91 82 00 	lds	r19, 0x0082
    1d98:	63 2f       	mov	r22, r19
    1d9a:	6f 71       	andi	r22, 0x1F	; 31
    1d9c:	60 93 82 00 	sts	0x0082, r22
	//time_tmp[]="00:00:00",data_tmp[]="2008.01.01",*week_tmp;
	//处理时间
	SecondOne = time[0]&0x0F;
    1da0:	8f 70       	andi	r24, 0x0F	; 15
    1da2:	80 93 6d 00 	sts	0x006D, r24
	SecondTen = time[0]>>4;
    1da6:	92 95       	swap	r25
    1da8:	9f 70       	andi	r25, 0x0F	; 15
    1daa:	90 93 6c 00 	sts	0x006C, r25
	MinuteOne = time[1]&0x0F;
    1dae:	2f 70       	andi	r18, 0x0F	; 15
    1db0:	20 93 6b 00 	sts	0x006B, r18
	MinuteTen = time[1]>>4;
    1db4:	42 95       	swap	r20
    1db6:	4f 70       	andi	r20, 0x0F	; 15
    1db8:	40 93 6a 00 	sts	0x006A, r20
	HourOne	= time[2]&0x0F;
    1dbc:	5f 70       	andi	r21, 0x0F	; 15
    1dbe:	50 93 69 00 	sts	0x0069, r21
	HourTen	= time[2]>>4;
    1dc2:	72 95       	swap	r23
    1dc4:	7f 70       	andi	r23, 0x0F	; 15
    1dc6:	70 93 68 00 	sts	0x0068, r23
	//处理日期
	DayOne = time[3]&0x0F;
    1dca:	ef 70       	andi	r30, 0x0F	; 15
    1dcc:	e0 93 67 00 	sts	0x0067, r30
	DayTen = time[3]>>4;
    1dd0:	a2 95       	swap	r26
    1dd2:	af 70       	andi	r26, 0x0F	; 15
    1dd4:	a0 93 66 00 	sts	0x0066, r26
	MonthOne = time[5]&0x0F;
    1dd8:	3f 70       	andi	r19, 0x0F	; 15
    1dda:	30 93 65 00 	sts	0x0065, r19
	MonthTen = time[5]>>4;
    1dde:	62 95       	swap	r22
    1de0:	6f 70       	andi	r22, 0x0F	; 15
    1de2:	60 93 64 00 	sts	0x0064, r22
	YearOne = time[6]&0x0F;
    1de6:	80 91 83 00 	lds	r24, 0x0083
    1dea:	98 2f       	mov	r25, r24
    1dec:	9f 70       	andi	r25, 0x0F	; 15
    1dee:	90 93 63 00 	sts	0x0063, r25
	YearTen = time[6]>>4;
    1df2:	82 95       	swap	r24
    1df4:	8f 70       	andi	r24, 0x0F	; 15
    1df6:	80 93 62 00 	sts	0x0062, r24
	//处理星期
	Week = (time[4]&0x0F)+1;
    1dfa:	ff 5f       	subi	r31, 0xFF	; 255
    1dfc:	f0 93 6e 00 	sts	0x006E, r31
}
    1e00:	08 95       	ret

00001e02 <Write_time>:

void Write_time(void)
{
    1e02:	df 93       	push	r29
    1e04:	cf 93       	push	r28
    1e06:	cd b7       	in	r28, 0x3d	; 61
    1e08:	de b7       	in	r29, 0x3e	; 62
    1e0a:	27 97       	sbiw	r28, 0x07	; 7
    1e0c:	0f b6       	in	r0, 0x3f	; 63
    1e0e:	f8 94       	cli
    1e10:	de bf       	out	0x3e, r29	; 62
    1e12:	0f be       	out	0x3f, r0	; 63
    1e14:	cd bf       	out	0x3d, r28	; 61
								(HourTen<<4)| HourOne,
								(DayTen<<4)| DayOne,
								Week-1,
								(MonthTen <<4)| MonthOne,	
								(YearTen <<4)| YearOne,
	};
    1e16:	60 91 6a 00 	lds	r22, 0x006A
    1e1a:	62 95       	swap	r22
    1e1c:	60 7f       	andi	r22, 0xF0	; 240
    1e1e:	80 91 6b 00 	lds	r24, 0x006B
    1e22:	68 2b       	or	r22, r24
    1e24:	50 91 68 00 	lds	r21, 0x0068
    1e28:	52 95       	swap	r21
    1e2a:	50 7f       	andi	r21, 0xF0	; 240
    1e2c:	80 91 69 00 	lds	r24, 0x0069
    1e30:	58 2b       	or	r21, r24
    1e32:	40 91 66 00 	lds	r20, 0x0066
    1e36:	42 95       	swap	r20
    1e38:	40 7f       	andi	r20, 0xF0	; 240
    1e3a:	80 91 67 00 	lds	r24, 0x0067
    1e3e:	48 2b       	or	r20, r24
    1e40:	70 91 6e 00 	lds	r23, 0x006E
    1e44:	71 50       	subi	r23, 0x01	; 1
    1e46:	30 91 64 00 	lds	r19, 0x0064
    1e4a:	32 95       	swap	r19
    1e4c:	30 7f       	andi	r19, 0xF0	; 240
    1e4e:	80 91 65 00 	lds	r24, 0x0065
    1e52:	38 2b       	or	r19, r24
    1e54:	20 91 62 00 	lds	r18, 0x0062
    1e58:	22 95       	swap	r18
    1e5a:	20 7f       	andi	r18, 0xF0	; 240
    1e5c:	80 91 63 00 	lds	r24, 0x0063
    1e60:	28 2b       	or	r18, r24
    1e62:	80 91 6c 00 	lds	r24, 0x006C
    1e66:	82 95       	swap	r24
    1e68:	80 7f       	andi	r24, 0xF0	; 240
    1e6a:	90 91 6d 00 	lds	r25, 0x006D
    1e6e:	89 2b       	or	r24, r25
    1e70:	89 83       	std	Y+1, r24	; 0x01
    1e72:	6a 83       	std	Y+2, r22	; 0x02
    1e74:	5b 83       	std	Y+3, r21	; 0x03
    1e76:	4c 83       	std	Y+4, r20	; 0x04
    1e78:	7d 83       	std	Y+5, r23	; 0x05
    1e7a:	3e 83       	std	Y+6, r19	; 0x06
    1e7c:	2f 83       	std	Y+7, r18	; 0x07
	PCF8536_wt_p(0x02, timeWriteBuffer, 7);
    1e7e:	82 e0       	ldi	r24, 0x02	; 2
    1e80:	90 e0       	ldi	r25, 0x00	; 0
    1e82:	be 01       	movw	r22, r28
    1e84:	6f 5f       	subi	r22, 0xFF	; 255
    1e86:	7f 4f       	sbci	r23, 0xFF	; 255
    1e88:	47 e0       	ldi	r20, 0x07	; 7
    1e8a:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <PCF8536_wt_p>
}
    1e8e:	27 96       	adiw	r28, 0x07	; 7
    1e90:	0f b6       	in	r0, 0x3f	; 63
    1e92:	f8 94       	cli
    1e94:	de bf       	out	0x3e, r29	; 62
    1e96:	0f be       	out	0x3f, r0	; 63
    1e98:	cd bf       	out	0x3d, r28	; 61
    1e9a:	cf 91       	pop	r28
    1e9c:	df 91       	pop	r29
    1e9e:	08 95       	ret

00001ea0 <AjustTimerMonthly>:

void AjustTimerMonthly()
{
    1ea0:	1f 93       	push	r17
	if(DayTen == 0 && DayOne == 1) // 每个月的一号 
    1ea2:	80 91 66 00 	lds	r24, 0x0066
    1ea6:	88 23       	and	r24, r24
    1ea8:	09 f0       	breq	.+2      	; 0x1eac <AjustTimerMonthly+0xc>
    1eaa:	4e c0       	rjmp	.+156    	; 0x1f48 <AjustTimerMonthly+0xa8>
    1eac:	10 91 67 00 	lds	r17, 0x0067
    1eb0:	11 30       	cpi	r17, 0x01	; 1
    1eb2:	09 f0       	breq	.+2      	; 0x1eb6 <AjustTimerMonthly+0x16>
    1eb4:	49 c0       	rjmp	.+146    	; 0x1f48 <AjustTimerMonthly+0xa8>
	{
		if(HourTen == 0 && HourOne == 3) //三点
    1eb6:	80 91 68 00 	lds	r24, 0x0068
    1eba:	88 23       	and	r24, r24
    1ebc:	09 f0       	breq	.+2      	; 0x1ec0 <AjustTimerMonthly+0x20>
    1ebe:	44 c0       	rjmp	.+136    	; 0x1f48 <AjustTimerMonthly+0xa8>
    1ec0:	80 91 69 00 	lds	r24, 0x0069
    1ec4:	83 30       	cpi	r24, 0x03	; 3
    1ec6:	09 f0       	breq	.+2      	; 0x1eca <AjustTimerMonthly+0x2a>
    1ec8:	3f c0       	rjmp	.+126    	; 0x1f48 <AjustTimerMonthly+0xa8>
		{
			if(MinuteTen  == 3 && MinuteOne  == 0) //30分
    1eca:	80 91 6a 00 	lds	r24, 0x006A
    1ece:	83 30       	cpi	r24, 0x03	; 3
    1ed0:	b9 f5       	brne	.+110    	; 0x1f40 <AjustTimerMonthly+0xa0>
    1ed2:	80 91 6b 00 	lds	r24, 0x006B
    1ed6:	88 23       	and	r24, r24
    1ed8:	b9 f5       	brne	.+110    	; 0x1f48 <AjustTimerMonthly+0xa8>
			{
				if(AjustTimeMode && !AjustTimeIsAjusted) //加时间
    1eda:	80 91 76 00 	lds	r24, 0x0076
    1ede:	88 23       	and	r24, r24
    1ee0:	79 f0       	breq	.+30     	; 0x1f00 <AjustTimerMonthly+0x60>
    1ee2:	80 91 79 00 	lds	r24, 0x0079
    1ee6:	88 23       	and	r24, r24
    1ee8:	79 f5       	brne	.+94     	; 0x1f48 <AjustTimerMonthly+0xa8>
				{
					uint8 temp = MinuteTen*10 + MinuteOne;
					temp = temp + AjustTimeTen*10 + AjustTimeOne;
    1eea:	20 91 78 00 	lds	r18, 0x0078
    1eee:	22 5e       	subi	r18, 0xE2	; 226
    1ef0:	80 91 77 00 	lds	r24, 0x0077
    1ef4:	3a e0       	ldi	r19, 0x0A	; 10
    1ef6:	83 9f       	mul	r24, r19
    1ef8:	c0 01       	movw	r24, r0
    1efa:	11 24       	eor	r1, r1
    1efc:	28 0f       	add	r18, r24
    1efe:	10 c0       	rjmp	.+32     	; 0x1f20 <AjustTimerMonthly+0x80>
					MinuteTen = temp/10;
					MinuteOne = temp%10;
					Write_time();
					AjustTimeIsAjusted = 1;
				}
				else if(!AjustTimeMode && !AjustTimeIsAjusted) //减时间
    1f00:	80 91 79 00 	lds	r24, 0x0079
    1f04:	88 23       	and	r24, r24
    1f06:	01 f5       	brne	.+64     	; 0x1f48 <AjustTimerMonthly+0xa8>
				{
					uint8 temp = MinuteTen*10 + MinuteOne;
					temp = temp - AjustTimeTen*10 - AjustTimeOne;
    1f08:	3e e1       	ldi	r19, 0x1E	; 30
    1f0a:	80 91 78 00 	lds	r24, 0x0078
    1f0e:	38 1b       	sub	r19, r24
    1f10:	20 91 77 00 	lds	r18, 0x0077
    1f14:	86 ef       	ldi	r24, 0xF6	; 246
    1f16:	9f ef       	ldi	r25, 0xFF	; 255
    1f18:	28 9f       	mul	r18, r24
    1f1a:	20 2d       	mov	r18, r0
    1f1c:	11 24       	eor	r1, r1
    1f1e:	23 0f       	add	r18, r19
					MinuteTen = temp/10;
    1f20:	82 2f       	mov	r24, r18
    1f22:	6a e0       	ldi	r22, 0x0A	; 10
    1f24:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    1f28:	80 93 6a 00 	sts	0x006A, r24
					MinuteOne = temp%10;
    1f2c:	82 2f       	mov	r24, r18
    1f2e:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    1f32:	90 93 6b 00 	sts	0x006B, r25
					Write_time();
    1f36:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <Write_time>
					AjustTimeIsAjusted = 1;
    1f3a:	10 93 79 00 	sts	0x0079, r17
    1f3e:	04 c0       	rjmp	.+8      	; 0x1f48 <AjustTimerMonthly+0xa8>
				}
			}
			else if(MinuteTen  == 5)
    1f40:	85 30       	cpi	r24, 0x05	; 5
    1f42:	11 f4       	brne	.+4      	; 0x1f48 <AjustTimerMonthly+0xa8>
			{
				AjustTimeIsAjusted = 0;
    1f44:	10 92 79 00 	sts	0x0079, r1
			}

		}
	}
}
    1f48:	1f 91       	pop	r17
    1f4a:	08 95       	ret

00001f4c <Voice_Init>:

uint8 inVoice;

void Voice_Init()
{
	VOICE_BUSY_PORT |= 1<<VOICE_BUSY_BIT;
    1f4c:	aa 9a       	sbi	0x15, 2	; 21
	VOICE_BUSY_DDR  &= ~(1<<VOICE_BUSY_BIT);
    1f4e:	a2 98       	cbi	0x14, 2	; 20
	VOICE_REST_DDR |= 1<<VOICE_REST_BIT;
    1f50:	a3 9a       	sbi	0x14, 3	; 20
	VOICE_DATA_DDR |= 1<<VOICE_DATA_BIT;
    1f52:	a4 9a       	sbi	0x14, 4	; 20
}
    1f54:	08 95       	ret

00001f56 <SPEEK_Time>:

void SPEEK_Time()
{
	uint8 nowHours;
	switch(SPEEK_TIME_Status)
    1f56:	90 91 9f 02 	lds	r25, 0x029F
    1f5a:	9b 30       	cpi	r25, 0x0B	; 11
    1f5c:	09 f4       	brne	.+2      	; 0x1f60 <SPEEK_Time+0xa>
    1f5e:	32 c1       	rjmp	.+612    	; 0x21c4 <SPEEK_Time+0x26e>
    1f60:	9c 30       	cpi	r25, 0x0C	; 12
    1f62:	58 f5       	brcc	.+86     	; 0x1fba <SPEEK_Time+0x64>
    1f64:	95 30       	cpi	r25, 0x05	; 5
    1f66:	09 f4       	brne	.+2      	; 0x1f6a <SPEEK_Time+0x14>
    1f68:	aa c0       	rjmp	.+340    	; 0x20be <SPEEK_Time+0x168>
    1f6a:	96 30       	cpi	r25, 0x06	; 6
    1f6c:	98 f4       	brcc	.+38     	; 0x1f94 <SPEEK_Time+0x3e>
    1f6e:	92 30       	cpi	r25, 0x02	; 2
    1f70:	09 f4       	brne	.+2      	; 0x1f74 <SPEEK_Time+0x1e>
    1f72:	58 c0       	rjmp	.+176    	; 0x2024 <SPEEK_Time+0xce>
    1f74:	93 30       	cpi	r25, 0x03	; 3
    1f76:	38 f4       	brcc	.+14     	; 0x1f86 <SPEEK_Time+0x30>
    1f78:	99 23       	and	r25, r25
    1f7a:	09 f4       	brne	.+2      	; 0x1f7e <SPEEK_Time+0x28>
    1f7c:	49 c0       	rjmp	.+146    	; 0x2010 <SPEEK_Time+0xba>
    1f7e:	91 30       	cpi	r25, 0x01	; 1
    1f80:	09 f0       	breq	.+2      	; 0x1f84 <SPEEK_Time+0x2e>
    1f82:	e5 c1       	rjmp	.+970    	; 0x234e <SPEEK_Time+0x3f8>
    1f84:	48 c0       	rjmp	.+144    	; 0x2016 <SPEEK_Time+0xc0>
    1f86:	93 30       	cpi	r25, 0x03	; 3
    1f88:	09 f4       	brne	.+2      	; 0x1f8c <SPEEK_Time+0x36>
    1f8a:	5d c0       	rjmp	.+186    	; 0x2046 <SPEEK_Time+0xf0>
    1f8c:	94 30       	cpi	r25, 0x04	; 4
    1f8e:	09 f0       	breq	.+2      	; 0x1f92 <SPEEK_Time+0x3c>
    1f90:	de c1       	rjmp	.+956    	; 0x234e <SPEEK_Time+0x3f8>
    1f92:	82 c0       	rjmp	.+260    	; 0x2098 <SPEEK_Time+0x142>
    1f94:	98 30       	cpi	r25, 0x08	; 8
    1f96:	09 f4       	brne	.+2      	; 0x1f9a <SPEEK_Time+0x44>
    1f98:	cb c0       	rjmp	.+406    	; 0x2130 <SPEEK_Time+0x1da>
    1f9a:	99 30       	cpi	r25, 0x09	; 9
    1f9c:	38 f4       	brcc	.+14     	; 0x1fac <SPEEK_Time+0x56>
    1f9e:	96 30       	cpi	r25, 0x06	; 6
    1fa0:	09 f4       	brne	.+2      	; 0x1fa4 <SPEEK_Time+0x4e>
    1fa2:	a0 c0       	rjmp	.+320    	; 0x20e4 <SPEEK_Time+0x18e>
    1fa4:	97 30       	cpi	r25, 0x07	; 7
    1fa6:	09 f0       	breq	.+2      	; 0x1faa <SPEEK_Time+0x54>
    1fa8:	d2 c1       	rjmp	.+932    	; 0x234e <SPEEK_Time+0x3f8>
    1faa:	b3 c0       	rjmp	.+358    	; 0x2112 <SPEEK_Time+0x1bc>
    1fac:	99 30       	cpi	r25, 0x09	; 9
    1fae:	09 f4       	brne	.+2      	; 0x1fb2 <SPEEK_Time+0x5c>
    1fb0:	da c0       	rjmp	.+436    	; 0x2166 <SPEEK_Time+0x210>
    1fb2:	9a 30       	cpi	r25, 0x0A	; 10
    1fb4:	09 f0       	breq	.+2      	; 0x1fb8 <SPEEK_Time+0x62>
    1fb6:	cb c1       	rjmp	.+918    	; 0x234e <SPEEK_Time+0x3f8>
    1fb8:	f2 c0       	rjmp	.+484    	; 0x219e <SPEEK_Time+0x248>
    1fba:	91 31       	cpi	r25, 0x11	; 17
    1fbc:	09 f4       	brne	.+2      	; 0x1fc0 <SPEEK_Time+0x6a>
    1fbe:	89 c1       	rjmp	.+786    	; 0x22d2 <SPEEK_Time+0x37c>
    1fc0:	92 31       	cpi	r25, 0x12	; 18
    1fc2:	98 f4       	brcc	.+38     	; 0x1fea <SPEEK_Time+0x94>
    1fc4:	9e 30       	cpi	r25, 0x0E	; 14
    1fc6:	09 f4       	brne	.+2      	; 0x1fca <SPEEK_Time+0x74>
    1fc8:	37 c1       	rjmp	.+622    	; 0x2238 <SPEEK_Time+0x2e2>
    1fca:	9f 30       	cpi	r25, 0x0F	; 15
    1fcc:	38 f4       	brcc	.+14     	; 0x1fdc <SPEEK_Time+0x86>
    1fce:	9c 30       	cpi	r25, 0x0C	; 12
    1fd0:	09 f4       	brne	.+2      	; 0x1fd4 <SPEEK_Time+0x7e>
    1fd2:	0f c1       	rjmp	.+542    	; 0x21f2 <SPEEK_Time+0x29c>
    1fd4:	9d 30       	cpi	r25, 0x0D	; 13
    1fd6:	09 f0       	breq	.+2      	; 0x1fda <SPEEK_Time+0x84>
    1fd8:	ba c1       	rjmp	.+884    	; 0x234e <SPEEK_Time+0x3f8>
    1fda:	1a c1       	rjmp	.+564    	; 0x2210 <SPEEK_Time+0x2ba>
    1fdc:	9f 30       	cpi	r25, 0x0F	; 15
    1fde:	09 f4       	brne	.+2      	; 0x1fe2 <SPEEK_Time+0x8c>
    1fe0:	46 c1       	rjmp	.+652    	; 0x226e <SPEEK_Time+0x318>
    1fe2:	90 31       	cpi	r25, 0x10	; 16
    1fe4:	09 f0       	breq	.+2      	; 0x1fe8 <SPEEK_Time+0x92>
    1fe6:	b3 c1       	rjmp	.+870    	; 0x234e <SPEEK_Time+0x3f8>
    1fe8:	57 c1       	rjmp	.+686    	; 0x2298 <SPEEK_Time+0x342>
    1fea:	94 31       	cpi	r25, 0x14	; 20
    1fec:	09 f4       	brne	.+2      	; 0x1ff0 <SPEEK_Time+0x9a>
    1fee:	9e c1       	rjmp	.+828    	; 0x232c <SPEEK_Time+0x3d6>
    1ff0:	95 31       	cpi	r25, 0x15	; 21
    1ff2:	38 f4       	brcc	.+14     	; 0x2002 <SPEEK_Time+0xac>
    1ff4:	92 31       	cpi	r25, 0x12	; 18
    1ff6:	09 f4       	brne	.+2      	; 0x1ffa <SPEEK_Time+0xa4>
    1ff8:	7a c1       	rjmp	.+756    	; 0x22ee <SPEEK_Time+0x398>
    1ffa:	93 31       	cpi	r25, 0x13	; 19
    1ffc:	09 f0       	breq	.+2      	; 0x2000 <SPEEK_Time+0xaa>
    1ffe:	a7 c1       	rjmp	.+846    	; 0x234e <SPEEK_Time+0x3f8>
    2000:	86 c1       	rjmp	.+780    	; 0x230e <SPEEK_Time+0x3b8>
    2002:	94 36       	cpi	r25, 0x64	; 100
    2004:	09 f4       	brne	.+2      	; 0x2008 <SPEEK_Time+0xb2>
    2006:	98 c1       	rjmp	.+816    	; 0x2338 <SPEEK_Time+0x3e2>
    2008:	95 36       	cpi	r25, 0x65	; 101
    200a:	09 f0       	breq	.+2      	; 0x200e <SPEEK_Time+0xb8>
    200c:	a0 c1       	rjmp	.+832    	; 0x234e <SPEEK_Time+0x3f8>
    200e:	97 c1       	rjmp	.+814    	; 0x233e <SPEEK_Time+0x3e8>
	{
		case 0:
			inVoice = 0;
    2010:	10 92 99 02 	sts	0x0299, r1
    2014:	08 95       	ret
			TemperatureTen = 	2;
			TemperatureOne = 	0;
			TemperatureDecimal = 0;
			初始化测试代码
			*/
			PLUSE_Number=25;
    2016:	89 e1       	ldi	r24, 0x19	; 25
    2018:	80 93 87 02 	sts	0x0287, r24
			PLUSE_Status=1;
    201c:	90 93 8a 02 	sts	0x028A, r25
			SPEEK_TIME_Status = 2;
    2020:	82 e0       	ldi	r24, 0x02	; 2
    2022:	0e c0       	rjmp	.+28     	; 0x2040 <SPEEK_Time+0xea>
		break;
		case 2: //现在时刻北京时间
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2024:	80 91 8a 02 	lds	r24, 0x028A
    2028:	88 23       	and	r24, r24
    202a:	09 f0       	breq	.+2      	; 0x202e <SPEEK_Time+0xd8>
    202c:	90 c1       	rjmp	.+800    	; 0x234e <SPEEK_Time+0x3f8>
    202e:	9a 9b       	sbis	0x13, 2	; 19
    2030:	8e c1       	rjmp	.+796    	; 0x234e <SPEEK_Time+0x3f8>
			{
				PLUSE_Number=22;
    2032:	86 e1       	ldi	r24, 0x16	; 22
    2034:	80 93 87 02 	sts	0x0287, r24
				PLUSE_Status=1;
    2038:	81 e0       	ldi	r24, 0x01	; 1
    203a:	80 93 8a 02 	sts	0x028A, r24
				SPEEK_TIME_Status = 3;		
    203e:	83 e0       	ldi	r24, 0x03	; 3
    2040:	80 93 9f 02 	sts	0x029F, r24
    2044:	08 95       	ret
			}
		break;
		case 3: //上午	
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2046:	80 91 8a 02 	lds	r24, 0x028A
    204a:	88 23       	and	r24, r24
    204c:	09 f0       	breq	.+2      	; 0x2050 <SPEEK_Time+0xfa>
    204e:	7f c1       	rjmp	.+766    	; 0x234e <SPEEK_Time+0x3f8>
    2050:	9a 9b       	sbis	0x13, 2	; 19
    2052:	7d c1       	rjmp	.+762    	; 0x234e <SPEEK_Time+0x3f8>
			{
				nowHours = HourTen*10 + HourOne;
    2054:	80 91 68 00 	lds	r24, 0x0068
    2058:	2a e0       	ldi	r18, 0x0A	; 10
    205a:	82 9f       	mul	r24, r18
    205c:	c0 01       	movw	r24, r0
    205e:	11 24       	eor	r1, r1
    2060:	90 91 69 00 	lds	r25, 0x0069
    2064:	98 0f       	add	r25, r24
				if(nowHours >= 0 && nowHours < 7)
    2066:	97 30       	cpi	r25, 0x07	; 7
    2068:	a8 f0       	brcs	.+42     	; 0x2094 <SPEEK_Time+0x13e>
				{
					SPEEK_TIME_Status = 4;	
				}
				else if(nowHours >= 7 && nowHours < 13)
    206a:	89 2f       	mov	r24, r25
    206c:	87 50       	subi	r24, 0x07	; 7
    206e:	86 30       	cpi	r24, 0x06	; 6
    2070:	10 f4       	brcc	.+4      	; 0x2076 <SPEEK_Time+0x120>
				{
					PLUSE_Number= 28;
    2072:	8c e1       	ldi	r24, 0x1C	; 28
    2074:	0a c0       	rjmp	.+20     	; 0x208a <SPEEK_Time+0x134>
					PLUSE_Status=1;
					SPEEK_TIME_Status = 4;	
				}
				else if(nowHours >= 13 && nowHours < 19)
    2076:	89 2f       	mov	r24, r25
    2078:	8d 50       	subi	r24, 0x0D	; 13
    207a:	86 30       	cpi	r24, 0x06	; 6
    207c:	10 f4       	brcc	.+4      	; 0x2082 <SPEEK_Time+0x12c>
				{
					PLUSE_Number= 29;
    207e:	8d e1       	ldi	r24, 0x1D	; 29
    2080:	04 c0       	rjmp	.+8      	; 0x208a <SPEEK_Time+0x134>
					PLUSE_Status=1;
					SPEEK_TIME_Status = 4;	
				}
				else if(nowHours >= 19 && nowHours < 24)
    2082:	93 51       	subi	r25, 0x13	; 19
    2084:	95 30       	cpi	r25, 0x05	; 5
    2086:	30 f4       	brcc	.+12     	; 0x2094 <SPEEK_Time+0x13e>
				{
					PLUSE_Number= 30;
    2088:	8e e1       	ldi	r24, 0x1E	; 30
    208a:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    208e:	81 e0       	ldi	r24, 0x01	; 1
    2090:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 4;	
				}		
				else
				{
					SPEEK_TIME_Status = 4;
    2094:	84 e0       	ldi	r24, 0x04	; 4
    2096:	d4 cf       	rjmp	.-88     	; 0x2040 <SPEEK_Time+0xea>
				}
			}	
		break;
		case 4: //二	
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2098:	80 91 8a 02 	lds	r24, 0x028A
    209c:	88 23       	and	r24, r24
    209e:	09 f0       	breq	.+2      	; 0x20a2 <SPEEK_Time+0x14c>
    20a0:	56 c1       	rjmp	.+684    	; 0x234e <SPEEK_Time+0x3f8>
    20a2:	9a 9b       	sbis	0x13, 2	; 19
    20a4:	54 c1       	rjmp	.+680    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(HourTen > 1)
    20a6:	80 91 68 00 	lds	r24, 0x0068
    20aa:	82 30       	cpi	r24, 0x02	; 2
    20ac:	30 f0       	brcs	.+12     	; 0x20ba <SPEEK_Time+0x164>
				{
					PLUSE_Number= HourTen+1;
    20ae:	8f 5f       	subi	r24, 0xFF	; 255
    20b0:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    20b4:	81 e0       	ldi	r24, 0x01	; 1
    20b6:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 5;	
				}	
				else
				{
					SPEEK_TIME_Status = 5;
    20ba:	85 e0       	ldi	r24, 0x05	; 5
    20bc:	c1 cf       	rjmp	.-126    	; 0x2040 <SPEEK_Time+0xea>
				}
			}	
		break;
		case 5: //十
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    20be:	80 91 8a 02 	lds	r24, 0x028A
    20c2:	88 23       	and	r24, r24
    20c4:	09 f0       	breq	.+2      	; 0x20c8 <SPEEK_Time+0x172>
    20c6:	43 c1       	rjmp	.+646    	; 0x234e <SPEEK_Time+0x3f8>
    20c8:	9a 9b       	sbis	0x13, 2	; 19
    20ca:	41 c1       	rjmp	.+642    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(HourTen != 0)
    20cc:	80 91 68 00 	lds	r24, 0x0068
    20d0:	88 23       	and	r24, r24
    20d2:	31 f0       	breq	.+12     	; 0x20e0 <SPEEK_Time+0x18a>
				{

					PLUSE_Number=11;
    20d4:	8b e0       	ldi	r24, 0x0B	; 11
    20d6:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    20da:	81 e0       	ldi	r24, 0x01	; 1
    20dc:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 6;	
				}
				else
				{
					SPEEK_TIME_Status = 6;
    20e0:	86 e0       	ldi	r24, 0x06	; 6
    20e2:	ae cf       	rjmp	.-164    	; 0x2040 <SPEEK_Time+0xea>
				}
			}
		break;
		case 6: //一
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    20e4:	80 91 8a 02 	lds	r24, 0x028A
    20e8:	88 23       	and	r24, r24
    20ea:	09 f0       	breq	.+2      	; 0x20ee <SPEEK_Time+0x198>
    20ec:	30 c1       	rjmp	.+608    	; 0x234e <SPEEK_Time+0x3f8>
    20ee:	9a 9b       	sbis	0x13, 2	; 19
    20f0:	2e c1       	rjmp	.+604    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(HourOne == 0 && HourTen != 0)
    20f2:	90 91 69 00 	lds	r25, 0x0069
    20f6:	99 23       	and	r25, r25
    20f8:	21 f4       	brne	.+8      	; 0x2102 <SPEEK_Time+0x1ac>
    20fa:	80 91 68 00 	lds	r24, 0x0068
    20fe:	88 23       	and	r24, r24
    2100:	31 f4       	brne	.+12     	; 0x210e <SPEEK_Time+0x1b8>
					SPEEK_TIME_Status = 7;
							
				}
				else
				{
					PLUSE_Number=HourOne+1;
    2102:	9f 5f       	subi	r25, 0xFF	; 255
    2104:	90 93 87 02 	sts	0x0287, r25
					PLUSE_Status=1;
    2108:	81 e0       	ldi	r24, 0x01	; 1
    210a:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 7;
    210e:	87 e0       	ldi	r24, 0x07	; 7
    2110:	97 cf       	rjmp	.-210    	; 0x2040 <SPEEK_Time+0xea>
				}
			}
		break;
		case 7: //点
			 if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2112:	80 91 8a 02 	lds	r24, 0x028A
    2116:	88 23       	and	r24, r24
    2118:	09 f0       	breq	.+2      	; 0x211c <SPEEK_Time+0x1c6>
    211a:	19 c1       	rjmp	.+562    	; 0x234e <SPEEK_Time+0x3f8>
    211c:	9a 9b       	sbis	0x13, 2	; 19
    211e:	17 c1       	rjmp	.+558    	; 0x234e <SPEEK_Time+0x3f8>
			{
				PLUSE_Number=13;
    2120:	8d e0       	ldi	r24, 0x0D	; 13
    2122:	80 93 87 02 	sts	0x0287, r24
				PLUSE_Status=1;
    2126:	81 e0       	ldi	r24, 0x01	; 1
    2128:	80 93 8a 02 	sts	0x028A, r24
				SPEEK_TIME_Status =8;		
    212c:	88 e0       	ldi	r24, 0x08	; 8
    212e:	88 cf       	rjmp	.-240    	; 0x2040 <SPEEK_Time+0xea>
			}
		break;
		case 8: //五
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2130:	80 91 8a 02 	lds	r24, 0x028A
    2134:	88 23       	and	r24, r24
    2136:	09 f0       	breq	.+2      	; 0x213a <SPEEK_Time+0x1e4>
    2138:	0a c1       	rjmp	.+532    	; 0x234e <SPEEK_Time+0x3f8>
    213a:	9a 9b       	sbis	0x13, 2	; 19
    213c:	08 c1       	rjmp	.+528    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(MinuteTen == 0 && MinuteOne == 0)
    213e:	80 91 6a 00 	lds	r24, 0x006A
    2142:	88 23       	and	r24, r24
    2144:	31 f4       	brne	.+12     	; 0x2152 <SPEEK_Time+0x1fc>
    2146:	80 91 6b 00 	lds	r24, 0x006B
    214a:	88 23       	and	r24, r24
    214c:	51 f4       	brne	.+20     	; 0x2162 <SPEEK_Time+0x20c>
				{
					PLUSE_Number= 26;
    214e:	8a e1       	ldi	r24, 0x1A	; 26
    2150:	03 c0       	rjmp	.+6      	; 0x2158 <SPEEK_Time+0x202>
					PLUSE_Status=1;
					SPEEK_TIME_Status =9;
				}
				else if(MinuteTen > 1)
    2152:	82 30       	cpi	r24, 0x02	; 2
    2154:	30 f0       	brcs	.+12     	; 0x2162 <SPEEK_Time+0x20c>
				{
					PLUSE_Number=MinuteTen+1;
    2156:	8f 5f       	subi	r24, 0xFF	; 255
    2158:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    215c:	81 e0       	ldi	r24, 0x01	; 1
    215e:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status =9;	
				}
				else
				{
					SPEEK_TIME_Status =9;
    2162:	89 e0       	ldi	r24, 0x09	; 9
    2164:	6d cf       	rjmp	.-294    	; 0x2040 <SPEEK_Time+0xea>
				}
			}
		break;
		case 9: //十
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2166:	80 91 8a 02 	lds	r24, 0x028A
    216a:	88 23       	and	r24, r24
    216c:	09 f0       	breq	.+2      	; 0x2170 <SPEEK_Time+0x21a>
    216e:	ef c0       	rjmp	.+478    	; 0x234e <SPEEK_Time+0x3f8>
    2170:	9a 9b       	sbis	0x13, 2	; 19
    2172:	ed c0       	rjmp	.+474    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(MinuteTen == 0 && MinuteOne == 0)
    2174:	80 91 6a 00 	lds	r24, 0x006A
    2178:	88 23       	and	r24, r24
    217a:	29 f4       	brne	.+10     	; 0x2186 <SPEEK_Time+0x230>
    217c:	80 91 6b 00 	lds	r24, 0x006B
    2180:	88 23       	and	r24, r24
    2182:	31 f4       	brne	.+12     	; 0x2190 <SPEEK_Time+0x23a>
    2184:	0a c0       	rjmp	.+20     	; 0x219a <SPEEK_Time+0x244>
				{
					SPEEK_TIME_Status =10;
				}
				else if(MinuteTen != 0)
				{
					PLUSE_Number=11;
    2186:	8b e0       	ldi	r24, 0x0B	; 11
    2188:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    218c:	81 e0       	ldi	r24, 0x01	; 1
    218e:	03 c0       	rjmp	.+6      	; 0x2196 <SPEEK_Time+0x240>
					SPEEK_TIME_Status =10;
				}
				else
				{
					PLUSE_Number=1;
    2190:	81 e0       	ldi	r24, 0x01	; 1
    2192:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    2196:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status =10;
    219a:	8a e0       	ldi	r24, 0x0A	; 10
    219c:	51 cf       	rjmp	.-350    	; 0x2040 <SPEEK_Time+0xea>
				}		
			}
		break;
		case 10: //三
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    219e:	80 91 8a 02 	lds	r24, 0x028A
    21a2:	88 23       	and	r24, r24
    21a4:	09 f0       	breq	.+2      	; 0x21a8 <SPEEK_Time+0x252>
    21a6:	d3 c0       	rjmp	.+422    	; 0x234e <SPEEK_Time+0x3f8>
    21a8:	9a 9b       	sbis	0x13, 2	; 19
    21aa:	d1 c0       	rjmp	.+418    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(MinuteOne == 0 && MinuteTen == 0)
    21ac:	80 91 6b 00 	lds	r24, 0x006B
    21b0:	88 23       	and	r24, r24
    21b2:	31 f0       	breq	.+12     	; 0x21c0 <SPEEK_Time+0x26a>
				{
					SPEEK_TIME_Status =11;	
				}
				else
				{
					PLUSE_Number=MinuteOne+1;
    21b4:	8f 5f       	subi	r24, 0xFF	; 255
    21b6:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    21ba:	81 e0       	ldi	r24, 0x01	; 1
    21bc:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status =11;	
    21c0:	8b e0       	ldi	r24, 0x0B	; 11
    21c2:	3e cf       	rjmp	.-388    	; 0x2040 <SPEEK_Time+0xea>
				}
			}
		break;
		case 11: //分
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    21c4:	80 91 8a 02 	lds	r24, 0x028A
    21c8:	88 23       	and	r24, r24
    21ca:	09 f0       	breq	.+2      	; 0x21ce <SPEEK_Time+0x278>
    21cc:	c0 c0       	rjmp	.+384    	; 0x234e <SPEEK_Time+0x3f8>
    21ce:	9a 9b       	sbis	0x13, 2	; 19
    21d0:	be c0       	rjmp	.+380    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(MinuteTen == 0 && MinuteOne == 0)
    21d2:	80 91 6a 00 	lds	r24, 0x006A
    21d6:	88 23       	and	r24, r24
    21d8:	21 f4       	brne	.+8      	; 0x21e2 <SPEEK_Time+0x28c>
    21da:	80 91 6b 00 	lds	r24, 0x006B
    21de:	88 23       	and	r24, r24
    21e0:	31 f0       	breq	.+12     	; 0x21ee <SPEEK_Time+0x298>
				{
					SPEEK_TIME_Status =12;
				}
				else
				{
					PLUSE_Number=14;
    21e2:	8e e0       	ldi	r24, 0x0E	; 14
    21e4:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    21e8:	81 e0       	ldi	r24, 0x01	; 1
    21ea:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 12;	
    21ee:	8c e0       	ldi	r24, 0x0C	; 12
    21f0:	27 cf       	rjmp	.-434    	; 0x2040 <SPEEK_Time+0xea>
				}	
			}
		break;
		case 12: //等待
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    21f2:	80 91 8a 02 	lds	r24, 0x028A
    21f6:	88 23       	and	r24, r24
    21f8:	09 f0       	breq	.+2      	; 0x21fc <SPEEK_Time+0x2a6>
    21fa:	a9 c0       	rjmp	.+338    	; 0x234e <SPEEK_Time+0x3f8>
    21fc:	9a 9b       	sbis	0x13, 2	; 19
    21fe:	a7 c0       	rjmp	.+334    	; 0x234e <SPEEK_Time+0x3f8>
			{
				SPEEK_TIME_Delay = 1000;
    2200:	88 ee       	ldi	r24, 0xE8	; 232
    2202:	93 e0       	ldi	r25, 0x03	; 3
    2204:	90 93 97 02 	sts	0x0297, r25
    2208:	80 93 96 02 	sts	0x0296, r24
				SPEEK_TIME_Status = 13;		
    220c:	8d e0       	ldi	r24, 0x0D	; 13
    220e:	18 cf       	rjmp	.-464    	; 0x2040 <SPEEK_Time+0xea>
			}
		break;
		case 13: //现在温度是
			SPEEK_TIME_Delay --;
    2210:	80 91 96 02 	lds	r24, 0x0296
    2214:	90 91 97 02 	lds	r25, 0x0297
    2218:	01 97       	sbiw	r24, 0x01	; 1
    221a:	90 93 97 02 	sts	0x0297, r25
    221e:	80 93 96 02 	sts	0x0296, r24
			if(SPEEK_TIME_Delay == 0)
    2222:	89 2b       	or	r24, r25
    2224:	09 f0       	breq	.+2      	; 0x2228 <SPEEK_Time+0x2d2>
    2226:	93 c0       	rjmp	.+294    	; 0x234e <SPEEK_Time+0x3f8>
			{
				PLUSE_Number=23;
    2228:	87 e1       	ldi	r24, 0x17	; 23
    222a:	80 93 87 02 	sts	0x0287, r24
				PLUSE_Status=1;
    222e:	81 e0       	ldi	r24, 0x01	; 1
    2230:	80 93 8a 02 	sts	0x028A, r24
				SPEEK_TIME_Status = 14;		
    2234:	8e e0       	ldi	r24, 0x0E	; 14
    2236:	04 cf       	rjmp	.-504    	; 0x2040 <SPEEK_Time+0xea>
			}
		break;
		case 14: //二
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2238:	80 91 8a 02 	lds	r24, 0x028A
    223c:	88 23       	and	r24, r24
    223e:	09 f0       	breq	.+2      	; 0x2242 <SPEEK_Time+0x2ec>
    2240:	86 c0       	rjmp	.+268    	; 0x234e <SPEEK_Time+0x3f8>
    2242:	9a 9b       	sbis	0x13, 2	; 19
    2244:	84 c0       	rjmp	.+264    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(TemperatureTen > 1 && TemperatureTen < 10)
    2246:	90 91 6f 00 	lds	r25, 0x006F
    224a:	89 2f       	mov	r24, r25
    224c:	82 50       	subi	r24, 0x02	; 2
    224e:	88 30       	cpi	r24, 0x08	; 8
    2250:	20 f4       	brcc	.+8      	; 0x225a <SPEEK_Time+0x304>
				{
					PLUSE_Number=TemperatureTen+1;
    2252:	9f 5f       	subi	r25, 0xFF	; 255
    2254:	90 93 87 02 	sts	0x0287, r25
    2258:	05 c0       	rjmp	.+10     	; 0x2264 <SPEEK_Time+0x30e>
					PLUSE_Status=1;
					SPEEK_TIME_Status = 15;	
				}
				else if(TemperatureTen > 10)
    225a:	9b 30       	cpi	r25, 0x0B	; 11
    225c:	30 f0       	brcs	.+12     	; 0x226a <SPEEK_Time+0x314>
				{
					PLUSE_Number=31;
    225e:	8f e1       	ldi	r24, 0x1F	; 31
    2260:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    2264:	81 e0       	ldi	r24, 0x01	; 1
    2266:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 15;
    226a:	8f e0       	ldi	r24, 0x0F	; 15
    226c:	e9 ce       	rjmp	.-558    	; 0x2040 <SPEEK_Time+0xea>
					SPEEK_TIME_Status = 15;
				}
			}
		break;
		case 15: //十
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    226e:	80 91 8a 02 	lds	r24, 0x028A
    2272:	88 23       	and	r24, r24
    2274:	09 f0       	breq	.+2      	; 0x2278 <SPEEK_Time+0x322>
    2276:	6b c0       	rjmp	.+214    	; 0x234e <SPEEK_Time+0x3f8>
    2278:	9a 9b       	sbis	0x13, 2	; 19
    227a:	69 c0       	rjmp	.+210    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(TemperatureTen != 0 && TemperatureTen != 14)
    227c:	80 91 6f 00 	lds	r24, 0x006F
    2280:	88 23       	and	r24, r24
    2282:	41 f0       	breq	.+16     	; 0x2294 <SPEEK_Time+0x33e>
    2284:	8e 30       	cpi	r24, 0x0E	; 14
    2286:	31 f0       	breq	.+12     	; 0x2294 <SPEEK_Time+0x33e>
				{
					PLUSE_Number=11;
    2288:	8b e0       	ldi	r24, 0x0B	; 11
    228a:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    228e:	81 e0       	ldi	r24, 0x01	; 1
    2290:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 16;
				}
				else
				{
					SPEEK_TIME_Status = 16;
    2294:	80 e1       	ldi	r24, 0x10	; 16
    2296:	d4 ce       	rjmp	.-600    	; 0x2040 <SPEEK_Time+0xea>
				}
			}
		break;
		case 16: //一
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    2298:	80 91 8a 02 	lds	r24, 0x028A
    229c:	88 23       	and	r24, r24
    229e:	09 f0       	breq	.+2      	; 0x22a2 <SPEEK_Time+0x34c>
    22a0:	56 c0       	rjmp	.+172    	; 0x234e <SPEEK_Time+0x3f8>
    22a2:	9a 9b       	sbis	0x13, 2	; 19
    22a4:	54 c0       	rjmp	.+168    	; 0x234e <SPEEK_Time+0x3f8>
			{
				if(TemperatureOne != 0)
    22a6:	80 91 70 00 	lds	r24, 0x0070
    22aa:	88 23       	and	r24, r24
    22ac:	29 f0       	breq	.+10     	; 0x22b8 <SPEEK_Time+0x362>
				{
					PLUSE_Number=TemperatureOne+1;
    22ae:	8f 5f       	subi	r24, 0xFF	; 255
    22b0:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    22b4:	81 e0       	ldi	r24, 0x01	; 1
    22b6:	09 c0       	rjmp	.+18     	; 0x22ca <SPEEK_Time+0x374>
					SPEEK_TIME_Status = 17;	
				}
				else if(TemperatureOne ==0 && (TemperatureTen == 0 || TemperatureTen == 14))
    22b8:	80 91 6f 00 	lds	r24, 0x006F
    22bc:	88 23       	and	r24, r24
    22be:	11 f0       	breq	.+4      	; 0x22c4 <SPEEK_Time+0x36e>
    22c0:	8e 30       	cpi	r24, 0x0E	; 14
    22c2:	29 f4       	brne	.+10     	; 0x22ce <SPEEK_Time+0x378>
				{
					PLUSE_Number=TemperatureOne+1;
    22c4:	81 e0       	ldi	r24, 0x01	; 1
    22c6:	80 93 87 02 	sts	0x0287, r24
					PLUSE_Status=1;
    22ca:	80 93 8a 02 	sts	0x028A, r24
					SPEEK_TIME_Status = 17;
				}
				else
				{
					SPEEK_TIME_Status = 17;	
    22ce:	81 e1       	ldi	r24, 0x11	; 17
    22d0:	b7 ce       	rjmp	.-658    	; 0x2040 <SPEEK_Time+0xea>
				}
			}
		break;
		case 17: //点
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    22d2:	80 91 8a 02 	lds	r24, 0x028A
    22d6:	88 23       	and	r24, r24
    22d8:	d1 f5       	brne	.+116    	; 0x234e <SPEEK_Time+0x3f8>
    22da:	9a 9b       	sbis	0x13, 2	; 19
    22dc:	38 c0       	rjmp	.+112    	; 0x234e <SPEEK_Time+0x3f8>
			{
				PLUSE_Number=13;
    22de:	8d e0       	ldi	r24, 0x0D	; 13
    22e0:	80 93 87 02 	sts	0x0287, r24
				PLUSE_Status=1;
    22e4:	81 e0       	ldi	r24, 0x01	; 1
    22e6:	80 93 8a 02 	sts	0x028A, r24
				SPEEK_TIME_Status = 18;		
    22ea:	82 e1       	ldi	r24, 0x12	; 18
    22ec:	a9 ce       	rjmp	.-686    	; 0x2040 <SPEEK_Time+0xea>
			}
		break;
		case 18: //五
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    22ee:	80 91 8a 02 	lds	r24, 0x028A
    22f2:	88 23       	and	r24, r24
    22f4:	61 f5       	brne	.+88     	; 0x234e <SPEEK_Time+0x3f8>
    22f6:	9a 9b       	sbis	0x13, 2	; 19
    22f8:	2a c0       	rjmp	.+84     	; 0x234e <SPEEK_Time+0x3f8>
			{
				PLUSE_Number=TemperatureDecimal+1;
    22fa:	80 91 71 00 	lds	r24, 0x0071
    22fe:	8f 5f       	subi	r24, 0xFF	; 255
    2300:	80 93 87 02 	sts	0x0287, r24
				PLUSE_Status=1;
    2304:	81 e0       	ldi	r24, 0x01	; 1
    2306:	80 93 8a 02 	sts	0x028A, r24
				SPEEK_TIME_Status =19;		
    230a:	83 e1       	ldi	r24, 0x13	; 19
    230c:	99 ce       	rjmp	.-718    	; 0x2040 <SPEEK_Time+0xea>
			}
		break;
		case 19: //度
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    230e:	80 91 8a 02 	lds	r24, 0x028A
    2312:	88 23       	and	r24, r24
    2314:	e1 f4       	brne	.+56     	; 0x234e <SPEEK_Time+0x3f8>
    2316:	9a 9b       	sbis	0x13, 2	; 19
    2318:	1a c0       	rjmp	.+52     	; 0x234e <SPEEK_Time+0x3f8>
			{
				PLUSE_Number=20;
    231a:	94 e1       	ldi	r25, 0x14	; 20
    231c:	90 93 87 02 	sts	0x0287, r25
				PLUSE_Status=1;
    2320:	81 e0       	ldi	r24, 0x01	; 1
    2322:	80 93 8a 02 	sts	0x028A, r24
				SPEEK_TIME_Status = 20;		
    2326:	90 93 9f 02 	sts	0x029F, r25
    232a:	08 95       	ret
			}
		break;
		case 20:
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    232c:	80 91 8a 02 	lds	r24, 0x028A
    2330:	88 23       	and	r24, r24
    2332:	69 f4       	brne	.+26     	; 0x234e <SPEEK_Time+0x3f8>
    2334:	9a 9b       	sbis	0x13, 2	; 19
    2336:	0b c0       	rjmp	.+22     	; 0x234e <SPEEK_Time+0x3f8>
			{
				SPEEK_TIME_Status = 0;		
			}		
		break;	
		case 100: //按键音
			SPEEK_TIME_Status = 0;
    2338:	10 92 9f 02 	sts	0x029F, r1
    233c:	08 95       	ret
			PLUSE_Status = 1;
			SPEEK_TIME_Status = 101;
			*/
		break;
		case 101:
			if(PLUSE_Status == 0 && VOICE_BUSY_H)
    233e:	80 91 8a 02 	lds	r24, 0x028A
    2342:	88 23       	and	r24, r24
    2344:	21 f4       	brne	.+8      	; 0x234e <SPEEK_Time+0x3f8>
    2346:	9a 9b       	sbis	0x13, 2	; 19
    2348:	02 c0       	rjmp	.+4      	; 0x234e <SPEEK_Time+0x3f8>
			{
				SPEEK_TIME_Status = 0;		
    234a:	10 92 9f 02 	sts	0x029F, r1
    234e:	08 95       	ret

00002350 <PLUSE_Out>:
	}
}

void PLUSE_Out()
{
	switch(PLUSE_Status)
    2350:	80 91 8a 02 	lds	r24, 0x028A
    2354:	82 30       	cpi	r24, 0x02	; 2
    2356:	11 f1       	breq	.+68     	; 0x239c <PLUSE_Out+0x4c>
    2358:	83 30       	cpi	r24, 0x03	; 3
    235a:	30 f4       	brcc	.+12     	; 0x2368 <PLUSE_Out+0x18>
    235c:	88 23       	and	r24, r24
    235e:	61 f0       	breq	.+24     	; 0x2378 <PLUSE_Out+0x28>
    2360:	81 30       	cpi	r24, 0x01	; 1
    2362:	09 f0       	breq	.+2      	; 0x2366 <PLUSE_Out+0x16>
    2364:	49 c0       	rjmp	.+146    	; 0x23f8 <PLUSE_Out+0xa8>
    2366:	0e c0       	rjmp	.+28     	; 0x2384 <PLUSE_Out+0x34>
    2368:	84 30       	cpi	r24, 0x04	; 4
    236a:	89 f1       	breq	.+98     	; 0x23ce <PLUSE_Out+0x7e>
    236c:	84 30       	cpi	r24, 0x04	; 4
    236e:	10 f1       	brcs	.+68     	; 0x23b4 <PLUSE_Out+0x64>
    2370:	85 30       	cpi	r24, 0x05	; 5
    2372:	09 f0       	breq	.+2      	; 0x2376 <PLUSE_Out+0x26>
    2374:	41 c0       	rjmp	.+130    	; 0x23f8 <PLUSE_Out+0xa8>
    2376:	37 c0       	rjmp	.+110    	; 0x23e6 <PLUSE_Out+0x96>
	{
		case 0:
			PLUSE_Delay = 2;
    2378:	82 e0       	ldi	r24, 0x02	; 2
    237a:	80 93 9c 02 	sts	0x029C, r24
			VOICE_DATA_L;
    237e:	ac 98       	cbi	0x15, 4	; 21
			VOICE_REST_L;	
    2380:	ab 98       	cbi	0x15, 3	; 21
    2382:	08 95       	ret
		break;
		case 1:
			VOICE_DATA_L;
    2384:	ac 98       	cbi	0x15, 4	; 21
			VOICE_REST_H;
    2386:	ab 9a       	sbi	0x15, 3	; 21
			PLUSE_Delay--;
    2388:	80 91 9c 02 	lds	r24, 0x029C
    238c:	81 50       	subi	r24, 0x01	; 1
    238e:	80 93 9c 02 	sts	0x029C, r24
			if(PLUSE_Delay==0)
    2392:	88 23       	and	r24, r24
    2394:	89 f5       	brne	.+98     	; 0x23f8 <PLUSE_Out+0xa8>
			{
				VOICE_REST_L;
    2396:	ab 98       	cbi	0x15, 3	; 21
				PLUSE_Status=2;
    2398:	82 e0       	ldi	r24, 0x02	; 2
    239a:	22 c0       	rjmp	.+68     	; 0x23e0 <PLUSE_Out+0x90>
			}
		break;
		case 2:
			if(PLUSE_Number>0)
    239c:	80 91 87 02 	lds	r24, 0x0287
    23a0:	88 23       	and	r24, r24
    23a2:	29 f0       	breq	.+10     	; 0x23ae <PLUSE_Out+0x5e>
			{
			  	PLUSE_Delay = 1;
    23a4:	81 e0       	ldi	r24, 0x01	; 1
    23a6:	80 93 9c 02 	sts	0x029C, r24
				PLUSE_Status = 3;
    23aa:	83 e0       	ldi	r24, 0x03	; 3
    23ac:	19 c0       	rjmp	.+50     	; 0x23e0 <PLUSE_Out+0x90>
			}
			else
			{
				PLUSE_Status = 0;
    23ae:	10 92 8a 02 	sts	0x028A, r1
    23b2:	08 95       	ret
			}	
		break;
		case 3:
			VOICE_DATA_L;
    23b4:	ac 98       	cbi	0x15, 4	; 21
			PLUSE_Delay--;
    23b6:	80 91 9c 02 	lds	r24, 0x029C
    23ba:	81 50       	subi	r24, 0x01	; 1
    23bc:	80 93 9c 02 	sts	0x029C, r24
			if(PLUSE_Delay==0)
    23c0:	88 23       	and	r24, r24
    23c2:	d1 f4       	brne	.+52     	; 0x23f8 <PLUSE_Out+0xa8>
			{
				PLUSE_Delay = 1;
    23c4:	81 e0       	ldi	r24, 0x01	; 1
    23c6:	80 93 9c 02 	sts	0x029C, r24
				PLUSE_Status=4;
    23ca:	84 e0       	ldi	r24, 0x04	; 4
    23cc:	09 c0       	rjmp	.+18     	; 0x23e0 <PLUSE_Out+0x90>
			}
		break;
		case 4:
			VOICE_DATA_H;
    23ce:	ac 9a       	sbi	0x15, 4	; 21
			PLUSE_Delay--;
    23d0:	80 91 9c 02 	lds	r24, 0x029C
    23d4:	81 50       	subi	r24, 0x01	; 1
    23d6:	80 93 9c 02 	sts	0x029C, r24
			if(PLUSE_Delay==0)
    23da:	88 23       	and	r24, r24
    23dc:	69 f4       	brne	.+26     	; 0x23f8 <PLUSE_Out+0xa8>
			{
				PLUSE_Status=5;
    23de:	85 e0       	ldi	r24, 0x05	; 5
    23e0:	80 93 8a 02 	sts	0x028A, r24
    23e4:	08 95       	ret
			}
		break;
		case 5:
			VOICE_DATA_L;
    23e6:	ac 98       	cbi	0x15, 4	; 21
			PLUSE_Number--;
    23e8:	80 91 87 02 	lds	r24, 0x0287
    23ec:	81 50       	subi	r24, 0x01	; 1
    23ee:	80 93 87 02 	sts	0x0287, r24
			PLUSE_Status = 2;
    23f2:	82 e0       	ldi	r24, 0x02	; 2
    23f4:	80 93 8a 02 	sts	0x028A, r24
    23f8:	08 95       	ret

000023fa <Key_Init>:
uint16 KEY_Time_count;
uint16 KEY_Time_count_speed_color;

void Key_Init()
{
	KEY_UP_PORT |= 1<<KEY_UP_BIT;
    23fa:	ae 9a       	sbi	0x15, 6	; 21
	KEY_UP_DDR  &= ~(1<<KEY_UP_BIT);
    23fc:	a6 98       	cbi	0x14, 6	; 20
	KEY_DOWN_PORT |= 1<<KEY_DOWN_BIT;
    23fe:	af 9a       	sbi	0x15, 7	; 21
	KEY_DOWN_DDR  &= ~(1<<KEY_DOWN_BIT);
    2400:	a7 98       	cbi	0x14, 7	; 20
	KEY_MODE_PORT |= 1<<KEY_MODE_BIT;
    2402:	90 9a       	sbi	0x12, 0	; 18
	KEY_MODE_DDR  &= ~(1<<KEY_MODE_BIT);
    2404:	88 98       	cbi	0x11, 0	; 17
	KEY_DISPLAY_COLOR_PORT |= 1<<KEY_DISPLAY_COLOR_BIT;
    2406:	91 9a       	sbi	0x12, 1	; 18
	KEY_DISPLAY_COLOR_DDR  &= ~(1<<KEY_DISPLAY_COLOR_BIT);
    2408:	89 98       	cbi	0x11, 1	; 17
}
    240a:	08 95       	ret

0000240c <Key_Operation>:

void Key_Operation(uint8 maxNum, uint8 minNum, uint8 *tenValue, uint8 *oneValue, void (*FunP)())
{
    240c:	cf 92       	push	r12
    240e:	df 92       	push	r13
    2410:	ef 92       	push	r14
    2412:	ff 92       	push	r15
    2414:	0f 93       	push	r16
    2416:	1f 93       	push	r17
    2418:	cf 93       	push	r28
    241a:	df 93       	push	r29
    241c:	d8 2e       	mov	r13, r24
    241e:	c6 2e       	mov	r12, r22
    2420:	ea 01       	movw	r28, r20
    2422:	79 01       	movw	r14, r18
	if(KEY_UP_L) 
    2424:	9e 99       	sbic	0x13, 6	; 19
    2426:	27 c0       	rjmp	.+78     	; 0x2476 <Key_Operation+0x6a>
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2428:	80 e2       	ldi	r24, 0x20	; 32
    242a:	9e e4       	ldi	r25, 0x4E	; 78
    242c:	01 97       	sbiw	r24, 0x01	; 1
    242e:	f1 f7       	brne	.-4      	; 0x242c <Key_Operation+0x20>
	{
		_delay_ms(10);
		if(KEY_UP_L)
    2430:	9e 99       	sbic	0x13, 6	; 19
    2432:	1f c0       	rjmp	.+62     	; 0x2472 <Key_Operation+0x66>
		{
			SPEEK_TIME_Status = 100; //按键音
    2434:	84 e6       	ldi	r24, 0x64	; 100
    2436:	80 93 9f 02 	sts	0x029F, r24
			KEY_Time_count = 0;
    243a:	10 92 8c 02 	sts	0x028C, r1
    243e:	10 92 8b 02 	sts	0x028B, r1
			uint8 value = *tenValue*10 + *oneValue;
    2442:	f9 01       	movw	r30, r18
    2444:	30 81       	ld	r19, Z
    2446:	3f 5f       	subi	r19, 0xFF	; 255
			value ++;
    2448:	88 81       	ld	r24, Y
    244a:	2a e0       	ldi	r18, 0x0A	; 10
    244c:	82 9f       	mul	r24, r18
    244e:	c0 01       	movw	r24, r0
    2450:	11 24       	eor	r1, r1
    2452:	38 0f       	add	r19, r24
			if(value > maxNum)
    2454:	d3 16       	cp	r13, r19
    2456:	08 f4       	brcc	.+2      	; 0x245a <Key_Operation+0x4e>
    2458:	36 2f       	mov	r19, r22
			{
				value = minNum;
			}
			*tenValue = value/10;
    245a:	83 2f       	mov	r24, r19
    245c:	6a e0       	ldi	r22, 0x0A	; 10
    245e:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    2462:	88 83       	st	Y, r24
			*oneValue = value%10;
    2464:	83 2f       	mov	r24, r19
    2466:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    246a:	f7 01       	movw	r30, r14
    246c:	90 83       	st	Z, r25
			(*FunP)();
    246e:	f8 01       	movw	r30, r16
    2470:	09 95       	icall
		}
		while(KEY_UP_L);	
    2472:	9e 9b       	sbis	0x13, 6	; 19
    2474:	fe cf       	rjmp	.-4      	; 0x2472 <Key_Operation+0x66>
	}
	if(KEY_DOWN_L) 
    2476:	9f 99       	sbic	0x13, 7	; 19
    2478:	29 c0       	rjmp	.+82     	; 0x24cc <Key_Operation+0xc0>
    247a:	80 e2       	ldi	r24, 0x20	; 32
    247c:	9e e4       	ldi	r25, 0x4E	; 78
    247e:	01 97       	sbiw	r24, 0x01	; 1
    2480:	f1 f7       	brne	.-4      	; 0x247e <Key_Operation+0x72>
	{
		_delay_ms(10);
		if(KEY_DOWN_L)
    2482:	9f 99       	sbic	0x13, 7	; 19
    2484:	21 c0       	rjmp	.+66     	; 0x24c8 <Key_Operation+0xbc>
		{
			SPEEK_TIME_Status = 100; //按键音
    2486:	84 e6       	ldi	r24, 0x64	; 100
    2488:	80 93 9f 02 	sts	0x029F, r24
			KEY_Time_count = 0;
    248c:	10 92 8c 02 	sts	0x028C, r1
    2490:	10 92 8b 02 	sts	0x028B, r1
			uint8 value = *tenValue*10 + *oneValue;
    2494:	f7 01       	movw	r30, r14
    2496:	30 81       	ld	r19, Z
    2498:	31 50       	subi	r19, 0x01	; 1
			value --;
    249a:	88 81       	ld	r24, Y
    249c:	2a e0       	ldi	r18, 0x0A	; 10
    249e:	82 9f       	mul	r24, r18
    24a0:	c0 01       	movw	r24, r0
    24a2:	11 24       	eor	r1, r1
    24a4:	38 0f       	add	r19, r24
			if((value > maxNum) | (value < minNum))
    24a6:	d3 16       	cp	r13, r19
    24a8:	10 f0       	brcs	.+4      	; 0x24ae <Key_Operation+0xa2>
    24aa:	3c 15       	cp	r19, r12
    24ac:	08 f4       	brcc	.+2      	; 0x24b0 <Key_Operation+0xa4>
    24ae:	3d 2d       	mov	r19, r13
			{
				value = maxNum;
			}
			*tenValue = value/10;
    24b0:	83 2f       	mov	r24, r19
    24b2:	6a e0       	ldi	r22, 0x0A	; 10
    24b4:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    24b8:	88 83       	st	Y, r24
			*oneValue = value%10;
    24ba:	83 2f       	mov	r24, r19
    24bc:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    24c0:	f7 01       	movw	r30, r14
    24c2:	90 83       	st	Z, r25
			(*FunP)();			
    24c4:	f8 01       	movw	r30, r16
    24c6:	09 95       	icall
		}
		while(KEY_DOWN_L);	
    24c8:	9f 9b       	sbis	0x13, 7	; 19
    24ca:	fe cf       	rjmp	.-4      	; 0x24c8 <Key_Operation+0xbc>
	}
}
    24cc:	df 91       	pop	r29
    24ce:	cf 91       	pop	r28
    24d0:	1f 91       	pop	r17
    24d2:	0f 91       	pop	r16
    24d4:	ff 90       	pop	r15
    24d6:	ef 90       	pop	r14
    24d8:	df 90       	pop	r13
    24da:	cf 90       	pop	r12
    24dc:	08 95       	ret

000024de <StartAD>:

uint16 AD_time_count;

void StartAD()
{
	ADCSRA=0x00;
    24de:	16 b8       	out	0x06, r1	; 6
	ADMUX=0x40;
    24e0:	80 e4       	ldi	r24, 0x40	; 64
    24e2:	87 b9       	out	0x07, r24	; 7
	ADCSRA=(1<<ADEN)|(1<<ADSC)|(1<<ADIF)|0x07;   //128分频，连续转换
    24e4:	87 ed       	ldi	r24, 0xD7	; 215
    24e6:	86 b9       	out	0x06, r24	; 6
}
    24e8:	08 95       	ret

000024ea <GetDispalyLight>:

void GetDispalyLight()
{
	uint8 ten_1;
	uint16 adc_data0,adc_l0,adc_h0;
	adc_l0=ADCL;
    24ea:	24 b1       	in	r18, 0x04	; 4
	adc_h0=ADCH;
    24ec:	45 b1       	in	r20, 0x05	; 5
	adc_data0=adc_h0<<8|adc_l0;                  
    24ee:	94 2f       	mov	r25, r20
    24f0:	80 e0       	ldi	r24, 0x00	; 0
    24f2:	30 e0       	ldi	r19, 0x00	; 0
    24f4:	82 2b       	or	r24, r18
    24f6:	93 2b       	or	r25, r19
	adc_data0=adc_data0>>1;               //放弃一位的精度
    24f8:	96 95       	lsr	r25
    24fa:	87 95       	ror	r24
	adc_data0-=35;                        //修正
	ten_1=(adc_data0)/60;
	display_light = 8 - ten_1;
    24fc:	83 97       	sbiw	r24, 0x23	; 35
    24fe:	6c e3       	ldi	r22, 0x3C	; 60
    2500:	70 e0       	ldi	r23, 0x00	; 0
    2502:	0e 94 f6 18 	call	0x31ec	; 0x31ec <__udivmodhi4>
    2506:	98 e0       	ldi	r25, 0x08	; 8
    2508:	89 2f       	mov	r24, r25
    250a:	86 1b       	sub	r24, r22
    250c:	80 93 73 00 	sts	0x0073, r24
	if(display_light > 8)
    2510:	89 30       	cpi	r24, 0x09	; 9
    2512:	18 f0       	brcs	.+6      	; 0x251a <GetDispalyLight+0x30>
	{
		display_light = 8;
    2514:	90 93 73 00 	sts	0x0073, r25
    2518:	05 c0       	rjmp	.+10     	; 0x2524 <GetDispalyLight+0x3a>
	}
	else if(display_light < 1)
    251a:	88 23       	and	r24, r24
    251c:	19 f4       	brne	.+6      	; 0x2524 <GetDispalyLight+0x3a>
	{
		display_light = 1;
    251e:	81 e0       	ldi	r24, 0x01	; 1
    2520:	80 93 73 00 	sts	0x0073, r24
	}
	SET_DISPLAY_LIGHT;
    2524:	80 91 73 00 	lds	r24, 0x0073
    2528:	29 e1       	ldi	r18, 0x19	; 25
    252a:	82 9f       	mul	r24, r18
    252c:	c0 01       	movw	r24, r0
    252e:	11 24       	eor	r1, r1
    2530:	88 51       	subi	r24, 0x18	; 24
    2532:	8c bf       	out	0x3c, r24	; 60
}
    2534:	08 95       	ret

00002536 <timer0_init>:



void timer0_init(void)
{
	TCCR0=0x00;//停止
    2536:	13 be       	out	0x33, r1	; 51
	TCNT0=0x00;//清除定时器值
    2538:	12 be       	out	0x32, r1	; 50
	TCCR0=0x79;//快速PWM模式,匹配时OC0清零,top时置数,系统时钟1024分频,输出比较匹配清除定时器值
    253a:	89 e7       	ldi	r24, 0x79	; 121
    253c:	83 bf       	out	0x33, r24	; 51
	if(RunParameter[18] <= 8)
    253e:	80 91 72 00 	lds	r24, 0x0072
    2542:	89 30       	cpi	r24, 0x09	; 9
    2544:	40 f4       	brcc	.+16     	; 0x2556 <timer0_init+0x20>
	{
		SET_DISPLAY_LIGHT;//OCR0置初值,占空比50%，调整OCR0的值用来调整占空比
    2546:	80 91 73 00 	lds	r24, 0x0073
    254a:	29 e1       	ldi	r18, 0x19	; 25
    254c:	82 9f       	mul	r24, r18
    254e:	c0 01       	movw	r24, r0
    2550:	11 24       	eor	r1, r1
    2552:	88 51       	subi	r24, 0x18	; 24
    2554:	01 c0       	rjmp	.+2      	; 0x2558 <timer0_init+0x22>
	}
	else
	{
		OCR0 = 0x64;
    2556:	84 e6       	ldi	r24, 0x64	; 100
    2558:	8c bf       	out	0x3c, r24	; 60
    255a:	08 95       	ret

0000255c <timer2_init>:
	}
}

void timer2_init(void)
{
	TCCR2  = 0x00;//停止定时器
    255c:	15 bc       	out	0x25, r1	; 37
	ASSR   = 0x00;//异步时钟模式
    255e:	12 bc       	out	0x22, r1	; 34
	TCNT2  = 0x83;//初始值
    2560:	83 e8       	ldi	r24, 0x83	; 131
    2562:	84 bd       	out	0x24, r24	; 36
	OCR2   = 0x82;//匹配值
    2564:	82 e8       	ldi	r24, 0x82	; 130
    2566:	83 bd       	out	0x23, r24	; 35
	TIMSK |= 0x40;//中断允许
    2568:	89 b7       	in	r24, 0x39	; 57
    256a:	80 64       	ori	r24, 0x40	; 64
    256c:	89 bf       	out	0x39, r24	; 57
	TCCR2  = 0x04;//启动定时器
    256e:	84 e0       	ldi	r24, 0x04	; 4
    2570:	85 bd       	out	0x25, r24	; 37
}
    2572:	08 95       	ret

00002574 <__vector_4>:

/*定时器2的中断服务程序，用于显示处理*/
SIGNAL(SIG_OVERFLOW2)
{
    2574:	1f 92       	push	r1
    2576:	0f 92       	push	r0
    2578:	0f b6       	in	r0, 0x3f	; 63
    257a:	0f 92       	push	r0
    257c:	11 24       	eor	r1, r1
    257e:	2f 93       	push	r18
    2580:	3f 93       	push	r19
    2582:	4f 93       	push	r20
    2584:	5f 93       	push	r21
    2586:	6f 93       	push	r22
    2588:	7f 93       	push	r23
    258a:	8f 93       	push	r24
    258c:	9f 93       	push	r25
    258e:	af 93       	push	r26
    2590:	bf 93       	push	r27
    2592:	ef 93       	push	r30
    2594:	ff 93       	push	r31
	//1ms
	PLUSE_Out();
    2596:	0e 94 a8 11 	call	0x2350	; 0x2350 <PLUSE_Out>
	SPEEK_Time();
    259a:	0e 94 ab 0f 	call	0x1f56	; 0x1f56 <SPEEK_Time>
	if( Mode == 0 && SPEEK_TIME_Status == 0)
    259e:	80 91 75 00 	lds	r24, 0x0075
    25a2:	88 23       	and	r24, r24
    25a4:	09 f0       	breq	.+2      	; 0x25a8 <__vector_4+0x34>
    25a6:	3f c0       	rjmp	.+126    	; 0x2626 <__vector_4+0xb2>
    25a8:	80 91 9f 02 	lds	r24, 0x029F
    25ac:	88 23       	and	r24, r24
    25ae:	d9 f5       	brne	.+118    	; 0x2626 <__vector_4+0xb2>
	{
		ReadDS18B20Count ++;
    25b0:	80 91 83 02 	lds	r24, 0x0283
    25b4:	90 91 84 02 	lds	r25, 0x0284
    25b8:	01 96       	adiw	r24, 0x01	; 1
    25ba:	90 93 84 02 	sts	0x0284, r25
    25be:	80 93 83 02 	sts	0x0283, r24
		if(ReadDS18B20Count == 51250)
    25c2:	82 53       	subi	r24, 0x32	; 50
    25c4:	98 4c       	sbci	r25, 0xC8	; 200
    25c6:	11 f4       	brne	.+4      	; 0x25cc <__vector_4+0x58>
		{
			ds1820_start();    
    25c8:	0e 94 42 08 	call	0x1084	; 0x1084 <ds1820_start>
		}
		
		if(ReadDS18B20Count > 60000)
    25cc:	80 91 83 02 	lds	r24, 0x0283
    25d0:	90 91 84 02 	lds	r25, 0x0284
    25d4:	81 56       	subi	r24, 0x61	; 97
    25d6:	9a 4e       	sbci	r25, 0xEA	; 234
    25d8:	30 f0       	brcs	.+12     	; 0x25e6 <__vector_4+0x72>
		{
			ReadTemputer(); 
    25da:	0e 94 4b 08 	call	0x1096	; 0x1096 <ReadTemputer>
			ReadDS18B20Count = 0;
    25de:	10 92 84 02 	sts	0x0284, r1
    25e2:	10 92 83 02 	sts	0x0283, r1
		}	
		if(!display_light_Mode)
    25e6:	80 91 72 00 	lds	r24, 0x0072
    25ea:	88 23       	and	r24, r24
    25ec:	e1 f4       	brne	.+56     	; 0x2626 <__vector_4+0xb2>
		{
			AD_time_count ++;
    25ee:	80 91 81 02 	lds	r24, 0x0281
    25f2:	90 91 82 02 	lds	r25, 0x0282
    25f6:	01 96       	adiw	r24, 0x01	; 1
    25f8:	90 93 82 02 	sts	0x0282, r25
    25fc:	80 93 81 02 	sts	0x0281, r24
			if(AD_time_count == 600)
    2600:	22 e0       	ldi	r18, 0x02	; 2
    2602:	88 35       	cpi	r24, 0x58	; 88
    2604:	92 07       	cpc	r25, r18
    2606:	31 f4       	brne	.+12     	; 0x2614 <__vector_4+0xa0>

uint16 AD_time_count;

void StartAD()
{
	ADCSRA=0x00;
    2608:	16 b8       	out	0x06, r1	; 6
	ADMUX=0x40;
    260a:	80 e4       	ldi	r24, 0x40	; 64
    260c:	87 b9       	out	0x07, r24	; 7
	ADCSRA=(1<<ADEN)|(1<<ADSC)|(1<<ADIF)|0x07;   //128分频，连续转换
    260e:	87 ed       	ldi	r24, 0xD7	; 215
    2610:	86 b9       	out	0x06, r24	; 6
    2612:	09 c0       	rjmp	.+18     	; 0x2626 <__vector_4+0xb2>
			{
				StartAD();    
			}
		
			if(AD_time_count > 900)
    2614:	85 58       	subi	r24, 0x85	; 133
    2616:	93 40       	sbci	r25, 0x03	; 3
    2618:	30 f0       	brcs	.+12     	; 0x2626 <__vector_4+0xb2>
			{
				GetDispalyLight(); 
    261a:	0e 94 75 12 	call	0x24ea	; 0x24ea <GetDispalyLight>
				AD_time_count = 0;
    261e:	10 92 82 02 	sts	0x0282, r1
    2622:	10 92 81 02 	sts	0x0281, r1
			}	
		}
	}
	KEY_Time_count ++;	
    2626:	80 91 8b 02 	lds	r24, 0x028B
    262a:	90 91 8c 02 	lds	r25, 0x028C
    262e:	01 96       	adiw	r24, 0x01	; 1
    2630:	90 93 8c 02 	sts	0x028C, r25
    2634:	80 93 8b 02 	sts	0x028B, r24
	KEY_Time_count_speed_color ++;
    2638:	80 91 9d 02 	lds	r24, 0x029D
    263c:	90 91 9e 02 	lds	r25, 0x029E
    2640:	01 96       	adiw	r24, 0x01	; 1
    2642:	90 93 9e 02 	sts	0x029E, r25
    2646:	80 93 9d 02 	sts	0x029D, r24
	TCNT2 = 0x83;
    264a:	83 e8       	ldi	r24, 0x83	; 131
    264c:	84 bd       	out	0x24, r24	; 36
}
    264e:	ff 91       	pop	r31
    2650:	ef 91       	pop	r30
    2652:	bf 91       	pop	r27
    2654:	af 91       	pop	r26
    2656:	9f 91       	pop	r25
    2658:	8f 91       	pop	r24
    265a:	7f 91       	pop	r23
    265c:	6f 91       	pop	r22
    265e:	5f 91       	pop	r21
    2660:	4f 91       	pop	r20
    2662:	3f 91       	pop	r19
    2664:	2f 91       	pop	r18
    2666:	0f 90       	pop	r0
    2668:	0f be       	out	0x3f, r0	; 63
    266a:	0f 90       	pop	r0
    266c:	1f 90       	pop	r1
    266e:	18 95       	reti

00002670 <fullScreen>:
	memset(display_buffer,0x00,256);
}

void fullScreen()
{
	memset(display_buffer,0xFF,256);
    2670:	81 e9       	ldi	r24, 0x91	; 145
    2672:	90 e0       	ldi	r25, 0x00	; 0
    2674:	6f ef       	ldi	r22, 0xFF	; 255
    2676:	70 e0       	ldi	r23, 0x00	; 0
    2678:	40 e0       	ldi	r20, 0x00	; 0
    267a:	51 e0       	ldi	r21, 0x01	; 1
    267c:	0e 94 e3 18 	call	0x31c6	; 0x31c6 <memset>
}
    2680:	08 95       	ret

00002682 <clearScreen>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2682:	80 e0       	ldi	r24, 0x00	; 0
    2684:	91 e0       	ldi	r25, 0x01	; 1
    2686:	e1 e9       	ldi	r30, 0x91	; 145
    2688:	f0 e0       	ldi	r31, 0x00	; 0
    268a:	df 01       	movw	r26, r30
    268c:	9c 01       	movw	r18, r24
    268e:	1d 92       	st	X+, r1
    2690:	21 50       	subi	r18, 0x01	; 1
    2692:	30 40       	sbci	r19, 0x00	; 0
    2694:	e1 f7       	brne	.-8      	; 0x268e <clearScreen+0xc>
}
    2696:	08 95       	ret

00002698 <init_devices>:
#include "_Timers.h"
#include "_Infrared.h"

void init_devices()
{
	cli(); //关闭所有中断
    2698:	f8 94       	cli
	MCUCR  = 0x00;
    269a:	15 be       	out	0x35, r1	; 53
	//MCUCSR = 0x80;//禁止JTAG
	GICR   = 0x00;//关闭外部中断
    269c:	1b be       	out	0x3b, r1	; 59
	LED_SCREEN_INI(); //初始化LED点阵
    269e:	0e 94 b7 09 	call	0x136e	; 0x136e <LED_SCREEN_INI>
	Key_Init();
    26a2:	0e 94 fd 11 	call	0x23fa	; 0x23fa <Key_Init>

uint8 inVoice;

void Voice_Init()
{
	VOICE_BUSY_PORT |= 1<<VOICE_BUSY_BIT;
    26a6:	aa 9a       	sbi	0x15, 2	; 21
	VOICE_BUSY_DDR  &= ~(1<<VOICE_BUSY_BIT);
    26a8:	a2 98       	cbi	0x14, 2	; 20
	VOICE_REST_DDR |= 1<<VOICE_REST_BIT;
    26aa:	a3 9a       	sbi	0x14, 3	; 20
	VOICE_DATA_DDR |= 1<<VOICE_DATA_BIT;
    26ac:	a4 9a       	sbi	0x14, 4	; 20



void timer0_init(void)
{
	TCCR0=0x00;//停止
    26ae:	13 be       	out	0x33, r1	; 51
	TCNT0=0x00;//清除定时器值
    26b0:	12 be       	out	0x32, r1	; 50
	TCCR0=0x79;//快速PWM模式,匹配时OC0清零,top时置数,系统时钟1024分频,输出比较匹配清除定时器值
    26b2:	89 e7       	ldi	r24, 0x79	; 121
    26b4:	83 bf       	out	0x33, r24	; 51
	if(RunParameter[18] <= 8)
    26b6:	80 91 72 00 	lds	r24, 0x0072
    26ba:	89 30       	cpi	r24, 0x09	; 9
    26bc:	40 f4       	brcc	.+16     	; 0x26ce <init_devices+0x36>
	{
		SET_DISPLAY_LIGHT;//OCR0置初值,占空比50%，调整OCR0的值用来调整占空比
    26be:	80 91 73 00 	lds	r24, 0x0073
    26c2:	29 e1       	ldi	r18, 0x19	; 25
    26c4:	82 9f       	mul	r24, r18
    26c6:	c0 01       	movw	r24, r0
    26c8:	11 24       	eor	r1, r1
    26ca:	88 51       	subi	r24, 0x18	; 24
    26cc:	01 c0       	rjmp	.+2      	; 0x26d0 <init_devices+0x38>
	}
	else
	{
		OCR0 = 0x64;
    26ce:	84 e6       	ldi	r24, 0x64	; 100
    26d0:	8c bf       	out	0x3c, r24	; 60
	}
}

void timer2_init(void)
{
	TCCR2  = 0x00;//停止定时器
    26d2:	15 bc       	out	0x25, r1	; 37
	ASSR   = 0x00;//异步时钟模式
    26d4:	12 bc       	out	0x22, r1	; 34
	TCNT2  = 0x83;//初始值
    26d6:	83 e8       	ldi	r24, 0x83	; 131
    26d8:	84 bd       	out	0x24, r24	; 36
	OCR2   = 0x82;//匹配值
    26da:	82 e8       	ldi	r24, 0x82	; 130
    26dc:	83 bd       	out	0x23, r24	; 35
	TIMSK |= 0x40;//中断允许
    26de:	89 b7       	in	r24, 0x39	; 57
    26e0:	80 64       	ori	r24, 0x40	; 64
    26e2:	89 bf       	out	0x39, r24	; 57
	TCCR2  = 0x04;//启动定时器
    26e4:	84 e0       	ldi	r24, 0x04	; 4
    26e6:	85 bd       	out	0x25, r24	; 37
	Voice_Init();
	//USART_Init();
	timer0_init(); //初始化定时器
	timer2_init();
	PCF8563_init();
    26e8:	0e 94 8d 0e 	call	0x1d1a	; 0x1d1a <PCF8563_init>
	ReadDS18B20Count = 0;
    26ec:	10 92 84 02 	sts	0x0284, r1
    26f0:	10 92 83 02 	sts	0x0283, r1
	AD_time_count = 0;
    26f4:	10 92 82 02 	sts	0x0282, r1
    26f8:	10 92 81 02 	sts	0x0281, r1
	KEY_Time_count = 0;
    26fc:	10 92 8c 02 	sts	0x028C, r1
    2700:	10 92 8b 02 	sts	0x028B, r1
	ds1820_reset();  
    2704:	0e 94 10 08 	call	0x1020	; 0x1020 <ds1820_reset>
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2708:	80 e0       	ldi	r24, 0x00	; 0
    270a:	91 e0       	ldi	r25, 0x01	; 1
    270c:	e1 e9       	ldi	r30, 0x91	; 145
    270e:	f0 e0       	ldi	r31, 0x00	; 0
    2710:	df 01       	movw	r26, r30
    2712:	9c 01       	movw	r18, r24
    2714:	1d 92       	st	X+, r1
    2716:	21 50       	subi	r18, 0x01	; 1
    2718:	30 40       	sbci	r19, 0x00	; 0
    271a:	e1 f7       	brne	.-8      	; 0x2714 <init_devices+0x7c>
	clearScreen();	
	sei(); //使能中断
    271c:	78 94       	sei
}
    271e:	08 95       	ret

00002720 <Show_welcome>:
	display_cnt++;
	if(display_cnt==16)display_cnt=0;
}

void Show_welcome()
{
    2720:	cf 93       	push	r28
    2722:	df 93       	push	r29
	uint16 timer_count;
	Mode = 28;
    2724:	8c e1       	ldi	r24, 0x1C	; 28
    2726:	80 93 75 00 	sts	0x0075, r24
	writeOneChinese(0, 0, 0);	
    272a:	80 e0       	ldi	r24, 0x00	; 0
    272c:	60 e0       	ldi	r22, 0x00	; 0
    272e:	40 e0       	ldi	r20, 0x00	; 0
    2730:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 0, 1);
    2734:	82 e0       	ldi	r24, 0x02	; 2
    2736:	60 e0       	ldi	r22, 0x00	; 0
    2738:	41 e0       	ldi	r20, 0x01	; 1
    273a:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(4, 0, 2);
    273e:	84 e0       	ldi	r24, 0x04	; 4
    2740:	60 e0       	ldi	r22, 0x00	; 0
    2742:	42 e0       	ldi	r20, 0x02	; 2
    2744:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(6, 0, 3);
    2748:	86 e0       	ldi	r24, 0x06	; 6
    274a:	60 e0       	ldi	r22, 0x00	; 0
    274c:	43 e0       	ldi	r20, 0x03	; 3
    274e:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16, 4);	
    2752:	80 e0       	ldi	r24, 0x00	; 0
    2754:	60 e1       	ldi	r22, 0x10	; 16
    2756:	44 e0       	ldi	r20, 0x04	; 4
    2758:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 16, 5);
    275c:	82 e0       	ldi	r24, 0x02	; 2
    275e:	60 e1       	ldi	r22, 0x10	; 16
    2760:	45 e0       	ldi	r20, 0x05	; 5
    2762:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(4, 16, 6);
    2766:	84 e0       	ldi	r24, 0x04	; 4
    2768:	60 e1       	ldi	r22, 0x10	; 16
    276a:	46 e0       	ldi	r20, 0x06	; 6
    276c:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(6, 16, 7);
    2770:	86 e0       	ldi	r24, 0x06	; 6
    2772:	60 e1       	ldi	r22, 0x10	; 16
    2774:	47 e0       	ldi	r20, 0x07	; 7
    2776:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    277a:	c0 e0       	ldi	r28, 0x00	; 0
    277c:	d0 e0       	ldi	r29, 0x00	; 0
	for(timer_count=0; timer_count< 5000; timer_count++)
	{
		display();
    277e:	0e 94 ae 0b 	call	0x175c	; 0x175c <display>
	writeOneChinese(6, 0, 3);
	writeOneChinese(0, 16, 4);	
	writeOneChinese(2, 16, 5);
	writeOneChinese(4, 16, 6);
	writeOneChinese(6, 16, 7);
	for(timer_count=0; timer_count< 5000; timer_count++)
    2782:	21 96       	adiw	r28, 0x01	; 1
    2784:	23 e1       	ldi	r18, 0x13	; 19
    2786:	c8 38       	cpi	r28, 0x88	; 136
    2788:	d2 07       	cpc	r29, r18
    278a:	c9 f7       	brne	.-14     	; 0x277e <Show_welcome+0x5e>
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    278c:	80 e0       	ldi	r24, 0x00	; 0
    278e:	91 e0       	ldi	r25, 0x01	; 1
    2790:	e1 e9       	ldi	r30, 0x91	; 145
    2792:	f0 e0       	ldi	r31, 0x00	; 0
    2794:	df 01       	movw	r26, r30
    2796:	9c 01       	movw	r18, r24
    2798:	1d 92       	st	X+, r1
    279a:	21 50       	subi	r18, 0x01	; 1
    279c:	30 40       	sbci	r19, 0x00	; 0
    279e:	e1 f7       	brne	.-8      	; 0x2798 <Show_welcome+0x78>
	{
		display();
		s_10us(10); //延迟10ms
	}
	clearScreen();
	Mode = 0;
    27a0:	10 92 75 00 	sts	0x0075, r1
}
    27a4:	df 91       	pop	r29
    27a6:	cf 91       	pop	r28
    27a8:	08 95       	ret

000027aa <FreshDisplayBufferNormal>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    27aa:	80 e0       	ldi	r24, 0x00	; 0
    27ac:	91 e0       	ldi	r25, 0x01	; 1
    27ae:	e1 e9       	ldi	r30, 0x91	; 145
    27b0:	f0 e0       	ldi	r31, 0x00	; 0
    27b2:	df 01       	movw	r26, r30
    27b4:	9c 01       	movw	r18, r24
    27b6:	1d 92       	st	X+, r1
    27b8:	21 50       	subi	r18, 0x01	; 1
    27ba:	30 40       	sbci	r19, 0x00	; 0
    27bc:	e1 f7       	brne	.-8      	; 0x27b6 <FreshDisplayBufferNormal+0xc>
void FreshDisplayBufferNormal()
{
	clearScreen();
	///// 10年 11月 12周 13度 14一 15二 16三 17四 18五 19六 20日 21点 22空格
	
	wirteOneBigNumber(0,0,HourTen ); 	//8 时十位
    27be:	80 e0       	ldi	r24, 0x00	; 0
    27c0:	60 e0       	ldi	r22, 0x00	; 0
    27c2:	40 91 68 00 	lds	r20, 0x0068
    27c6:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
	wirteOneBigNumber(2,0,HourOne );	//9 时个位
    27ca:	82 e0       	ldi	r24, 0x02	; 2
    27cc:	60 e0       	ldi	r22, 0x00	; 0
    27ce:	40 91 69 00 	lds	r20, 0x0069
    27d2:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
	wirteOneBigNumber(4,3,MinuteTen );	//10 分十位
    27d6:	84 e0       	ldi	r24, 0x04	; 4
    27d8:	63 e0       	ldi	r22, 0x03	; 3
    27da:	40 91 6a 00 	lds	r20, 0x006A
    27de:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
	wirteOneBigNumber(6,3,MinuteOne );	//11 分个位
    27e2:	86 e0       	ldi	r24, 0x06	; 6
    27e4:	63 e0       	ldi	r22, 0x03	; 3
    27e6:	40 91 6b 00 	lds	r20, 0x006B
    27ea:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
	
	writeOneSCROLL(0,23,YearThousand );		//0 年千位
    27ee:	80 e0       	ldi	r24, 0x00	; 0
    27f0:	67 e1       	ldi	r22, 0x17	; 23
    27f2:	40 91 60 00 	lds	r20, 0x0060
    27f6:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(1,23,YearHundred );		//1 年百位
    27fa:	81 e0       	ldi	r24, 0x01	; 1
    27fc:	67 e1       	ldi	r22, 0x17	; 23
    27fe:	40 91 61 00 	lds	r20, 0x0061
    2802:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(2,23,YearTen );		//2 年十位
    2806:	82 e0       	ldi	r24, 0x02	; 2
    2808:	67 e1       	ldi	r22, 0x17	; 23
    280a:	40 91 62 00 	lds	r20, 0x0062
    280e:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(3,23,YearOne );		//3 年个位
    2812:	83 e0       	ldi	r24, 0x03	; 3
    2814:	67 e1       	ldi	r22, 0x17	; 23
    2816:	40 91 63 00 	lds	r20, 0x0063
    281a:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(4,23,10);
    281e:	84 e0       	ldi	r24, 0x04	; 4
    2820:	67 e1       	ldi	r22, 0x17	; 23
    2822:	4a e0       	ldi	r20, 0x0A	; 10
    2824:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(5,23,MonthTen );		//4 月十位
    2828:	85 e0       	ldi	r24, 0x05	; 5
    282a:	67 e1       	ldi	r22, 0x17	; 23
    282c:	40 91 64 00 	lds	r20, 0x0064
    2830:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(6,23,MonthOne );		//5 月个位
    2834:	86 e0       	ldi	r24, 0x06	; 6
    2836:	67 e1       	ldi	r22, 0x17	; 23
    2838:	40 91 65 00 	lds	r20, 0x0065
    283c:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(7,23,11);	
    2840:	87 e0       	ldi	r24, 0x07	; 7
    2842:	67 e1       	ldi	r22, 0x17	; 23
    2844:	4b e0       	ldi	r20, 0x0B	; 11
    2846:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	///// 10年 11月 12周 13度 14一 15二 16三 17四 18五 19六 20日 21点 22空格
	writeOneSCROLL(0,24,DayTen );		//6 日十位
    284a:	80 e0       	ldi	r24, 0x00	; 0
    284c:	68 e1       	ldi	r22, 0x18	; 24
    284e:	40 91 66 00 	lds	r20, 0x0066
    2852:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(1,24,DayOne );		//7 日个位
    2856:	81 e0       	ldi	r24, 0x01	; 1
    2858:	68 e1       	ldi	r22, 0x18	; 24
    285a:	40 91 67 00 	lds	r20, 0x0067
    285e:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(2,24,20);
    2862:	82 e0       	ldi	r24, 0x02	; 2
    2864:	68 e1       	ldi	r22, 0x18	; 24
    2866:	44 e1       	ldi	r20, 0x14	; 20
    2868:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(4,24,12);
    286c:	84 e0       	ldi	r24, 0x04	; 4
    286e:	68 e1       	ldi	r22, 0x18	; 24
    2870:	4c e0       	ldi	r20, 0x0C	; 12
    2872:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(5,24,Week +13); 		//14 星期
    2876:	40 91 6e 00 	lds	r20, 0x006E
    287a:	43 5f       	subi	r20, 0xF3	; 243
    287c:	85 e0       	ldi	r24, 0x05	; 5
    287e:	68 e1       	ldi	r22, 0x18	; 24
    2880:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(7,24,TemperatureTen );		//15 温度十位
    2884:	87 e0       	ldi	r24, 0x07	; 7
    2886:	68 e1       	ldi	r22, 0x18	; 24
    2888:	40 91 6f 00 	lds	r20, 0x006F
    288c:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(0,25,TemperatureOne );		//16 温度个位
    2890:	80 e0       	ldi	r24, 0x00	; 0
    2892:	69 e1       	ldi	r22, 0x19	; 25
    2894:	40 91 70 00 	lds	r20, 0x0070
    2898:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(1,25,21);	
    289c:	81 e0       	ldi	r24, 0x01	; 1
    289e:	69 e1       	ldi	r22, 0x19	; 25
    28a0:	45 e1       	ldi	r20, 0x15	; 21
    28a2:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(2,25,TemperatureDecimal );		//17 温度小数	
    28a6:	82 e0       	ldi	r24, 0x02	; 2
    28a8:	69 e1       	ldi	r22, 0x19	; 25
    28aa:	40 91 71 00 	lds	r20, 0x0071
    28ae:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
	writeOneSCROLL(3,25,13);	
    28b2:	83 e0       	ldi	r24, 0x03	; 3
    28b4:	69 e1       	ldi	r22, 0x19	; 25
    28b6:	4d e0       	ldi	r20, 0x0D	; 13
    28b8:	0e 94 9b 0a 	call	0x1536	; 0x1536 <writeOneSCROLL>
}
    28bc:	08 95       	ret

000028be <FreshDisplayBufferAjustProofTime>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    28be:	80 e0       	ldi	r24, 0x00	; 0
    28c0:	91 e0       	ldi	r25, 0x01	; 1
    28c2:	e1 e9       	ldi	r30, 0x91	; 145
    28c4:	f0 e0       	ldi	r31, 0x00	; 0
    28c6:	df 01       	movw	r26, r30
    28c8:	9c 01       	movw	r18, r24
    28ca:	1d 92       	st	X+, r1
    28cc:	21 50       	subi	r18, 0x01	; 1
    28ce:	30 40       	sbci	r19, 0x00	; 0
    28d0:	e1 f7       	brne	.-8      	; 0x28ca <FreshDisplayBufferAjustProofTime+0xc>
}

void FreshDisplayBufferAjustProofTime() //校对时间模式
{
	clearScreen();
	writeOneChinese(0, 0, 29);
    28d2:	80 e0       	ldi	r24, 0x00	; 0
    28d4:	60 e0       	ldi	r22, 0x00	; 0
    28d6:	4d e1       	ldi	r20, 0x1D	; 29
    28d8:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16,13);	
    28dc:	80 e0       	ldi	r24, 0x00	; 0
    28de:	60 e1       	ldi	r22, 0x10	; 16
    28e0:	4d e0       	ldi	r20, 0x0D	; 13
    28e2:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    28e6:	e4 e4       	ldi	r30, 0x44	; 68
    28e8:	f6 e0       	ldi	r31, 0x06	; 6
    28ea:	a7 e4       	ldi	r26, 0x47	; 71
    28ec:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    28ee:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    28f0:	8c 93       	st	X, r24
    28f2:	31 96       	adiw	r30, 0x01	; 1
    28f4:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    28f6:	36 e0       	ldi	r19, 0x06	; 6
    28f8:	ee 34       	cpi	r30, 0x4E	; 78
    28fa:	f3 07       	cpc	r31, r19
    28fc:	c1 f7       	brne	.-16     	; 0x28ee <FreshDisplayBufferAjustProofTime+0x30>
    28fe:	2e ea       	ldi	r18, 0xAE	; 174
    2900:	35 e0       	ldi	r19, 0x05	; 5
    2902:	a8 e4       	ldi	r26, 0x48	; 72
    2904:	b1 e0       	ldi	r27, 0x01	; 1
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    2906:	f9 01       	movw	r30, r18
    2908:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    290a:	8c 93       	st	X, r24
    290c:	2f 5f       	subi	r18, 0xFF	; 255
    290e:	3f 4f       	sbci	r19, 0xFF	; 255
    2910:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2912:	f1 e0       	ldi	r31, 0x01	; 1
    2914:	a8 39       	cpi	r26, 0x98	; 152
    2916:	bf 07       	cpc	r27, r31
    2918:	b1 f7       	brne	.-20     	; 0x2906 <FreshDisplayBufferAjustProofTime+0x48>
	clearScreen();
	writeOneChinese(0, 0, 29);
	writeOneChinese(0, 16,13);	
	writeOneUnSCROLL(6,22,26); //每
	writeOneUnSCROLL(7,22,11);	//月
	if(AjustTimeMode) // 加
    291a:	80 91 76 00 	lds	r24, 0x0076
    291e:	88 23       	and	r24, r24
    2920:	79 f0       	breq	.+30     	; 0x2940 <FreshDisplayBufferAjustProofTime+0x82>
    2922:	2e e4       	ldi	r18, 0x4E	; 78
    2924:	36 e0       	ldi	r19, 0x06	; 6
    2926:	a3 e4       	ldi	r26, 0x43	; 67
    2928:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    292a:	f9 01       	movw	r30, r18
    292c:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    292e:	8c 93       	st	X, r24
    2930:	2f 5f       	subi	r18, 0xFF	; 255
    2932:	3f 4f       	sbci	r19, 0xFF	; 255
    2934:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2936:	f1 e0       	ldi	r31, 0x01	; 1
    2938:	a3 39       	cpi	r26, 0x93	; 147
    293a:	bf 07       	cpc	r27, r31
    293c:	b1 f7       	brne	.-20     	; 0x292a <FreshDisplayBufferAjustProofTime+0x6c>
    293e:	0e c0       	rjmp	.+28     	; 0x295c <FreshDisplayBufferAjustProofTime+0x9e>
    2940:	2a e8       	ldi	r18, 0x8A	; 138
    2942:	36 e0       	ldi	r19, 0x06	; 6
    2944:	a3 e4       	ldi	r26, 0x43	; 67
    2946:	b1 e0       	ldi	r27, 0x01	; 1
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    2948:	f9 01       	movw	r30, r18
    294a:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    294c:	8c 93       	st	X, r24
    294e:	2f 5f       	subi	r18, 0xFF	; 255
    2950:	3f 4f       	sbci	r19, 0xFF	; 255
    2952:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2954:	f1 e0       	ldi	r31, 0x01	; 1
    2956:	a3 39       	cpi	r26, 0x93	; 147
    2958:	bf 07       	cpc	r27, r31
    295a:	b1 f7       	brne	.-20     	; 0x2948 <FreshDisplayBufferAjustProofTime+0x8a>
	}
	else
	{
		writeOneUnSCROLL(2,22,33);	//减
	}
	wirteOneBigNumber(3,0,AjustTimeTen); 
    295c:	83 e0       	ldi	r24, 0x03	; 3
    295e:	60 e0       	ldi	r22, 0x00	; 0
    2960:	40 91 77 00 	lds	r20, 0x0077
    2964:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
	wirteOneBigNumber(5,0,AjustTimeOne);
    2968:	85 e0       	ldi	r24, 0x05	; 5
    296a:	60 e0       	ldi	r22, 0x00	; 0
    296c:	40 91 78 00 	lds	r20, 0x0078
    2970:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
    2974:	20 e3       	ldi	r18, 0x30	; 48
    2976:	36 e0       	ldi	r19, 0x06	; 6
    2978:	a0 ef       	ldi	r26, 0xF0	; 240
    297a:	b0 e0       	ldi	r27, 0x00	; 0
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    297c:	f9 01       	movw	r30, r18
    297e:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    2980:	8c 93       	st	X, r24
    2982:	2f 5f       	subi	r18, 0xFF	; 255
    2984:	3f 4f       	sbci	r19, 0xFF	; 255
    2986:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2988:	f1 e0       	ldi	r31, 0x01	; 1
    298a:	a0 34       	cpi	r26, 0x40	; 64
    298c:	bf 07       	cpc	r27, r31
    298e:	b1 f7       	brne	.-20     	; 0x297c <FreshDisplayBufferAjustProofTime+0xbe>
		writeOneUnSCROLL(2,22,33);	//减
	}
	wirteOneBigNumber(3,0,AjustTimeTen); 
	wirteOneBigNumber(5,0,AjustTimeOne);
	writeOneUnSCROLL(7,11,24); //分
}
    2990:	08 95       	ret

00002992 <FreshDisplayBufferChangeFont>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2992:	80 e0       	ldi	r24, 0x00	; 0
    2994:	91 e0       	ldi	r25, 0x01	; 1
    2996:	e1 e9       	ldi	r30, 0x91	; 145
    2998:	f0 e0       	ldi	r31, 0x00	; 0
    299a:	df 01       	movw	r26, r30
    299c:	9c 01       	movw	r18, r24
    299e:	1d 92       	st	X+, r1
    29a0:	21 50       	subi	r18, 0x01	; 1
    29a2:	30 40       	sbci	r19, 0x00	; 0
    29a4:	e1 f7       	brne	.-8      	; 0x299e <FreshDisplayBufferChangeFont+0xc>
}

void FreshDisplayBufferChangeFont()
{
	clearScreen();
	writeOneChinese(0, 0, 8);	
    29a6:	80 e0       	ldi	r24, 0x00	; 0
    29a8:	60 e0       	ldi	r22, 0x00	; 0
    29aa:	48 e0       	ldi	r20, 0x08	; 8
    29ac:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 0, 9);
    29b0:	82 e0       	ldi	r24, 0x02	; 2
    29b2:	60 e0       	ldi	r22, 0x00	; 0
    29b4:	49 e0       	ldi	r20, 0x09	; 9
    29b6:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16, 27);
    29ba:	80 e0       	ldi	r24, 0x00	; 0
    29bc:	60 e1       	ldi	r22, 0x10	; 16
    29be:	4b e1       	ldi	r20, 0x1B	; 27
    29c0:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 16, 28);
    29c4:	82 e0       	ldi	r24, 0x02	; 2
    29c6:	60 e1       	ldi	r22, 0x10	; 16
    29c8:	4c e1       	ldi	r20, 0x1C	; 28
    29ca:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    29ce:	ec e6       	ldi	r30, 0x6C	; 108
    29d0:	f6 e0       	ldi	r31, 0x06	; 6
    29d2:	a5 e4       	ldi	r26, 0x45	; 69
    29d4:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    29d6:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    29d8:	8c 93       	st	X, r24
    29da:	31 96       	adiw	r30, 0x01	; 1
    29dc:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    29de:	36 e0       	ldi	r19, 0x06	; 6
    29e0:	e6 37       	cpi	r30, 0x76	; 118
    29e2:	f3 07       	cpc	r31, r19
    29e4:	c1 f7       	brne	.-16     	; 0x29d6 <FreshDisplayBufferChangeFont+0x44>
	writeOneChinese(0, 0, 8);	
	writeOneChinese(2, 0, 9);
	writeOneChinese(0, 16, 27);
	writeOneChinese(2, 16, 28);
	writeOneUnSCROLL(4,22,30);
	wirteOneBigNumber(5,0,3);
    29e6:	85 e0       	ldi	r24, 0x05	; 5
    29e8:	60 e0       	ldi	r22, 0x00	; 0
    29ea:	43 e0       	ldi	r20, 0x03	; 3
    29ec:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
}
    29f0:	08 95       	ret

000029f2 <FreshDisplayBufferAjustLightMode>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    29f2:	80 e0       	ldi	r24, 0x00	; 0
    29f4:	91 e0       	ldi	r25, 0x01	; 1
    29f6:	e1 e9       	ldi	r30, 0x91	; 145
    29f8:	f0 e0       	ldi	r31, 0x00	; 0
    29fa:	df 01       	movw	r26, r30
    29fc:	9c 01       	movw	r18, r24
    29fe:	1d 92       	st	X+, r1
    2a00:	21 50       	subi	r18, 0x01	; 1
    2a02:	30 40       	sbci	r19, 0x00	; 0
    2a04:	e1 f7       	brne	.-8      	; 0x29fe <FreshDisplayBufferAjustLightMode+0xc>
}

void FreshDisplayBufferAjustLightMode() //亮度模式
{
	clearScreen();
	writeOneChinese(0, 0, 8);	
    2a06:	80 e0       	ldi	r24, 0x00	; 0
    2a08:	60 e0       	ldi	r22, 0x00	; 0
    2a0a:	48 e0       	ldi	r20, 0x08	; 8
    2a0c:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 0, 9);
    2a10:	82 e0       	ldi	r24, 0x02	; 2
    2a12:	60 e0       	ldi	r22, 0x00	; 0
    2a14:	49 e0       	ldi	r20, 0x09	; 9
    2a16:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16, 12);
    2a1a:	80 e0       	ldi	r24, 0x00	; 0
    2a1c:	60 e1       	ldi	r22, 0x10	; 16
    2a1e:	4c e0       	ldi	r20, 0x0C	; 12
    2a20:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 16, 11);
    2a24:	82 e0       	ldi	r24, 0x02	; 2
    2a26:	60 e1       	ldi	r22, 0x10	; 16
    2a28:	4b e0       	ldi	r20, 0x0B	; 11
    2a2a:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    2a2e:	ec e6       	ldi	r30, 0x6C	; 108
    2a30:	f6 e0       	ldi	r31, 0x06	; 6
    2a32:	a5 e4       	ldi	r26, 0x45	; 69
    2a34:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    2a36:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    2a38:	8c 93       	st	X, r24
    2a3a:	31 96       	adiw	r30, 0x01	; 1
    2a3c:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2a3e:	36 e0       	ldi	r19, 0x06	; 6
    2a40:	e6 37       	cpi	r30, 0x76	; 118
    2a42:	f3 07       	cpc	r31, r19
    2a44:	c1 f7       	brne	.-16     	; 0x2a36 <FreshDisplayBufferAjustLightMode+0x44>
	writeOneChinese(0, 0, 8);	
	writeOneChinese(2, 0, 9);
	writeOneChinese(0, 16, 12);
	writeOneChinese(2, 16, 11);
	writeOneUnSCROLL(4,22,30);
	if(display_light_Mode) //手动
    2a46:	80 91 72 00 	lds	r24, 0x0072
    2a4a:	88 23       	and	r24, r24
    2a4c:	21 f0       	breq	.+8      	; 0x2a56 <FreshDisplayBufferAjustLightMode+0x64>
	{
		writeOneChinese(6, 0, 25);
    2a4e:	86 e0       	ldi	r24, 0x06	; 6
    2a50:	60 e0       	ldi	r22, 0x00	; 0
    2a52:	49 e1       	ldi	r20, 0x19	; 25
    2a54:	03 c0       	rjmp	.+6      	; 0x2a5c <FreshDisplayBufferAjustLightMode+0x6a>
	}
	else
	{
		writeOneChinese(6, 0, 24);
    2a56:	86 e0       	ldi	r24, 0x06	; 6
    2a58:	60 e0       	ldi	r22, 0x00	; 0
    2a5a:	48 e1       	ldi	r20, 0x18	; 24
    2a5c:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	}
	writeOneChinese(6, 16, 26);
    2a60:	86 e0       	ldi	r24, 0x06	; 6
    2a62:	60 e1       	ldi	r22, 0x10	; 16
    2a64:	4a e1       	ldi	r20, 0x1A	; 26
    2a66:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
}
    2a6a:	08 95       	ret

00002a6c <FreshDisplayBufferAjustLight>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2a6c:	80 e0       	ldi	r24, 0x00	; 0
    2a6e:	91 e0       	ldi	r25, 0x01	; 1
    2a70:	e1 e9       	ldi	r30, 0x91	; 145
    2a72:	f0 e0       	ldi	r31, 0x00	; 0
    2a74:	df 01       	movw	r26, r30
    2a76:	9c 01       	movw	r18, r24
    2a78:	1d 92       	st	X+, r1
    2a7a:	21 50       	subi	r18, 0x01	; 1
    2a7c:	30 40       	sbci	r19, 0x00	; 0
    2a7e:	e1 f7       	brne	.-8      	; 0x2a78 <FreshDisplayBufferAjustLight+0xc>
}

void FreshDisplayBufferAjustLight()
{
	clearScreen();
	if(display_light_Mode)
    2a80:	80 91 72 00 	lds	r24, 0x0072
    2a84:	88 23       	and	r24, r24
    2a86:	39 f1       	breq	.+78     	; 0x2ad6 <FreshDisplayBufferAjustLight+0x6a>
	{
		writeOneChinese(0, 0, 8);	
    2a88:	80 e0       	ldi	r24, 0x00	; 0
    2a8a:	60 e0       	ldi	r22, 0x00	; 0
    2a8c:	48 e0       	ldi	r20, 0x08	; 8
    2a8e:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
		writeOneChinese(2, 0, 9);
    2a92:	82 e0       	ldi	r24, 0x02	; 2
    2a94:	60 e0       	ldi	r22, 0x00	; 0
    2a96:	49 e0       	ldi	r20, 0x09	; 9
    2a98:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
		writeOneChinese(0, 16, 12);
    2a9c:	80 e0       	ldi	r24, 0x00	; 0
    2a9e:	60 e1       	ldi	r22, 0x10	; 16
    2aa0:	4c e0       	ldi	r20, 0x0C	; 12
    2aa2:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
		writeOneChinese(2, 16, 11);
    2aa6:	82 e0       	ldi	r24, 0x02	; 2
    2aa8:	60 e1       	ldi	r22, 0x10	; 16
    2aaa:	4b e0       	ldi	r20, 0x0B	; 11
    2aac:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    2ab0:	ec e6       	ldi	r30, 0x6C	; 108
    2ab2:	f6 e0       	ldi	r31, 0x06	; 6
    2ab4:	a5 e4       	ldi	r26, 0x45	; 69
    2ab6:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    2ab8:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    2aba:	8c 93       	st	X, r24
    2abc:	31 96       	adiw	r30, 0x01	; 1
    2abe:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2ac0:	36 e0       	ldi	r19, 0x06	; 6
    2ac2:	e6 37       	cpi	r30, 0x76	; 118
    2ac4:	f3 07       	cpc	r31, r19
    2ac6:	c1 f7       	brne	.-16     	; 0x2ab8 <FreshDisplayBufferAjustLight+0x4c>
		writeOneChinese(0, 0, 8);	
		writeOneChinese(2, 0, 9);
		writeOneChinese(0, 16, 12);
		writeOneChinese(2, 16, 11);
		writeOneUnSCROLL(4,22,30);
		wirteOneBigNumber(5,0,display_light);
    2ac8:	85 e0       	ldi	r24, 0x05	; 5
    2aca:	60 e0       	ldi	r22, 0x00	; 0
    2acc:	40 91 73 00 	lds	r20, 0x0073
    2ad0:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
    2ad4:	08 95       	ret
	}
	else
	{
		FreshDisplayBufferAjustLightMode();
    2ad6:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <FreshDisplayBufferAjustLightMode>
    2ada:	08 95       	ret

00002adc <FreshDisplayBufferVoiceMode>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2adc:	80 e0       	ldi	r24, 0x00	; 0
    2ade:	91 e0       	ldi	r25, 0x01	; 1
    2ae0:	e1 e9       	ldi	r30, 0x91	; 145
    2ae2:	f0 e0       	ldi	r31, 0x00	; 0
    2ae4:	df 01       	movw	r26, r30
    2ae6:	9c 01       	movw	r18, r24
    2ae8:	1d 92       	st	X+, r1
    2aea:	21 50       	subi	r18, 0x01	; 1
    2aec:	30 40       	sbci	r19, 0x00	; 0
    2aee:	e1 f7       	brne	.-8      	; 0x2ae8 <FreshDisplayBufferVoiceMode+0xc>
}

void FreshDisplayBufferVoiceMode()
{
	clearScreen();
	writeOneChinese(0, 0,40);	
    2af0:	80 e0       	ldi	r24, 0x00	; 0
    2af2:	60 e0       	ldi	r22, 0x00	; 0
    2af4:	48 e2       	ldi	r20, 0x28	; 40
    2af6:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 0, 41);
    2afa:	82 e0       	ldi	r24, 0x02	; 2
    2afc:	60 e0       	ldi	r22, 0x00	; 0
    2afe:	49 e2       	ldi	r20, 0x29	; 41
    2b00:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16, 42);
    2b04:	80 e0       	ldi	r24, 0x00	; 0
    2b06:	60 e1       	ldi	r22, 0x10	; 16
    2b08:	4a e2       	ldi	r20, 0x2A	; 42
    2b0a:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 16, 13);
    2b0e:	82 e0       	ldi	r24, 0x02	; 2
    2b10:	60 e1       	ldi	r22, 0x10	; 16
    2b12:	4d e0       	ldi	r20, 0x0D	; 13
    2b14:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    2b18:	ec e6       	ldi	r30, 0x6C	; 108
    2b1a:	f6 e0       	ldi	r31, 0x06	; 6
    2b1c:	a5 e4       	ldi	r26, 0x45	; 69
    2b1e:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    2b20:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    2b22:	8c 93       	st	X, r24
    2b24:	31 96       	adiw	r30, 0x01	; 1
    2b26:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2b28:	36 e0       	ldi	r19, 0x06	; 6
    2b2a:	e6 37       	cpi	r30, 0x76	; 118
    2b2c:	f3 07       	cpc	r31, r19
    2b2e:	c1 f7       	brne	.-16     	; 0x2b20 <FreshDisplayBufferVoiceMode+0x44>
	writeOneChinese(0, 0,40);	
	writeOneChinese(2, 0, 41);
	writeOneChinese(0, 16, 42);
	writeOneChinese(2, 16, 13);
	writeOneUnSCROLL(4,22,30);
	if(Voice_Mode == 0)
    2b30:	80 91 7c 00 	lds	r24, 0x007C
    2b34:	88 23       	and	r24, r24
    2b36:	49 f4       	brne	.+18     	; 0x2b4a <FreshDisplayBufferVoiceMode+0x6e>
	{
		writeOneChinese(6, 0, 43);
    2b38:	86 e0       	ldi	r24, 0x06	; 6
    2b3a:	60 e0       	ldi	r22, 0x00	; 0
    2b3c:	4b e2       	ldi	r20, 0x2B	; 43
    2b3e:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
		writeOneChinese(6, 16, 44);
    2b42:	86 e0       	ldi	r24, 0x06	; 6
    2b44:	60 e1       	ldi	r22, 0x10	; 16
    2b46:	4c e2       	ldi	r20, 0x2C	; 44
    2b48:	13 c0       	rjmp	.+38     	; 0x2b70 <FreshDisplayBufferVoiceMode+0x94>
	}
	else if(Voice_Mode == 1)
    2b4a:	81 30       	cpi	r24, 0x01	; 1
    2b4c:	49 f4       	brne	.+18     	; 0x2b60 <FreshDisplayBufferVoiceMode+0x84>
	{
		writeOneChinese(6, 0, 45);
    2b4e:	86 e0       	ldi	r24, 0x06	; 6
    2b50:	60 e0       	ldi	r22, 0x00	; 0
    2b52:	4d e2       	ldi	r20, 0x2D	; 45
    2b54:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
		writeOneChinese(6, 16, 46);
    2b58:	86 e0       	ldi	r24, 0x06	; 6
    2b5a:	60 e1       	ldi	r22, 0x10	; 16
    2b5c:	4e e2       	ldi	r20, 0x2E	; 46
    2b5e:	08 c0       	rjmp	.+16     	; 0x2b70 <FreshDisplayBufferVoiceMode+0x94>
	}
	else
	{
		writeOneChinese(6, 0, 47);
    2b60:	86 e0       	ldi	r24, 0x06	; 6
    2b62:	60 e0       	ldi	r22, 0x00	; 0
    2b64:	4f e2       	ldi	r20, 0x2F	; 47
    2b66:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
		writeOneChinese(6, 16, 48);
    2b6a:	86 e0       	ldi	r24, 0x06	; 6
    2b6c:	60 e1       	ldi	r22, 0x10	; 16
    2b6e:	40 e3       	ldi	r20, 0x30	; 48
    2b70:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    2b74:	08 95       	ret

00002b76 <FreshDisplayBufferAjustSpeed>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2b76:	80 e0       	ldi	r24, 0x00	; 0
    2b78:	91 e0       	ldi	r25, 0x01	; 1
    2b7a:	e1 e9       	ldi	r30, 0x91	; 145
    2b7c:	f0 e0       	ldi	r31, 0x00	; 0
    2b7e:	df 01       	movw	r26, r30
    2b80:	9c 01       	movw	r18, r24
    2b82:	1d 92       	st	X+, r1
    2b84:	21 50       	subi	r18, 0x01	; 1
    2b86:	30 40       	sbci	r19, 0x00	; 0
    2b88:	e1 f7       	brne	.-8      	; 0x2b82 <FreshDisplayBufferAjustSpeed+0xc>
}

void FreshDisplayBufferAjustSpeed()
{
	clearScreen();
	writeOneChinese(0, 0, 8);	
    2b8a:	80 e0       	ldi	r24, 0x00	; 0
    2b8c:	60 e0       	ldi	r22, 0x00	; 0
    2b8e:	48 e0       	ldi	r20, 0x08	; 8
    2b90:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 0, 9);
    2b94:	82 e0       	ldi	r24, 0x02	; 2
    2b96:	60 e0       	ldi	r22, 0x00	; 0
    2b98:	49 e0       	ldi	r20, 0x09	; 9
    2b9a:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16, 10);
    2b9e:	80 e0       	ldi	r24, 0x00	; 0
    2ba0:	60 e1       	ldi	r22, 0x10	; 16
    2ba2:	4a e0       	ldi	r20, 0x0A	; 10
    2ba4:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 16, 11);
    2ba8:	82 e0       	ldi	r24, 0x02	; 2
    2baa:	60 e1       	ldi	r22, 0x10	; 16
    2bac:	4b e0       	ldi	r20, 0x0B	; 11
    2bae:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    2bb2:	ec e6       	ldi	r30, 0x6C	; 108
    2bb4:	f6 e0       	ldi	r31, 0x06	; 6
    2bb6:	a5 e4       	ldi	r26, 0x45	; 69
    2bb8:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    2bba:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    2bbc:	8c 93       	st	X, r24
    2bbe:	31 96       	adiw	r30, 0x01	; 1
    2bc0:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2bc2:	36 e0       	ldi	r19, 0x06	; 6
    2bc4:	e6 37       	cpi	r30, 0x76	; 118
    2bc6:	f3 07       	cpc	r31, r19
    2bc8:	c1 f7       	brne	.-16     	; 0x2bba <FreshDisplayBufferAjustSpeed+0x44>
	writeOneChinese(0, 0, 8);	
	writeOneChinese(2, 0, 9);
	writeOneChinese(0, 16, 10);
	writeOneChinese(2, 16, 11);
	writeOneUnSCROLL(4,22,30);
	wirteOneBigNumber(5,0,moveSpeed);
    2bca:	85 e0       	ldi	r24, 0x05	; 5
    2bcc:	60 e0       	ldi	r22, 0x00	; 0
    2bce:	40 91 74 00 	lds	r20, 0x0074
    2bd2:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
}
    2bd6:	08 95       	ret

00002bd8 <FreshDisplayBufferAjustWeek>:
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2bd8:	80 e0       	ldi	r24, 0x00	; 0
    2bda:	91 e0       	ldi	r25, 0x01	; 1
    2bdc:	e1 e9       	ldi	r30, 0x91	; 145
    2bde:	f0 e0       	ldi	r31, 0x00	; 0
    2be0:	df 01       	movw	r26, r30
    2be2:	9c 01       	movw	r18, r24
    2be4:	1d 92       	st	X+, r1
    2be6:	21 50       	subi	r18, 0x01	; 1
    2be8:	30 40       	sbci	r19, 0x00	; 0
    2bea:	e1 f7       	brne	.-8      	; 0x2be4 <FreshDisplayBufferAjustWeek+0xc>
}

void FreshDisplayBufferAjustWeek()
{
	clearScreen();
	writeOneChinese(0, 0, 8);	
    2bec:	80 e0       	ldi	r24, 0x00	; 0
    2bee:	60 e0       	ldi	r22, 0x00	; 0
    2bf0:	48 e0       	ldi	r20, 0x08	; 8
    2bf2:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 0, 9);
    2bf6:	82 e0       	ldi	r24, 0x02	; 2
    2bf8:	60 e0       	ldi	r22, 0x00	; 0
    2bfa:	49 e0       	ldi	r20, 0x09	; 9
    2bfc:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16, 21);
    2c00:	80 e0       	ldi	r24, 0x00	; 0
    2c02:	60 e1       	ldi	r22, 0x10	; 16
    2c04:	45 e1       	ldi	r20, 0x15	; 21
    2c06:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(2, 16, 22);
    2c0a:	82 e0       	ldi	r24, 0x02	; 2
    2c0c:	60 e1       	ldi	r22, 0x10	; 16
    2c0e:	46 e1       	ldi	r20, 0x16	; 22
    2c10:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
    2c14:	ec e6       	ldi	r30, 0x6C	; 108
    2c16:	f6 e0       	ldi	r31, 0x06	; 6
    2c18:	a5 e4       	ldi	r26, 0x45	; 69
    2c1a:	b1 e0       	ldi	r27, 0x01	; 1
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
	{
		temp = pgm_read_byte(&SCROLL[index][i]);
    2c1c:	84 91       	lpm	r24, Z+
		display_buffer[(y+i)*8+x] = temp;
    2c1e:	8c 93       	st	X, r24
    2c20:	31 96       	adiw	r30, 0x01	; 1
    2c22:	18 96       	adiw	r26, 0x08	; 8

void writeOneUnSCROLL(uint8 x, uint8 y,uint8 index)
{
	uint8 temp;
	uint8 i;
	for(i=0;i<10;i++)
    2c24:	36 e0       	ldi	r19, 0x06	; 6
    2c26:	e6 37       	cpi	r30, 0x76	; 118
    2c28:	f3 07       	cpc	r31, r19
    2c2a:	c1 f7       	brne	.-16     	; 0x2c1c <FreshDisplayBufferAjustWeek+0x44>
	writeOneChinese(0, 0, 8);	
	writeOneChinese(2, 0, 9);
	writeOneChinese(0, 16, 21);
	writeOneChinese(2, 16, 22);
	writeOneUnSCROLL(4,22,30);
	wirteOneBigNumber(5,0,Week);
    2c2c:	85 e0       	ldi	r24, 0x05	; 5
    2c2e:	60 e0       	ldi	r22, 0x00	; 0
    2c30:	40 91 6e 00 	lds	r20, 0x006E
    2c34:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
}
    2c38:	08 95       	ret

00002c3a <FreshDisplayComment>:
		}
	}
}

void FreshDisplayComment(uint8 *tenValue, uint8 *oneValue, uint8 matrixIndex)
{
    2c3a:	df 92       	push	r13
    2c3c:	ef 92       	push	r14
    2c3e:	ff 92       	push	r15
    2c40:	0f 93       	push	r16
    2c42:	1f 93       	push	r17
    2c44:	8c 01       	movw	r16, r24
    2c46:	7b 01       	movw	r14, r22
    2c48:	d4 2e       	mov	r13, r20
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2c4a:	80 e0       	ldi	r24, 0x00	; 0
    2c4c:	91 e0       	ldi	r25, 0x01	; 1
    2c4e:	e1 e9       	ldi	r30, 0x91	; 145
    2c50:	f0 e0       	ldi	r31, 0x00	; 0
    2c52:	df 01       	movw	r26, r30
    2c54:	9c 01       	movw	r18, r24
    2c56:	1d 92       	st	X+, r1
    2c58:	21 50       	subi	r18, 0x01	; 1
    2c5a:	30 40       	sbci	r19, 0x00	; 0
    2c5c:	e1 f7       	brne	.-8      	; 0x2c56 <FreshDisplayComment+0x1c>

void FreshDisplayComment(uint8 *tenValue, uint8 *oneValue, uint8 matrixIndex)
{
	clearScreen();
	
	writeOneChinese(0, 0, 8);	
    2c5e:	80 e0       	ldi	r24, 0x00	; 0
    2c60:	60 e0       	ldi	r22, 0x00	; 0
    2c62:	48 e0       	ldi	r20, 0x08	; 8
    2c64:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	writeOneChinese(0, 16, 9);
    2c68:	80 e0       	ldi	r24, 0x00	; 0
    2c6a:	60 e1       	ldi	r22, 0x10	; 16
    2c6c:	49 e0       	ldi	r20, 0x09	; 9
    2c6e:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
	wirteOneBigNumber(2,0,*tenValue); 
    2c72:	82 e0       	ldi	r24, 0x02	; 2
    2c74:	60 e0       	ldi	r22, 0x00	; 0
    2c76:	d8 01       	movw	r26, r16
    2c78:	4c 91       	ld	r20, X
    2c7a:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
	wirteOneBigNumber(4,0,*oneValue);
    2c7e:	84 e0       	ldi	r24, 0x04	; 4
    2c80:	60 e0       	ldi	r22, 0x00	; 0
    2c82:	f7 01       	movw	r30, r14
    2c84:	40 81       	ld	r20, Z
    2c86:	0e 94 03 0b 	call	0x1606	; 0x1606 <wirteOneBigNumber>
	writeOneChinese(6, 16, matrixIndex);
    2c8a:	86 e0       	ldi	r24, 0x06	; 6
    2c8c:	60 e1       	ldi	r22, 0x10	; 16
    2c8e:	4d 2d       	mov	r20, r13
    2c90:	0e 94 51 0a 	call	0x14a2	; 0x14a2 <writeOneChinese>
}
    2c94:	1f 91       	pop	r17
    2c96:	0f 91       	pop	r16
    2c98:	ff 90       	pop	r15
    2c9a:	ef 90       	pop	r14
    2c9c:	df 90       	pop	r13
    2c9e:	08 95       	ret

00002ca0 <FreshDisplayBufferAjustMinute>:
	FreshDisplayComment(&HourTen, &HourOne, 13);
}

void FreshDisplayBufferAjustMinute()
{
	FreshDisplayComment(&MinuteTen, &MinuteOne, 18);
    2ca0:	6a e6       	ldi	r22, 0x6A	; 106
    2ca2:	70 e0       	ldi	r23, 0x00	; 0
    2ca4:	cb 01       	movw	r24, r22
    2ca6:	6f 5f       	subi	r22, 0xFF	; 255
    2ca8:	7f 4f       	sbci	r23, 0xFF	; 255
    2caa:	42 e1       	ldi	r20, 0x12	; 18
    2cac:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <FreshDisplayComment>
}
    2cb0:	08 95       	ret

00002cb2 <FreshDisplayBufferAjustHour>:
	FreshDisplayComment(&DayTen, &DayOne, 17);
}

void FreshDisplayBufferAjustHour()
{
	FreshDisplayComment(&HourTen, &HourOne, 13);
    2cb2:	68 e6       	ldi	r22, 0x68	; 104
    2cb4:	70 e0       	ldi	r23, 0x00	; 0
    2cb6:	cb 01       	movw	r24, r22
    2cb8:	6f 5f       	subi	r22, 0xFF	; 255
    2cba:	7f 4f       	sbci	r23, 0xFF	; 255
    2cbc:	4d e0       	ldi	r20, 0x0D	; 13
    2cbe:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <FreshDisplayComment>
}
    2cc2:	08 95       	ret

00002cc4 <FreshDisplayBufferAjustDay>:
	FreshDisplayComment(&MonthTen, &MonthOne, 16);
}

void FreshDisplayBufferAjustDay()
{
	FreshDisplayComment(&DayTen, &DayOne, 17);
    2cc4:	66 e6       	ldi	r22, 0x66	; 102
    2cc6:	70 e0       	ldi	r23, 0x00	; 0
    2cc8:	cb 01       	movw	r24, r22
    2cca:	6f 5f       	subi	r22, 0xFF	; 255
    2ccc:	7f 4f       	sbci	r23, 0xFF	; 255
    2cce:	41 e1       	ldi	r20, 0x11	; 17
    2cd0:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <FreshDisplayComment>
}
    2cd4:	08 95       	ret

00002cd6 <FreshDisplayBufferAjustMonth>:
	FreshDisplayComment(&YearTen, &YearOne, 15);
}

void FreshDisplayBufferAjustMonth()
{
	FreshDisplayComment(&MonthTen, &MonthOne, 16);
    2cd6:	64 e6       	ldi	r22, 0x64	; 100
    2cd8:	70 e0       	ldi	r23, 0x00	; 0
    2cda:	cb 01       	movw	r24, r22
    2cdc:	6f 5f       	subi	r22, 0xFF	; 255
    2cde:	7f 4f       	sbci	r23, 0xFF	; 255
    2ce0:	40 e1       	ldi	r20, 0x10	; 16
    2ce2:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <FreshDisplayComment>
}
    2ce6:	08 95       	ret

00002ce8 <FreshDisplayBufferAjustYear>:
	writeOneChinese(6, 16, matrixIndex);
}

void FreshDisplayBufferAjustYear()
{
	FreshDisplayComment(&YearTen, &YearOne, 15);
    2ce8:	62 e6       	ldi	r22, 0x62	; 98
    2cea:	70 e0       	ldi	r23, 0x00	; 0
    2cec:	cb 01       	movw	r24, r22
    2cee:	6f 5f       	subi	r22, 0xFF	; 255
    2cf0:	7f 4f       	sbci	r23, 0xFF	; 255
    2cf2:	4f e0       	ldi	r20, 0x0F	; 15
    2cf4:	0e 94 1d 16 	call	0x2c3a	; 0x2c3a <FreshDisplayComment>
}
    2cf8:	08 95       	ret

00002cfa <Scan_Key>:

void Scan_Key()
{
    2cfa:	0f 93       	push	r16
    2cfc:	1f 93       	push	r17
    2cfe:	df 93       	push	r29
    2d00:	cf 93       	push	r28
    2d02:	0f 92       	push	r0
    2d04:	cd b7       	in	r28, 0x3d	; 61
    2d06:	de b7       	in	r29, 0x3e	; 62
	if(Mode != 0 && Mode != 27 && Mode != 26 && KEY_Time_count > 21000)
    2d08:	80 91 75 00 	lds	r24, 0x0075
    2d0c:	88 23       	and	r24, r24
    2d0e:	e9 f0       	breq	.+58     	; 0x2d4a <Scan_Key+0x50>
    2d10:	8b 31       	cpi	r24, 0x1B	; 27
    2d12:	d9 f0       	breq	.+54     	; 0x2d4a <Scan_Key+0x50>
    2d14:	8a 31       	cpi	r24, 0x1A	; 26
    2d16:	c9 f0       	breq	.+50     	; 0x2d4a <Scan_Key+0x50>
    2d18:	80 91 8b 02 	lds	r24, 0x028B
    2d1c:	90 91 8c 02 	lds	r25, 0x028C
    2d20:	89 50       	subi	r24, 0x09	; 9
    2d22:	92 45       	sbci	r25, 0x52	; 82
    2d24:	90 f0       	brcs	.+36     	; 0x2d4a <Scan_Key+0x50>
	{
		Mode = 0;
    2d26:	10 92 75 00 	sts	0x0075, r1
		//保存时间到时钟芯片
		Write_time();
    2d2a:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <Write_time>
		//保存运行参数到eepROM
		SaveRunParameter();
    2d2e:	0e 94 ab 08 	call	0x1156	; 0x1156 <SaveRunParameter>
	FreshDisplayBufferCount = 0;
}

void clearScreen()
{
	memset(display_buffer,0x00,256);
    2d32:	80 e0       	ldi	r24, 0x00	; 0
    2d34:	91 e0       	ldi	r25, 0x01	; 1
    2d36:	e1 e9       	ldi	r30, 0x91	; 145
    2d38:	f0 e0       	ldi	r31, 0x00	; 0
    2d3a:	df 01       	movw	r26, r30
    2d3c:	9c 01       	movw	r18, r24
    2d3e:	1d 92       	st	X+, r1
    2d40:	21 50       	subi	r18, 0x01	; 1
    2d42:	30 40       	sbci	r19, 0x00	; 0
    2d44:	e1 f7       	brne	.-8      	; 0x2d3e <Scan_Key+0x44>
		clearScreen(); //清屏
		FreshDisplayBufferNormal(); //加载正常走时模式
    2d46:	0e 94 d5 13 	call	0x27aa	; 0x27aa <FreshDisplayBufferNormal>
	}
	
	if(Mode == 27 || Mode == 26)
    2d4a:	80 91 75 00 	lds	r24, 0x0075
    2d4e:	8a 51       	subi	r24, 0x1A	; 26
    2d50:	82 30       	cpi	r24, 0x02	; 2
    2d52:	68 f4       	brcc	.+26     	; 0x2d6e <Scan_Key+0x74>
	{
		if(KEY_Time_count_speed_color > 500)
    2d54:	80 91 9d 02 	lds	r24, 0x029D
    2d58:	90 91 9e 02 	lds	r25, 0x029E
    2d5c:	85 5f       	subi	r24, 0xF5	; 245
    2d5e:	91 40       	sbci	r25, 0x01	; 1
    2d60:	30 f0       	brcs	.+12     	; 0x2d6e <Scan_Key+0x74>
		{
			Mode = 0;
    2d62:	10 92 75 00 	sts	0x0075, r1
			SaveRunParameter();
    2d66:	0e 94 ab 08 	call	0x1156	; 0x1156 <SaveRunParameter>
			FreshDisplayBufferNormal(); //加载正常走时模式
    2d6a:	0e 94 d5 13 	call	0x27aa	; 0x27aa <FreshDisplayBufferNormal>
		}
	}

	if(KEY_DISPLAY_COLOR_L) //显示颜色调节
    2d6e:	81 99       	sbic	0x10, 1	; 16
    2d70:	16 c0       	rjmp	.+44     	; 0x2d9e <Scan_Key+0xa4>
    2d72:	80 e2       	ldi	r24, 0x20	; 32
    2d74:	9e e4       	ldi	r25, 0x4E	; 78
    2d76:	01 97       	sbiw	r24, 0x01	; 1
    2d78:	f1 f7       	brne	.-4      	; 0x2d76 <Scan_Key+0x7c>
	{
		_delay_ms(10);
		if(KEY_DISPLAY_COLOR_L)
    2d7a:	81 99       	sbic	0x10, 1	; 16
    2d7c:	0e c0       	rjmp	.+28     	; 0x2d9a <Scan_Key+0xa0>
		{
			SPEEK_TIME_Status = 1;
    2d7e:	81 e0       	ldi	r24, 0x01	; 1
    2d80:	80 93 9f 02 	sts	0x029F, r24
			Display_color ++;
    2d84:	80 91 7a 00 	lds	r24, 0x007A
    2d88:	8f 5f       	subi	r24, 0xFF	; 255
    2d8a:	80 93 7a 00 	sts	0x007A, r24
			if(Display_color > 4)
    2d8e:	85 30       	cpi	r24, 0x05	; 5
    2d90:	10 f0       	brcs	.+4      	; 0x2d96 <Scan_Key+0x9c>
			{
				Display_color = 0;
    2d92:	10 92 7a 00 	sts	0x007A, r1
			}
			SaveRunParameter();
    2d96:	0e 94 ab 08 	call	0x1156	; 0x1156 <SaveRunParameter>
		}
		while(KEY_DISPLAY_COLOR_L);	
    2d9a:	81 9b       	sbis	0x10, 1	; 16
    2d9c:	fe cf       	rjmp	.-4      	; 0x2d9a <Scan_Key+0xa0>
	}

	if(Mode == 0 || Mode== 27 || Mode == 26) //正常运行模式 调节速度和亮度模式
    2d9e:	80 91 75 00 	lds	r24, 0x0075
    2da2:	88 23       	and	r24, r24
    2da4:	29 f0       	breq	.+10     	; 0x2db0 <Scan_Key+0xb6>
    2da6:	8b 31       	cpi	r24, 0x1B	; 27
    2da8:	19 f0       	breq	.+6      	; 0x2db0 <Scan_Key+0xb6>
    2daa:	8a 31       	cpi	r24, 0x1A	; 26
    2dac:	09 f0       	breq	.+2      	; 0x2db0 <Scan_Key+0xb6>
    2dae:	4d c0       	rjmp	.+154    	; 0x2e4a <Scan_Key+0x150>
	{

		if(KEY_UP_L) //亮度调节
    2db0:	9e 99       	sbic	0x13, 6	; 19
    2db2:	2a c0       	rjmp	.+84     	; 0x2e08 <Scan_Key+0x10e>
    2db4:	80 e2       	ldi	r24, 0x20	; 32
    2db6:	9e e4       	ldi	r25, 0x4E	; 78
    2db8:	01 97       	sbiw	r24, 0x01	; 1
    2dba:	f1 f7       	brne	.-4      	; 0x2db8 <Scan_Key+0xbe>
		{
			_delay_ms(10);
			if(KEY_UP_L)
    2dbc:	9e 99       	sbic	0x13, 6	; 19
    2dbe:	22 c0       	rjmp	.+68     	; 0x2e04 <Scan_Key+0x10a>
			{
				SPEEK_TIME_Status = 100; //按键音
    2dc0:	84 e6       	ldi	r24, 0x64	; 100
    2dc2:	80 93 9f 02 	sts	0x029F, r24
				if(display_light_Mode) //手动调节亮度模式
    2dc6:	80 91 72 00 	lds	r24, 0x0072
    2dca:	88 23       	and	r24, r24
    2dcc:	91 f0       	breq	.+36     	; 0x2df2 <Scan_Key+0xf8>
				{
					display_light ++;
    2dce:	80 91 73 00 	lds	r24, 0x0073
    2dd2:	8f 5f       	subi	r24, 0xFF	; 255
    2dd4:	80 93 73 00 	sts	0x0073, r24
					if(display_light > 8)
    2dd8:	89 30       	cpi	r24, 0x09	; 9
    2dda:	18 f0       	brcs	.+6      	; 0x2de2 <Scan_Key+0xe8>
					{
						display_light = 1;
    2ddc:	81 e0       	ldi	r24, 0x01	; 1
    2dde:	80 93 73 00 	sts	0x0073, r24
					}
					SET_DISPLAY_LIGHT;//OCR0置初值,占空比50%，调整OCR0的值用来调整占空比
    2de2:	80 91 73 00 	lds	r24, 0x0073
    2de6:	29 e1       	ldi	r18, 0x19	; 25
    2de8:	82 9f       	mul	r24, r18
    2dea:	c0 01       	movw	r24, r0
    2dec:	11 24       	eor	r1, r1
    2dee:	88 51       	subi	r24, 0x18	; 24
    2df0:	8c bf       	out	0x3c, r24	; 60
				}
				else //自动调节亮度模式
				{
				
				}
				Mode = 27;
    2df2:	8b e1       	ldi	r24, 0x1B	; 27
    2df4:	80 93 75 00 	sts	0x0075, r24
				KEY_Time_count_speed_color = 0;
    2df8:	10 92 9e 02 	sts	0x029E, r1
    2dfc:	10 92 9d 02 	sts	0x029D, r1
				FreshDisplayBufferAjustLight();
    2e00:	0e 94 36 15 	call	0x2a6c	; 0x2a6c <FreshDisplayBufferAjustLight>
			}
			while(KEY_UP_L);	
    2e04:	9e 9b       	sbis	0x13, 6	; 19
    2e06:	fe cf       	rjmp	.-4      	; 0x2e04 <Scan_Key+0x10a>
		}
	
		if(KEY_DOWN_L) //速度调节
    2e08:	9f 99       	sbic	0x13, 7	; 19
    2e0a:	d7 c0       	rjmp	.+430    	; 0x2fba <Scan_Key+0x2c0>
    2e0c:	80 e2       	ldi	r24, 0x20	; 32
    2e0e:	9e e4       	ldi	r25, 0x4E	; 78
    2e10:	01 97       	sbiw	r24, 0x01	; 1
    2e12:	f1 f7       	brne	.-4      	; 0x2e10 <Scan_Key+0x116>
		{
			_delay_ms(10);
			if(KEY_DOWN_L)
    2e14:	9f 99       	sbic	0x13, 7	; 19
    2e16:	16 c0       	rjmp	.+44     	; 0x2e44 <Scan_Key+0x14a>
			{
				SPEEK_TIME_Status = 100; //按键音
    2e18:	84 e6       	ldi	r24, 0x64	; 100
    2e1a:	80 93 9f 02 	sts	0x029F, r24
				moveSpeed ++;
    2e1e:	80 91 74 00 	lds	r24, 0x0074
    2e22:	8f 5f       	subi	r24, 0xFF	; 255
    2e24:	80 93 74 00 	sts	0x0074, r24
				if(moveSpeed > 8)
    2e28:	89 30       	cpi	r24, 0x09	; 9
    2e2a:	18 f0       	brcs	.+6      	; 0x2e32 <Scan_Key+0x138>
				{
					moveSpeed = 1;
    2e2c:	81 e0       	ldi	r24, 0x01	; 1
    2e2e:	80 93 74 00 	sts	0x0074, r24
				}
				Mode = 26;
    2e32:	8a e1       	ldi	r24, 0x1A	; 26
    2e34:	80 93 75 00 	sts	0x0075, r24
				KEY_Time_count_speed_color = 0;
    2e38:	10 92 9e 02 	sts	0x029E, r1
    2e3c:	10 92 9d 02 	sts	0x029D, r1
				FreshDisplayBufferAjustSpeed();
    2e40:	0e 94 bb 15 	call	0x2b76	; 0x2b76 <FreshDisplayBufferAjustSpeed>
			}
			while(KEY_DOWN_L);	
    2e44:	9f 9b       	sbis	0x13, 7	; 19
    2e46:	fe cf       	rjmp	.-4      	; 0x2e44 <Scan_Key+0x14a>
    2e48:	b8 c0       	rjmp	.+368    	; 0x2fba <Scan_Key+0x2c0>
		}
	}
	else if(Mode == 1) //调节年
    2e4a:	81 30       	cpi	r24, 0x01	; 1
    2e4c:	49 f4       	brne	.+18     	; 0x2e60 <Scan_Key+0x166>
	{
		Key_Operation(99, 0, &YearTen, &YearOne, &FreshDisplayBufferAjustYear);
    2e4e:	83 e6       	ldi	r24, 0x63	; 99
    2e50:	60 e0       	ldi	r22, 0x00	; 0
    2e52:	42 e6       	ldi	r20, 0x62	; 98
    2e54:	50 e0       	ldi	r21, 0x00	; 0
    2e56:	23 e6       	ldi	r18, 0x63	; 99
    2e58:	30 e0       	ldi	r19, 0x00	; 0
    2e5a:	04 e7       	ldi	r16, 0x74	; 116
    2e5c:	16 e1       	ldi	r17, 0x16	; 22
    2e5e:	ab c0       	rjmp	.+342    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 2) //调节月
    2e60:	82 30       	cpi	r24, 0x02	; 2
    2e62:	49 f4       	brne	.+18     	; 0x2e76 <Scan_Key+0x17c>
	{
		Key_Operation(12, 1, &MonthTen, &MonthOne, &FreshDisplayBufferAjustMonth);
    2e64:	8c e0       	ldi	r24, 0x0C	; 12
    2e66:	61 e0       	ldi	r22, 0x01	; 1
    2e68:	44 e6       	ldi	r20, 0x64	; 100
    2e6a:	50 e0       	ldi	r21, 0x00	; 0
    2e6c:	25 e6       	ldi	r18, 0x65	; 101
    2e6e:	30 e0       	ldi	r19, 0x00	; 0
    2e70:	0b e6       	ldi	r16, 0x6B	; 107
    2e72:	16 e1       	ldi	r17, 0x16	; 22
    2e74:	a0 c0       	rjmp	.+320    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 3) //调节日
    2e76:	83 30       	cpi	r24, 0x03	; 3
    2e78:	49 f4       	brne	.+18     	; 0x2e8c <Scan_Key+0x192>
	{
		Key_Operation(31, 1, &DayTen, &DayOne, &FreshDisplayBufferAjustDay);
    2e7a:	8f e1       	ldi	r24, 0x1F	; 31
    2e7c:	61 e0       	ldi	r22, 0x01	; 1
    2e7e:	46 e6       	ldi	r20, 0x66	; 102
    2e80:	50 e0       	ldi	r21, 0x00	; 0
    2e82:	27 e6       	ldi	r18, 0x67	; 103
    2e84:	30 e0       	ldi	r19, 0x00	; 0
    2e86:	02 e6       	ldi	r16, 0x62	; 98
    2e88:	16 e1       	ldi	r17, 0x16	; 22
    2e8a:	95 c0       	rjmp	.+298    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 4) //调节时
    2e8c:	84 30       	cpi	r24, 0x04	; 4
    2e8e:	49 f4       	brne	.+18     	; 0x2ea2 <Scan_Key+0x1a8>
	{
		Key_Operation(23, 0, &HourTen, &HourOne, &FreshDisplayBufferAjustHour);
    2e90:	87 e1       	ldi	r24, 0x17	; 23
    2e92:	60 e0       	ldi	r22, 0x00	; 0
    2e94:	48 e6       	ldi	r20, 0x68	; 104
    2e96:	50 e0       	ldi	r21, 0x00	; 0
    2e98:	29 e6       	ldi	r18, 0x69	; 105
    2e9a:	30 e0       	ldi	r19, 0x00	; 0
    2e9c:	09 e5       	ldi	r16, 0x59	; 89
    2e9e:	16 e1       	ldi	r17, 0x16	; 22
    2ea0:	8a c0       	rjmp	.+276    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 5) //调节分
    2ea2:	85 30       	cpi	r24, 0x05	; 5
    2ea4:	49 f4       	brne	.+18     	; 0x2eb8 <Scan_Key+0x1be>
	{
		Key_Operation(59, 0, &MinuteTen, &MinuteOne, &FreshDisplayBufferAjustMinute);
    2ea6:	8b e3       	ldi	r24, 0x3B	; 59
    2ea8:	60 e0       	ldi	r22, 0x00	; 0
    2eaa:	4a e6       	ldi	r20, 0x6A	; 106
    2eac:	50 e0       	ldi	r21, 0x00	; 0
    2eae:	2b e6       	ldi	r18, 0x6B	; 107
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	00 e5       	ldi	r16, 0x50	; 80
    2eb4:	16 e1       	ldi	r17, 0x16	; 22
    2eb6:	7f c0       	rjmp	.+254    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 6) //调节星期
    2eb8:	86 30       	cpi	r24, 0x06	; 6
    2eba:	59 f4       	brne	.+22     	; 0x2ed2 <Scan_Key+0x1d8>
	{
		uint8 temp = 0;
    2ebc:	19 82       	std	Y+1, r1	; 0x01
		Key_Operation(7, 1, &temp, &Week, &FreshDisplayBufferAjustWeek);
    2ebe:	87 e0       	ldi	r24, 0x07	; 7
    2ec0:	61 e0       	ldi	r22, 0x01	; 1
    2ec2:	ae 01       	movw	r20, r28
    2ec4:	4f 5f       	subi	r20, 0xFF	; 255
    2ec6:	5f 4f       	sbci	r21, 0xFF	; 255
    2ec8:	2e e6       	ldi	r18, 0x6E	; 110
    2eca:	30 e0       	ldi	r19, 0x00	; 0
    2ecc:	0c ee       	ldi	r16, 0xEC	; 236
    2ece:	15 e1       	ldi	r17, 0x15	; 21
    2ed0:	72 c0       	rjmp	.+228    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 7) //调节亮度模式
    2ed2:	87 30       	cpi	r24, 0x07	; 7
    2ed4:	59 f4       	brne	.+22     	; 0x2eec <Scan_Key+0x1f2>
	{
		uint8 temp = 0;
    2ed6:	19 82       	std	Y+1, r1	; 0x01
		Key_Operation(1, 0, &temp, &display_light_Mode, &FreshDisplayBufferAjustLightMode);
    2ed8:	81 e0       	ldi	r24, 0x01	; 1
    2eda:	60 e0       	ldi	r22, 0x00	; 0
    2edc:	ae 01       	movw	r20, r28
    2ede:	4f 5f       	subi	r20, 0xFF	; 255
    2ee0:	5f 4f       	sbci	r21, 0xFF	; 255
    2ee2:	22 e7       	ldi	r18, 0x72	; 114
    2ee4:	30 e0       	ldi	r19, 0x00	; 0
    2ee6:	09 ef       	ldi	r16, 0xF9	; 249
    2ee8:	14 e1       	ldi	r17, 0x14	; 20
    2eea:	65 c0       	rjmp	.+202    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 8) //设置字体
    2eec:	88 30       	cpi	r24, 0x08	; 8
    2eee:	59 f4       	brne	.+22     	; 0x2f06 <Scan_Key+0x20c>
	{
		uint8 temp = 0;
    2ef0:	19 82       	std	Y+1, r1	; 0x01
		Key_Operation(2, 0, &temp, &Display_BigNumber_Font, &FreshDisplayBufferChangeFont);
    2ef2:	82 e0       	ldi	r24, 0x02	; 2
    2ef4:	60 e0       	ldi	r22, 0x00	; 0
    2ef6:	ae 01       	movw	r20, r28
    2ef8:	4f 5f       	subi	r20, 0xFF	; 255
    2efa:	5f 4f       	sbci	r21, 0xFF	; 255
    2efc:	2b e7       	ldi	r18, 0x7B	; 123
    2efe:	30 e0       	ldi	r19, 0x00	; 0
    2f00:	09 ec       	ldi	r16, 0xC9	; 201
    2f02:	14 e1       	ldi	r17, 0x14	; 20
    2f04:	58 c0       	rjmp	.+176    	; 0x2fb6 <Scan_Key+0x2bc>
	}
	else if(Mode == 9) //调节校对时间
    2f06:	89 30       	cpi	r24, 0x09	; 9
    2f08:	09 f0       	breq	.+2      	; 0x2f0c <Scan_Key+0x212>
    2f0a:	49 c0       	rjmp	.+146    	; 0x2f9e <Scan_Key+0x2a4>
	{
		if(KEY_UP_L) 
    2f0c:	9e 99       	sbic	0x13, 6	; 19
    2f0e:	29 c0       	rjmp	.+82     	; 0x2f62 <Scan_Key+0x268>
    2f10:	80 e2       	ldi	r24, 0x20	; 32
    2f12:	9e e4       	ldi	r25, 0x4E	; 78
    2f14:	01 97       	sbiw	r24, 0x01	; 1
    2f16:	f1 f7       	brne	.-4      	; 0x2f14 <Scan_Key+0x21a>
		{
			_delay_ms(10);
			if(KEY_UP_L)
    2f18:	9e 99       	sbic	0x13, 6	; 19
    2f1a:	21 c0       	rjmp	.+66     	; 0x2f5e <Scan_Key+0x264>
			{
				KEY_Time_count = 0;
    2f1c:	10 92 8c 02 	sts	0x028C, r1
    2f20:	10 92 8b 02 	sts	0x028B, r1
				SPEEK_TIME_Status = 100; //按键音
    2f24:	84 e6       	ldi	r24, 0x64	; 100
    2f26:	80 93 9f 02 	sts	0x029F, r24
				uint8 value = AjustTimeTen*10 + AjustTimeOne;
    2f2a:	30 91 78 00 	lds	r19, 0x0078
    2f2e:	3f 5f       	subi	r19, 0xFF	; 255
				value ++;
    2f30:	80 91 77 00 	lds	r24, 0x0077
    2f34:	2a e0       	ldi	r18, 0x0A	; 10
    2f36:	82 9f       	mul	r24, r18
    2f38:	c0 01       	movw	r24, r0
    2f3a:	11 24       	eor	r1, r1
    2f3c:	38 0f       	add	r19, r24
				if(value > 20)
    2f3e:	35 31       	cpi	r19, 0x15	; 21
    2f40:	08 f0       	brcs	.+2      	; 0x2f44 <Scan_Key+0x24a>
    2f42:	30 e0       	ldi	r19, 0x00	; 0
				{
					value = 0;
				}
				AjustTimeTen = value/10;
    2f44:	83 2f       	mov	r24, r19
    2f46:	6a e0       	ldi	r22, 0x0A	; 10
    2f48:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    2f4c:	80 93 77 00 	sts	0x0077, r24
				AjustTimeOne = value%10;
    2f50:	83 2f       	mov	r24, r19
    2f52:	0e 94 ea 18 	call	0x31d4	; 0x31d4 <__udivmodqi4>
    2f56:	90 93 78 00 	sts	0x0078, r25
				FreshDisplayBufferAjustProofTime();
    2f5a:	0e 94 5f 14 	call	0x28be	; 0x28be <FreshDisplayBufferAjustProofTime>
			}
			while(KEY_UP_L);	
    2f5e:	9e 9b       	sbis	0x13, 6	; 19
    2f60:	fe cf       	rjmp	.-4      	; 0x2f5e <Scan_Key+0x264>
		}
		if(KEY_DOWN_L) 
    2f62:	9f 99       	sbic	0x13, 7	; 19
    2f64:	2a c0       	rjmp	.+84     	; 0x2fba <Scan_Key+0x2c0>
    2f66:	80 e2       	ldi	r24, 0x20	; 32
    2f68:	9e e4       	ldi	r25, 0x4E	; 78
    2f6a:	01 97       	sbiw	r24, 0x01	; 1
    2f6c:	f1 f7       	brne	.-4      	; 0x2f6a <Scan_Key+0x270>
		{
			_delay_ms(10);
			if(KEY_DOWN_L)
    2f6e:	9f 99       	sbic	0x13, 7	; 19
    2f70:	13 c0       	rjmp	.+38     	; 0x2f98 <Scan_Key+0x29e>
			{
				KEY_Time_count = 0;
    2f72:	10 92 8c 02 	sts	0x028C, r1
    2f76:	10 92 8b 02 	sts	0x028B, r1
				SPEEK_TIME_Status = 100; //按键音
    2f7a:	84 e6       	ldi	r24, 0x64	; 100
    2f7c:	80 93 9f 02 	sts	0x029F, r24
				if(AjustTimeMode)
    2f80:	80 91 76 00 	lds	r24, 0x0076
    2f84:	88 23       	and	r24, r24
    2f86:	19 f0       	breq	.+6      	; 0x2f8e <Scan_Key+0x294>
				{
					AjustTimeMode = 0;
    2f88:	10 92 76 00 	sts	0x0076, r1
    2f8c:	03 c0       	rjmp	.+6      	; 0x2f94 <Scan_Key+0x29a>
				}
				else
				{
					AjustTimeMode = 1;
    2f8e:	81 e0       	ldi	r24, 0x01	; 1
    2f90:	80 93 76 00 	sts	0x0076, r24
				}
				FreshDisplayBufferAjustProofTime();
    2f94:	0e 94 5f 14 	call	0x28be	; 0x28be <FreshDisplayBufferAjustProofTime>
			}
			while(KEY_DOWN_L);	
    2f98:	9f 9b       	sbis	0x13, 7	; 19
    2f9a:	fe cf       	rjmp	.-4      	; 0x2f98 <Scan_Key+0x29e>
    2f9c:	0e c0       	rjmp	.+28     	; 0x2fba <Scan_Key+0x2c0>
		}
	}
	else if(Mode == 10) //报时
    2f9e:	8a 30       	cpi	r24, 0x0A	; 10
    2fa0:	61 f4       	brne	.+24     	; 0x2fba <Scan_Key+0x2c0>
	{
		uint8 temp = 0;
    2fa2:	19 82       	std	Y+1, r1	; 0x01
		Key_Operation(2, 0, &temp, &Voice_Mode, &FreshDisplayBufferVoiceMode);
    2fa4:	82 e0       	ldi	r24, 0x02	; 2
    2fa6:	60 e0       	ldi	r22, 0x00	; 0
    2fa8:	ae 01       	movw	r20, r28
    2faa:	4f 5f       	subi	r20, 0xFF	; 255
    2fac:	5f 4f       	sbci	r21, 0xFF	; 255
    2fae:	2c e7       	ldi	r18, 0x7C	; 124
    2fb0:	30 e0       	ldi	r19, 0x00	; 0
    2fb2:	0e e6       	ldi	r16, 0x6E	; 110
    2fb4:	15 e1       	ldi	r17, 0x15	; 21
    2fb6:	0e 94 06 12 	call	0x240c	; 0x240c <Key_Operation>
	}
	//////////////////////////////////////////////////////////
	if(KEY_MODE_L) //模式调节
    2fba:	80 99       	sbic	0x10, 0	; 16
    2fbc:	69 c0       	rjmp	.+210    	; 0x3090 <Scan_Key+0x396>
    2fbe:	80 e2       	ldi	r24, 0x20	; 32
    2fc0:	9e e4       	ldi	r25, 0x4E	; 78
    2fc2:	01 97       	sbiw	r24, 0x01	; 1
    2fc4:	f1 f7       	brne	.-4      	; 0x2fc2 <Scan_Key+0x2c8>
	{
		_delay_ms(10);
		if(KEY_MODE_L)
    2fc6:	80 99       	sbic	0x10, 0	; 16
    2fc8:	61 c0       	rjmp	.+194    	; 0x308c <Scan_Key+0x392>
		{
			SPEEK_TIME_Status = 100; //按键音
    2fca:	84 e6       	ldi	r24, 0x64	; 100
    2fcc:	80 93 9f 02 	sts	0x029F, r24
			KEY_Time_count = 0;
    2fd0:	10 92 8c 02 	sts	0x028C, r1
    2fd4:	10 92 8b 02 	sts	0x028B, r1
			Mode ++;
    2fd8:	80 91 75 00 	lds	r24, 0x0075
    2fdc:	8f 5f       	subi	r24, 0xFF	; 255
    2fde:	80 93 75 00 	sts	0x0075, r24
			if(Mode > 10)
    2fe2:	8b 30       	cpi	r24, 0x0B	; 11
    2fe4:	10 f0       	brcs	.+4      	; 0x2fea <Scan_Key+0x2f0>
			{
				Mode = 0;
    2fe6:	10 92 75 00 	sts	0x0075, r1
			}
			switch(Mode){
    2fea:	80 91 75 00 	lds	r24, 0x0075
    2fee:	85 30       	cpi	r24, 0x05	; 5
    2ff0:	e1 f1       	breq	.+120    	; 0x306a <Scan_Key+0x370>
    2ff2:	86 30       	cpi	r24, 0x06	; 6
    2ff4:	78 f4       	brcc	.+30     	; 0x3014 <Scan_Key+0x31a>
    2ff6:	82 30       	cpi	r24, 0x02	; 2
    2ff8:	79 f1       	breq	.+94     	; 0x3058 <Scan_Key+0x35e>
    2ffa:	83 30       	cpi	r24, 0x03	; 3
    2ffc:	30 f4       	brcc	.+12     	; 0x300a <Scan_Key+0x310>
    2ffe:	88 23       	and	r24, r24
    3000:	b9 f0       	breq	.+46     	; 0x3030 <Scan_Key+0x336>
    3002:	81 30       	cpi	r24, 0x01	; 1
    3004:	09 f0       	breq	.+2      	; 0x3008 <Scan_Key+0x30e>
    3006:	42 c0       	rjmp	.+132    	; 0x308c <Scan_Key+0x392>
    3008:	24 c0       	rjmp	.+72     	; 0x3052 <Scan_Key+0x358>
    300a:	83 30       	cpi	r24, 0x03	; 3
    300c:	41 f1       	breq	.+80     	; 0x305e <Scan_Key+0x364>
    300e:	84 30       	cpi	r24, 0x04	; 4
    3010:	e9 f5       	brne	.+122    	; 0x308c <Scan_Key+0x392>
    3012:	28 c0       	rjmp	.+80     	; 0x3064 <Scan_Key+0x36a>
    3014:	88 30       	cpi	r24, 0x08	; 8
    3016:	91 f1       	breq	.+100    	; 0x307c <Scan_Key+0x382>
    3018:	89 30       	cpi	r24, 0x09	; 9
    301a:	28 f4       	brcc	.+10     	; 0x3026 <Scan_Key+0x32c>
    301c:	86 30       	cpi	r24, 0x06	; 6
    301e:	41 f1       	breq	.+80     	; 0x3070 <Scan_Key+0x376>
    3020:	87 30       	cpi	r24, 0x07	; 7
    3022:	a1 f5       	brne	.+104    	; 0x308c <Scan_Key+0x392>
    3024:	28 c0       	rjmp	.+80     	; 0x3076 <Scan_Key+0x37c>
    3026:	89 30       	cpi	r24, 0x09	; 9
    3028:	61 f1       	breq	.+88     	; 0x3082 <Scan_Key+0x388>
    302a:	8a 30       	cpi	r24, 0x0A	; 10
    302c:	79 f5       	brne	.+94     	; 0x308c <Scan_Key+0x392>
    302e:	2c c0       	rjmp	.+88     	; 0x3088 <Scan_Key+0x38e>
				case 0:	//正常运行
					//保存时间到时钟芯片
					Write_time();
    3030:	0e 94 01 0f 	call	0x1e02	; 0x1e02 <Write_time>
					//保存运行参数到eepROM
					SaveRunParameter();
    3034:	0e 94 ab 08 	call	0x1156	; 0x1156 <SaveRunParameter>
    3038:	80 e0       	ldi	r24, 0x00	; 0
    303a:	91 e0       	ldi	r25, 0x01	; 1
    303c:	e1 e9       	ldi	r30, 0x91	; 145
    303e:	f0 e0       	ldi	r31, 0x00	; 0
    3040:	df 01       	movw	r26, r30
    3042:	9c 01       	movw	r18, r24
    3044:	1d 92       	st	X+, r1
    3046:	21 50       	subi	r18, 0x01	; 1
    3048:	30 40       	sbci	r19, 0x00	; 0
    304a:	e1 f7       	brne	.-8      	; 0x3044 <Scan_Key+0x34a>
					clearScreen(); //清屏
					FreshDisplayBufferNormal(); //加载正常走时模式
    304c:	0e 94 d5 13 	call	0x27aa	; 0x27aa <FreshDisplayBufferNormal>
    3050:	1d c0       	rjmp	.+58     	; 0x308c <Scan_Key+0x392>
					break; 
				case 1:	//调节年
					FreshDisplayBufferAjustYear();
    3052:	0e 94 74 16 	call	0x2ce8	; 0x2ce8 <FreshDisplayBufferAjustYear>
    3056:	1a c0       	rjmp	.+52     	; 0x308c <Scan_Key+0x392>
					break; 
				case 2:	//调节月
					FreshDisplayBufferAjustMonth();
    3058:	0e 94 6b 16 	call	0x2cd6	; 0x2cd6 <FreshDisplayBufferAjustMonth>
    305c:	17 c0       	rjmp	.+46     	; 0x308c <Scan_Key+0x392>
					break; 
				case 3:	//调节日
					FreshDisplayBufferAjustDay();
    305e:	0e 94 62 16 	call	0x2cc4	; 0x2cc4 <FreshDisplayBufferAjustDay>
    3062:	14 c0       	rjmp	.+40     	; 0x308c <Scan_Key+0x392>
					break; 
				case 4:	//调节时
					FreshDisplayBufferAjustHour();
    3064:	0e 94 59 16 	call	0x2cb2	; 0x2cb2 <FreshDisplayBufferAjustHour>
    3068:	11 c0       	rjmp	.+34     	; 0x308c <Scan_Key+0x392>
					break; 
				case 5:	//调节分
					FreshDisplayBufferAjustMinute();
    306a:	0e 94 50 16 	call	0x2ca0	; 0x2ca0 <FreshDisplayBufferAjustMinute>
    306e:	0e c0       	rjmp	.+28     	; 0x308c <Scan_Key+0x392>
					break;
				case 6:	//调节星期
					FreshDisplayBufferAjustWeek();
    3070:	0e 94 ec 15 	call	0x2bd8	; 0x2bd8 <FreshDisplayBufferAjustWeek>
    3074:	0b c0       	rjmp	.+22     	; 0x308c <Scan_Key+0x392>
					break;  
				case 7:	//调节亮度模式
					FreshDisplayBufferAjustLightMode();
    3076:	0e 94 f9 14 	call	0x29f2	; 0x29f2 <FreshDisplayBufferAjustLightMode>
    307a:	08 c0       	rjmp	.+16     	; 0x308c <Scan_Key+0x392>
					break;
				case 8:	//设置字体
					FreshDisplayBufferChangeFont();
    307c:	0e 94 c9 14 	call	0x2992	; 0x2992 <FreshDisplayBufferChangeFont>
    3080:	05 c0       	rjmp	.+10     	; 0x308c <Scan_Key+0x392>
					break;
				case 9:	//调节校队时间
					FreshDisplayBufferAjustProofTime();
    3082:	0e 94 5f 14 	call	0x28be	; 0x28be <FreshDisplayBufferAjustProofTime>
    3086:	02 c0       	rjmp	.+4      	; 0x308c <Scan_Key+0x392>
					break; 
				case 10://调节语音报时
					FreshDisplayBufferVoiceMode();
    3088:	0e 94 6e 15 	call	0x2adc	; 0x2adc <FreshDisplayBufferVoiceMode>
					break;
				default:
					break; 
			} 
		}
		while(KEY_MODE_L);	
    308c:	80 9b       	sbis	0x10, 0	; 16
    308e:	fe cf       	rjmp	.-4      	; 0x308c <Scan_Key+0x392>
	}
}
    3090:	0f 90       	pop	r0
    3092:	cf 91       	pop	r28
    3094:	df 91       	pop	r29
    3096:	1f 91       	pop	r17
    3098:	0f 91       	pop	r16
    309a:	08 95       	ret

0000309c <main>:

int main()
{
    309c:	0f 93       	push	r16
    309e:	1f 93       	push	r17
	uint8 currentlyHourVoice;//当前小时数，用于语音报时
	init_devices();
    30a0:	0e 94 4c 13 	call	0x2698	; 0x2698 <init_devices>
	ds1820_start();   
    30a4:	0e 94 42 08 	call	0x1084	; 0x1084 <ds1820_start>
	_delay_100ms(6);   
	ReadTemputer();
    30a8:	0e 94 4b 08 	call	0x1096	; 0x1096 <ReadTemputer>
	if(KEY_MODE_L) //判断是否加载初始化参数
    30ac:	80 99       	sbic	0x10, 0	; 16
    30ae:	1c c0       	rjmp	.+56     	; 0x30e8 <main+0x4c>
    30b0:	80 e2       	ldi	r24, 0x20	; 32
    30b2:	9e e4       	ldi	r25, 0x4E	; 78
    30b4:	01 97       	sbiw	r24, 0x01	; 1
    30b6:	f1 f7       	brne	.-4      	; 0x30b4 <main+0x18>
	{
		_delay_ms(10);
		if(KEY_MODE_L)
    30b8:	80 99       	sbic	0x10, 0	; 16
    30ba:	16 c0       	rjmp	.+44     	; 0x30e8 <main+0x4c>
		{
			display_light_Mode = 	1;
    30bc:	81 e0       	ldi	r24, 0x01	; 1
    30be:	80 93 72 00 	sts	0x0072, r24
			display_light = 		1;
    30c2:	80 93 73 00 	sts	0x0073, r24
			moveSpeed = 			1;
    30c6:	80 93 74 00 	sts	0x0074, r24
			Mode = 					0;
    30ca:	10 92 75 00 	sts	0x0075, r1
			AjustTimeMode = 		0;
    30ce:	10 92 76 00 	sts	0x0076, r1
			AjustTimeTen = 			0;
    30d2:	10 92 77 00 	sts	0x0077, r1
			AjustTimeOne = 			0;	
    30d6:	10 92 78 00 	sts	0x0078, r1
			Display_color = 		0;
    30da:	10 92 7a 00 	sts	0x007A, r1
			Display_BigNumber_Font = 0;
    30de:	10 92 7b 00 	sts	0x007B, r1
			SET_DISPLAY_LIGHT;
    30e2:	8c bf       	out	0x3c, r24	; 60
			SaveRunParameter();
    30e4:	0e 94 ab 08 	call	0x1156	; 0x1156 <SaveRunParameter>
		}
	}
	ReadRunParameter();
    30e8:	0e 94 47 09 	call	0x128e	; 0x128e <ReadRunParameter>
	Show_welcome();
    30ec:	0e 94 90 13 	call	0x2720	; 0x2720 <Show_welcome>
	Updata_time();
    30f0:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <Updata_time>
	FreshDisplayBufferNormal();
    30f4:	0e 94 d5 13 	call	0x27aa	; 0x27aa <FreshDisplayBufferNormal>
	SPEEK_TIME_Status = 1;
    30f8:	81 e0       	ldi	r24, 0x01	; 1
    30fa:	80 93 9f 02 	sts	0x029F, r24
				}
			}
			else if(Voice_Mode == 1) //勿扰模式
			{
				currentlyHourVoice = HourTen*10 + HourOne;
				if(currentlyHourVoice > 6 && currentlyHourVoice <= 23)
    30fe:	0a e0       	ldi	r16, 0x0A	; 10
			//语音报时开始
			if(Voice_Mode == 0)//正常模式
			{
				if(MinuteTen == 0 && MinuteOne == 0 && SecondTen == 0 && SecondOne < 10 && inVoice == 0)
				{
					inVoice = 1;
    3100:	11 e0       	ldi	r17, 0x01	; 1
	FreshDisplayBufferNormal();
	SPEEK_TIME_Status = 1;
	while(1)
	{
		//675 us 0.000675s
		if( Mode == 0)
    3102:	80 91 75 00 	lds	r24, 0x0075
    3106:	88 23       	and	r24, r24
    3108:	09 f0       	breq	.+2      	; 0x310c <main+0x70>
    310a:	58 c0       	rjmp	.+176    	; 0x31bc <main+0x120>
		{
			Updata_time();
    310c:	0e 94 a6 0e 	call	0x1d4c	; 0x1d4c <Updata_time>
			//语音报时开始
			if(Voice_Mode == 0)//正常模式
    3110:	30 91 7c 00 	lds	r19, 0x007C
    3114:	33 23       	and	r19, r19
    3116:	c9 f4       	brne	.+50     	; 0x314a <main+0xae>
			{
				if(MinuteTen == 0 && MinuteOne == 0 && SecondTen == 0 && SecondOne < 10 && inVoice == 0)
    3118:	80 91 6a 00 	lds	r24, 0x006A
    311c:	88 23       	and	r24, r24
    311e:	d1 f5       	brne	.+116    	; 0x3194 <main+0xf8>
    3120:	80 91 6b 00 	lds	r24, 0x006B
    3124:	88 23       	and	r24, r24
    3126:	b1 f5       	brne	.+108    	; 0x3194 <main+0xf8>
    3128:	80 91 6c 00 	lds	r24, 0x006C
    312c:	88 23       	and	r24, r24
    312e:	91 f5       	brne	.+100    	; 0x3194 <main+0xf8>
    3130:	80 91 6d 00 	lds	r24, 0x006D
    3134:	8a 30       	cpi	r24, 0x0A	; 10
    3136:	70 f5       	brcc	.+92     	; 0x3194 <main+0xf8>
    3138:	80 91 99 02 	lds	r24, 0x0299
    313c:	88 23       	and	r24, r24
    313e:	51 f5       	brne	.+84     	; 0x3194 <main+0xf8>
				{
					inVoice = 1;
    3140:	10 93 99 02 	sts	0x0299, r17
					SPEEK_TIME_Status = 1;
    3144:	10 93 9f 02 	sts	0x029F, r17
    3148:	25 c0       	rjmp	.+74     	; 0x3194 <main+0xf8>
				}
			}
			else if(Voice_Mode == 1) //勿扰模式
    314a:	31 30       	cpi	r19, 0x01	; 1
    314c:	19 f5       	brne	.+70     	; 0x3194 <main+0xf8>
			{
				currentlyHourVoice = HourTen*10 + HourOne;
				if(currentlyHourVoice > 6 && currentlyHourVoice <= 23)
    314e:	20 91 69 00 	lds	r18, 0x0069
    3152:	27 50       	subi	r18, 0x07	; 7
    3154:	80 91 68 00 	lds	r24, 0x0068
    3158:	80 9f       	mul	r24, r16
    315a:	c0 01       	movw	r24, r0
    315c:	11 24       	eor	r1, r1
    315e:	28 0f       	add	r18, r24
    3160:	21 31       	cpi	r18, 0x11	; 17
    3162:	c0 f4       	brcc	.+48     	; 0x3194 <main+0xf8>
				{
					if(MinuteTen == 0 && MinuteOne == 0 && SecondTen == 0 && SecondOne < 10 && inVoice == 0)
    3164:	80 91 6a 00 	lds	r24, 0x006A
    3168:	88 23       	and	r24, r24
    316a:	a1 f4       	brne	.+40     	; 0x3194 <main+0xf8>
    316c:	80 91 6b 00 	lds	r24, 0x006B
    3170:	88 23       	and	r24, r24
    3172:	81 f4       	brne	.+32     	; 0x3194 <main+0xf8>
    3174:	80 91 6c 00 	lds	r24, 0x006C
    3178:	88 23       	and	r24, r24
    317a:	61 f4       	brne	.+24     	; 0x3194 <main+0xf8>
    317c:	80 91 6d 00 	lds	r24, 0x006D
    3180:	8a 30       	cpi	r24, 0x0A	; 10
    3182:	40 f4       	brcc	.+16     	; 0x3194 <main+0xf8>
    3184:	80 91 99 02 	lds	r24, 0x0299
    3188:	88 23       	and	r24, r24
    318a:	21 f4       	brne	.+8      	; 0x3194 <main+0xf8>
					{
						inVoice = 1;
    318c:	30 93 99 02 	sts	0x0299, r19
						SPEEK_TIME_Status = 1;
    3190:	30 93 9f 02 	sts	0x029F, r19
			else //关闭模式
			{
			
			}
			//语音报时结束
			FreshDisplayBufferCount ++;
    3194:	80 91 9a 02 	lds	r24, 0x029A
    3198:	90 91 9b 02 	lds	r25, 0x029B
    319c:	01 96       	adiw	r24, 0x01	; 1
    319e:	90 93 9b 02 	sts	0x029B, r25
    31a2:	80 93 9a 02 	sts	0x029A, r24
			if(FreshDisplayBufferCount > 10000)
    31a6:	81 51       	subi	r24, 0x11	; 17
    31a8:	97 42       	sbci	r25, 0x27	; 39
    31aa:	40 f0       	brcs	.+16     	; 0x31bc <main+0x120>
			{
				AjustTimerMonthly();
    31ac:	0e 94 50 0f 	call	0x1ea0	; 0x1ea0 <AjustTimerMonthly>
				FreshDisplayBufferNormal();
    31b0:	0e 94 d5 13 	call	0x27aa	; 0x27aa <FreshDisplayBufferNormal>
				FreshDisplayBufferCount = 0;
    31b4:	10 92 9b 02 	sts	0x029B, r1
    31b8:	10 92 9a 02 	sts	0x029A, r1
			}	
		}
		display();	
    31bc:	0e 94 ae 0b 	call	0x175c	; 0x175c <display>
		Scan_Key();
    31c0:	0e 94 7d 16 	call	0x2cfa	; 0x2cfa <Scan_Key>
    31c4:	9e cf       	rjmp	.-196    	; 0x3102 <main+0x66>

000031c6 <memset>:
    31c6:	dc 01       	movw	r26, r24
    31c8:	01 c0       	rjmp	.+2      	; 0x31cc <memset+0x6>
    31ca:	6d 93       	st	X+, r22
    31cc:	41 50       	subi	r20, 0x01	; 1
    31ce:	50 40       	sbci	r21, 0x00	; 0
    31d0:	e0 f7       	brcc	.-8      	; 0x31ca <memset+0x4>
    31d2:	08 95       	ret

000031d4 <__udivmodqi4>:
    31d4:	99 1b       	sub	r25, r25
    31d6:	79 e0       	ldi	r23, 0x09	; 9
    31d8:	04 c0       	rjmp	.+8      	; 0x31e2 <__udivmodqi4_ep>

000031da <__udivmodqi4_loop>:
    31da:	99 1f       	adc	r25, r25
    31dc:	96 17       	cp	r25, r22
    31de:	08 f0       	brcs	.+2      	; 0x31e2 <__udivmodqi4_ep>
    31e0:	96 1b       	sub	r25, r22

000031e2 <__udivmodqi4_ep>:
    31e2:	88 1f       	adc	r24, r24
    31e4:	7a 95       	dec	r23
    31e6:	c9 f7       	brne	.-14     	; 0x31da <__udivmodqi4_loop>
    31e8:	80 95       	com	r24
    31ea:	08 95       	ret

000031ec <__udivmodhi4>:
    31ec:	aa 1b       	sub	r26, r26
    31ee:	bb 1b       	sub	r27, r27
    31f0:	51 e1       	ldi	r21, 0x11	; 17
    31f2:	07 c0       	rjmp	.+14     	; 0x3202 <__udivmodhi4_ep>

000031f4 <__udivmodhi4_loop>:
    31f4:	aa 1f       	adc	r26, r26
    31f6:	bb 1f       	adc	r27, r27
    31f8:	a6 17       	cp	r26, r22
    31fa:	b7 07       	cpc	r27, r23
    31fc:	10 f0       	brcs	.+4      	; 0x3202 <__udivmodhi4_ep>
    31fe:	a6 1b       	sub	r26, r22
    3200:	b7 0b       	sbc	r27, r23

00003202 <__udivmodhi4_ep>:
    3202:	88 1f       	adc	r24, r24
    3204:	99 1f       	adc	r25, r25
    3206:	5a 95       	dec	r21
    3208:	a9 f7       	brne	.-22     	; 0x31f4 <__udivmodhi4_loop>
    320a:	80 95       	com	r24
    320c:	90 95       	com	r25
    320e:	bc 01       	movw	r22, r24
    3210:	cd 01       	movw	r24, r26
    3212:	08 95       	ret

00003214 <_exit>:
    3214:	f8 94       	cli

00003216 <__stop_program>:
    3216:	ff cf       	rjmp	.-2      	; 0x3216 <__stop_program>
